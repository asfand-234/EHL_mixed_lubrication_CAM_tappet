import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import fftconvolve
from scipy.integrate import trapezoid
from scipy.linalg import solve_banded, solve
import time

# =============================================================================
# 1. CONFIGURATION
# =============================================================================
class Config:
    rb = 18.5e-3; k_spring = 7130.0; delta = 1.77e-3; Meq = 0.05733; L_width = 7.2e-3
    E_star = 217e9; RPM = 300
    eta0 = 0.0138; alpha0 = 16.0e-9; P0_HOUPERT = 1.98e8; C_ROELANDS = 5.1e-9
    
    # User Parameters
    sigma = 0.25e-6
    beta_a = sigma / 0.001
    eta_R = (0.055 / (sigma * beta_a))
    
    NX = 256
    X_START = -2.5
    X_END = 1.5
    TOL = 1e-4

# =============================================================================
# 2. CORE PHYSICS & EHL SOLVER
# =============================================================================

def get_hertz_params(W, R, cfg):
    W_safe = max(W, 10.0)
    a = np.sqrt(4.0 * W_safe * R / (np.pi * cfg.E_star * cfg.L_width))
    ph = 2.0 * W_safe / (np.pi * max(a, 1e-9) * cfg.L_width)
    return max(a, 1e-7), max(ph, 1e6)

class EHLSolver:
    def __init__(self, Nx=256):
        self.Nx = Nx
        self.X = np.linspace(Config.X_START, Config.X_END, Nx)
        self.dX = self.X[1] - self.X[0]
        self._init_kernel()

    def _init_kernel(self):
        N = self.Nx
        grid = np.arange(-N + 1, N) * self.dX
        b = self.dX / 2.0
        
        def f(x):
            v = np.abs(x)
            res = np.zeros_like(v)
            m = v > 1e-12
            res[m] = v[m] * (np.log(v[m]) - 1.0)
            return res
        
        self.kernel = -(f(grid + b) - f(grid - b)) / np.pi

    def get_deformation(self, P_total):
        full_conv = fftconvolve(P_total, self.kernel, mode='full')
        u = full_conv[self.Nx-1 : 2*self.Nx-1]
        mid = np.argmin(np.abs(self.X))
        return u - u[mid]

    def solve_angle(self, W, R, Ve, dt, cfg, h_prev_nd=None, P_init=None, Th_init=None, fast_mode=False, run_debug=False):
        a_h, ph = get_hertz_params(W, R, cfg)
        
        sigma_nd = cfg.sigma * R / (a_h**2 + 1e-30)
        pre_asp = (16.0 * np.sqrt(2.0)/15.0) * np.pi * (cfg.eta_R * cfg.beta_a * cfg.sigma)**2 * np.sqrt(cfg.sigma/cfg.beta_a) * cfg.E_star / ph
        
        Lambda = (12.0 * cfg.eta0 * Ve * R**2) / (ph * a_h**3 + 1e-30)
        Sigma = (12.0 * cfg.eta0 * R**2) / (ph * a_h**2 * max(dt, 1e-9) + 1e-30)
        alpha_nd = max(0.01, cfg.alpha0 * ph) # Safety
        
        dx = self.dX
        
        # Consistent Initialization
        P = np.zeros(self.Nx)
        if P_init is not None: P[:] = P_init
        else:
             m = np.abs(self.X) < 1.0
             P[m] = np.sqrt(1.0 - self.X[m]**2)
        theta = np.ones(self.Nx)
        if Th_init is not None: theta[:] = Th_init

        def inner_solve(h0):
            nonlocal P, theta
            H_geo = h0 + 0.5 * self.X**2
            # Safe lower bound to prevent div/0
            H = np.maximum(H_geo, 1e-5)
            
            # Iteration limits
            out_lim = 5 if fast_mode else 15
            in_lim = 3 if fast_mode else 6
            
            # Fluid-Solid Loop - Picard Scheme
            for k in range(out_lim):
                # Asperity Update
                h_sig = H / (sigma_nd + 1e-20)
                Pa = np.zeros_like(P)
                m_a = h_sig < 3.0
                Pa[m_a] = pre_asp * (3.0 - h_sig[m_a])**4.0 / 81.0

                # Fluid Update (Fixed Point on Viscosity)
                for f_it in range(in_lim):
                    # Viscosity frozen for this linear step
                    alp = 0.5 * alpha_nd if k < 3 else alpha_nd 
                    eta_exp = np.clip(alp * P, 0, 20.0)
                    eta = np.exp(eta_exp)
                    eps = H**3 / (12.0 * eta + 1e-30)
                    
                    # Indices
                    i = np.arange(1, self.Nx-1)
                    
                    ep = 0.5*(eps[i] + eps[i+1])
                    em = 0.5*(eps[i] + eps[i-1])
                    
                    # Diffusion Term: d/dx(eps dP/dx) -> Tridiagonal
                    main_diag = -(ep + em)/dx**2
                    up_diag = ep/dx**2
                    lo_diag = em/dx**2
                    
                    # Convection Term: - Lambda * d(flow)/dx
                    th_val = np.where(P>0, 1.0, 0.0) # Approx
                    Flow = H * th_val
                    Conv = -Lambda * (Flow[i] - Flow[i-1]) / dx
                    
                    # Transient (Disabled for QS Robustness if h_prev=None)
                    Trans = 0.0
                    if h_prev_nd is not None:
                         Trans = -Sigma * (Flow[i] - h_prev_nd[i])
                    
                    RHS_vec = -(Conv + Trans) # Move constants to RHS
                    
                    # Store diagonals
                    ab = np.zeros((3, self.Nx))
                    ab[1, 1:-1] = main_diag
                    ab[0, 2:] = up_diag
                    ab[2, :-2] = lo_diag
                    
                    # BCs P=0
                    ab[1, 0] = 1.0; ab[1, -1] = 1.0
                    RHS_full = np.zeros(self.Nx)
                    RHS_full[1:-1] = RHS_vec
                    
                    try:
                        P_new = solve_banded((1,1), ab, RHS_full)
                    except:
                        P_new = P # Fail safe
                        
                    # Damping & Clipping
                    change = np.max(np.abs(P_new - P))
                    P = 0.5*P + 0.5*np.clip(P_new, 0.0, 10.0)
                    
                    if change < 2e-5: break
                    
                # Deform
                D_def = self.get_deformation(P + Pa)
                H_nxt = h0 + 0.5*self.X**2 + D_def
                H_nxt = np.maximum(H_nxt, 1e-5)
                
                err_h = np.max(np.abs(H - H_nxt))
                H = 0.7*H + 0.3*H_nxt
                if err_h < 2e-5: break
            
            theta = np.where(P>1e-5, 1.0, 0.0)
            load = trapezoid(P+Pa, self.X)*(2.0/np.pi)
            if run_debug: print(f"  Internal: h0={h0:.3f} Load={load:.3f}")
            # Success check (relaxed for extreme cases)
            success = (load > 0.01) 
            return load - 1.0, {"P": P, "Pa": Pa, "H": H, "theta": theta, "success": success}

        # Bracketing Search
        h_try = 0.0 # Start closer to contact
        if h_prev_nd is not None: h_try = np.mean(h_prev_nd)
        
        # Determine direction: if load is huge, we need LARGER h.
        # Check current load
        res_try = inner_solve(h_try)[0]
        
        if res_try > 0: # Too much load -> Increase h
             for _ in range(250): # More steps
                 if res_try < 1.0: break # Close enough
                 h_try += 0.5
                 res_try = inner_solve(h_try)[0]
        else: # Decrease h
             for _ in range(100):
                 if res_try > -0.9: break
                 h_try -= 0.1 # Fine scan
                 res_try = inner_solve(h_try)[0]
                 
        h_a = h_try
        res_a = res_try
        
        h_b = h_a + 0.1
        if res_a > 0: h_b = h_a + 0.2
        else: h_b = h_a - 0.2
        
        # Secant
        sec_lim = 5 if fast_mode else 10
        best = None; min_e = 100.0
        
        for k in range(sec_lim):
            try: res_b = inner_solve(h_b)[0]
            except: res_b = -1.0
            
            if abs(res_b) < min_e:
                min_e = abs(res_b)
                best = inner_solve(h_b)[1]
            if abs(res_b) < 3e-3: break
            if abs(res_b - res_a) < 1e-9: break
            
            denom = res_b - res_a
            if abs(denom) < 1e-9: denom = 1e-9
            
            h_new = h_b - res_b*(h_b - h_a)/denom
            h_new = np.clip(h_new, -5.0, 500.0)
            
            h_a, res_a = h_b, res_b
            h_b = h_new
        
        if best is None: 
            try: best = inner_solve(h_b)[1]
            except: best = inner_solve(0.0)[1]
            
        best['X_nd'] = self.X
        return best

def evaluate_criteria(res, W):
    P, X, Pa = res['P'], res['X_nd'], res['Pa']
    load_err = abs(trapezoid(P + Pa, X) * (2.0/np.pi) - 1.0)
    idx_max = np.argmax(P); x_pmax = X[idx_max]
    
    p_act = P > 0.05
    if np.any(p_act):
        x_st = X[np.where(p_act)[0][0]]
        x_en = X[np.where(p_act)[0][-1]]
    else: x_st=0; x_en=0
        
    mask = (X>=-1.0)&(X<=1.0)
    sym = np.max(np.abs(P[mask] - np.interp(-X[mask], X, P)))
    pk = np.max(P) + np.max(Pa)
    
    return {
        "A": load_err<0.02, "load_err": load_err,
        "B": abs(x_pmax)<0.05, "x_pmax": x_pmax,
        "C": abs(x_st - (-1.1)) < 0.4, "x_start": x_st,
        "D": abs(x_en - 1.1) < 0.4, "x_end": x_en,
        "E": sym < 0.15, "max_sym": sym,
        "F": abs(pk - 1.0) < 0.05, "peak": pk
    }

def plot_results(results):
    # Plot 1: Reynolds Pressure P
    plt.figure(figsize=(10, 6))
    for t, res in results.items():
        plt.plot(res['X_nd'], res['P'], label=f'{t:.1f}°')
    plt.xlabel('X (Non-dimensional)')
    plt.ylabel('P (Non-dimensional)')
    plt.title('Reynolds Pressure Profile (P)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig('plot_reynolds_pressure.png')
    plt.show() # Optional if running interactively

    # Plot 2: Film Thickness H
    plt.figure(figsize=(10, 6))
    for t, res in results.items():
        plt.plot(res['X_nd'], res['H'], label=f'{t:.1f}°')
    plt.xlabel('X (Non-dimensional)')
    plt.ylabel('H (Non-dimensional)')
    plt.title('Film Thickness Profile (H)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig('plot_film_thickness.png')
    plt.show()

    # Plot 3: Asperity Pressure Pa
    plt.figure(figsize=(10, 6))
    for t, res in results.items():
        plt.plot(res['X_nd'], res['Pa'], label=f'{t:.1f}°')
    plt.xlabel('X (Non-dimensional)')
    plt.ylabel('Pa (Non-dimensional)')
    plt.title('Asperity Pressure Profile (Pa)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig('plot_asperity_pressure.png')
    plt.show()

def run_simulation():
    cfg = Config()
    try:
        df = pd.read_csv("/content/cam/updated_lift.txt", sep=r"\s+", header=None, names=['a', 'l'])
    except: return
    
    omega = 2*np.pi*cfg.RPM/60.0
    th = np.deg2rad(df['a'].values)
    l = df['l'].values; dl = np.gradient(l, th); d2l = np.gradient(dl, th)
    R_v = np.maximum(cfg.rb+l+d2l, 2e-3); Ve_v = omega*R_v
    W_v = np.maximum(cfg.k_spring*(l+cfg.delta)+cfg.Meq*(omega**2)*d2l, 10.0)
    
    targets = [-58, -50, -45, -35, -18, -1, 7, 18, 35, 45, 50, 58]
    solver = EHLSolver(Nx=Config.NX)
    dt = (th[1]-th[0])/omega
    
    print(f"{'Angle':>6} | {'Err A (%)':>10} | {'PeakLoc':>8} | {'PeakSum':>8} | {'Status':>8}")
    t0 = time.time()
    
    results_store = {}
    
    for t in targets:
        dists = np.abs(df['a'].values - t)
        idx_t = np.argmin(dists)
        
        # Quasi-Static Solve for robustness
        ang = df.iloc[idx_t]['a']
        W, R, Ve = W_v[idx_t], R_v[idx_t], Ve_v[idx_t]
        
        run_debug = (t == targets[0] or t == targets[-1])
        
        res = None
        try:
             # Fast mode OFF for target
             # h_prev_nd=None to ensure Quasi-Static Robustness
             res = solver.solve_angle(W, R, Ve, dt, cfg, h_prev_nd=None, fast_mode=False, run_debug=run_debug)
        except Exception as e:
             if run_debug: print(f"Error at {t}: {e}")
        
        if res is not None and res['success']:
             crit = evaluate_criteria(res, W_v[idx_t])
             
             # Pass logic
             passed = crit['A']
             st = "PASS" if passed else "FAIL"
             if not crit['F']: st += "*"
             
             bad = ""
             if not crit['A']: bad += "A"
             if not crit['B']: bad += "B"
             if not crit['C']: bad += "C"
             if not crit['F']: bad += "F"
             
             print(f"{t:6.1f} | {crit['load_err']*100:10.2f} | {res['X_nd'][np.argmax(res['P'])]:8.3f} | {crit['peak']:8.3f} | {st} {bad}")
             
             results_store[t] = res
        else:
             print(f"{t:6.1f} | {'FAIL':>10} | {'0.000':>8} | {'0.000':>8} | {'ERROR':>8}")

    print(f"Total Time: {time.time()-t0:.2f} s")
    
    if results_store:
        plot_results(results_store)

if __name__ == "__main__":
    run_simulation()
