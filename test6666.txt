import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import root

# =============================================================================
# 1. CONFIGURATION
# =============================================================================
class Config:
    rb = 18.5e-3; k_spring = 7130.0; delta = 1.77e-3; Meq = 0.05733; L_width = 7.2e-3
    E_star = 217e9; RPM = 300
    eta0 = 0.0138; alpha0 = 16.0e-9; P0_HOUPERT = 1.98e8; C_ROELANDS = 5.1e-9
    sigma = 0.25e-6; beta_a = sigma / 0.001
    eta_R = (0.055 / (sigma * beta_a))
    
    NX = 256
    X_START = -3.0
    X_END = 2.0 # More resolved toward outlet
    TOL = 1e-9

# =============================================================================
# 2. PHYSICS MODELS
# =============================================================================

def fluid_props(P, cfg, ph):
    p_pa = np.clip(P * ph, 0, 5e9)
    ln0 = np.log(cfg.eta0) + 9.67
    Z = cfg.alpha0 / (cfg.C_ROELANDS * ln0)
    eta = np.exp(ln0 * (-1 + (1 + p_pa / cfg.P0_HOUPERT)**Z))
    rho = (1 + 0.6e-9 * p_pa / (1 + 1.7e-9 * p_pa))
    return eta, rho

def asperity_p(H, cfg, sh, ph):
    h_r = np.maximum(H * sh, 1e-12)
    lam = h_r / cfg.sigma
    pre = (16.0 * np.sqrt(2.0) / 15.0) * np.pi * (cfg.eta_R * cfg.beta_a * cfg.sigma)**2 * np.sqrt(cfg.sigma / cfg.beta_a) * cfg.E_star
    pa = np.zeros_like(H)
    m2, m3 = (lam < 1.0), (lam >= 1.0) & (lam <= 3.0)
    pa[m2] = 1.0 - lam[m2] + 0.1 * lam[m2]**2
    pa[m3] = 0.2 * (2.0 - lam[m3])**2
    return (pre * pa) / ph

def build_K(Nx, dX):
    g = np.arange(-Nx + 1, Nx) * dX; b = dX / 2.0
    def sl(v):
        br = np.abs(v); res = np.zeros_like(v); m=br>1e-15
        res[m] = v[m]*np.log(br[m]); return res
    kn = sl(g+b) - sl(g-b) - 2*b; ids = np.arange(Nx); K = np.zeros((Nx, Nx))
    for r in range(Nx):
        K[r, :] = kn[(Nx-1) + (r - ids)] / (-1.0 * np.pi) 
    return K - 0.5 * (K[0, :] + K[-1, :])

def get_dh_h0(W, R, Ve, cfg):
    G = cfg.alpha0 * cfg.E_star; U = (cfg.eta0 * Ve) / (cfg.E_star * R); W_dh = W / (cfg.E_star * R * cfg.L_width)
    H_dh_c = 2.69 * (G**0.53) * (U**0.67) * (W_dh**-0.067)
    a4 = np.sqrt(4.0 * W * R / (np.pi * cfg.E_star * cfg.L_width)); sh = a4**2 / R
    return (H_dh_c * R) / sh

# =============================================================================
# 3. TRANSIENT CYCLE SOLVER
# =============================================================================

def run_transient_cycle():
    cfg = Config()
    try:
        df = pd.read_csv("updated_lift.txt", sep=r"\s+", header=None, names=['a', 'l'])
    except: return

    omega = 300 * 2 * np.pi / 60.0; th = np.deg2rad(df['a'].values)
    l = df['l'].values; dl = np.gradient(l, th); d2l = np.gradient(dl, th)
    R_val = np.maximum(cfg.rb + l + d2l, 2.0e-3); Ve_val = omega * R_val
    W_val = np.maximum(cfg.k_spring*(l+cfg.delta) + cfg.Meq*(omega**2)*d2l, 10.0)
    
    targets = [-58, -50, -45, -35, -18, -1, 7, 18, 35, 45, 50, 58]
    X = np.linspace(cfg.X_START, cfg.X_END, cfg.NX); dX = X[1]-X[0]; Nx = cfg.NX; K_eff = build_K(Nx, dX)
    
    start_idx = df.index[df['a'] >= -62].tolist()[0]
    dt = (th[1]-th[0])/omega; p_rh_prev = None; results_map = {}
    
    p_init = np.zeros(Nx-2); m_hz = np.abs(X[1:-1]) < 1.0; p_init[m_hz] = np.sqrt(np.maximum(1 - X[1:-1][m_hz]**2, 1e-12))
    h0_stat = max(get_dh_h0(W_val[start_idx], R_val[start_idx], Ve_val[start_idx], cfg), 0.5)
    x_state = np.concatenate([p_init, [np.log(h0_stat)]])
    
    print(f"{'Angle':>6} | {'Hmin(um)':>10} | {'W_err %':>8} | {'PeakLoc':>8} | {'Status':>8}")

    for i in range(start_idx, len(df)):
        ang = df.iloc[i]['a']; W, R, Ve = W_val[i], R_val[i], Ve_val[i]
        a4 = np.sqrt(4.0 * W * R / (np.pi * cfg.E_star * cfg.L_width)); ph = 2.0*W/(np.pi*a4*cfg.L_width); sh = a4**2 / R
        eps = (ph * a4**3) / (12.0 * cfg.eta0 * (Ve+1e-15) * R**2); sqf = 2.0 * (a4/(Ve+1e-15))/dt

        def residual_func(vec):
            P_in, zh0 = vec[:-1], np.clip(vec[-1], -10, 10); h0 = np.exp(zh0)
            PF = np.zeros(Nx); PF[1:-1] = np.maximum(P_in, 0.0)
            H = h0 + 0.5*X**2 + K_eff @ PF; PA = asperity_p(H, cfg, sh, ph)
            if np.any(PA > 1e-4): H = h0 + 0.5*X**2 + K_eff @ (PF + PA); PA = asperity_p(H, cfg, sh, ph)
            Hr = np.maximum(H, 1e-11)
            eta, rho = fluid_props(PF, cfg, ph); rm = 0.5*(rho[:-1]+rho[1:]); hm = 0.5*(Hr[:-1]+Hr[1:]); em = 0.5*(eta[:-1]+eta[1:])
            D = (eps * rm * (hm**3)) / (em + 1e-35)
            ps = (D[1:]*(PF[2:]-PF[1:-1]) - D[:-1]*(PF[1:-1]-PF[0:-2]))/(dX**2)
            trh = rho * H; cu = (trh[1:-1] - trh[:-2])/dX
            sq = sqf * (trh[1:-1] - p_rh_prev[1:-1]) if p_rh_prev is not None else 0.0
            r_reyn = (ps - cu - sq)
            r_load = (np.trapezoid(PF + PA, dx=dX) - np.pi/2)
            return np.concatenate([r_reyn * 1.0, [r_load * 1000.0]]) # Heavy load constraint

        sol = root(residual_func, x_state, method='lm', tol=cfg.TOL, options={'maxiter': 500, 'factor': 0.05})
        if not sol.success or np.linalg.norm(sol.fun) > 0.1:
            h0_dh = max(get_dh_h0(W, R, Ve, cfg), 0.1)
            p_g = np.zeros(Nx-2); p_g[m_hz] = np.sqrt(np.maximum(1 - X[1:-1][m_hz]**2, 1e-12))
            sol = root(residual_func, np.concatenate([p_g, [np.log(h0_dh)]]), method='lm', tol=1e-8, options={'maxiter': 500})
            
        x_state = sol.x; PF_sol = np.zeros(Nx); PF_sol[1:-1] = np.maximum(x_state[:-1], 0.0)
        h0_sol = np.exp(np.clip(x_state[-1], -10, 10)); H_sol = h0_sol + 0.5*X**2 + K_eff @ PF_sol
        PA_sol = asperity_p(H_sol, cfg, sh, ph)
        if np.any(PA_sol > 1e-5): H_sol = h0_sol + 0.5*X**2 + K_eff @ (PF_sol + PA_sol); PA_sol = asperity_p(H_sol, cfg, sh, ph)
        _, rhob = fluid_props(PF_sol, cfg, ph); p_rh_prev = rhob * H_sol
        
        if any(abs(ang - t) < 0.25 for t in targets):
            ta = min(targets, key=lambda t: abs(ang - t))
            if ta not in results_map:
                w_err = abs(np.trapezoid(PF_sol + PA_sol, dx=dX) - np.pi/2)/(np.pi/2)*100
                hmin = np.min(H_sol) * sh * 1e6; ml = X[np.argmax(PF_sol)]
                status = "PASS" if w_err < 1.0 and abs(ml) < 0.9 else "FAIL"
                print(f"{ang:6.1f} | {hmin:10.4f} | {w_err:8.2f} | {ml:8.3f} | {status}")
                results_map[ta] = {'X': X, 'P': PF_sol, 'Pa': PA_sol, 'H': H_sol}
        if ang >= 60: break

    plt.figure(figsize=(15, 10))
    for j, t in enumerate(targets):
        if t in results_map:
            r = results_map[t]; plt.subplot(4, 3, j + 1)
            plt.plot(r['X'], r['P'], 'b', label='P'); plt.plot(r['X'], r['Pa'], 'r--', label='Pa')
            plt.title(f"Angle {t}"); plt.grid(True)
    plt.tight_layout(); plt.savefig("results_robust.png")

if __name__ == "__main__":
    run_transient_cycle()
