

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import root

class EHLSolver:
    def __init__(self):
        print("Init start")
        # Constants
        self.P0_ref = 0.5e9 # 0.5 GPa Ref
        self.mu00 = 0.01381
        self.muinf = 6.315e-5
        self.Pr = 1.98e8
        self.alpha_input = 15e-9
        self.z_input = 0.65
        
        self.E1 = 210e9
        self.E2 = 210e9
        self.nu1 = 0.3
        self.nu2 = 0.3
        self.E_prime = 2 / ((1 - self.nu1**2)/self.E1 + (1 - self.nu2**2)/self.E2)
        
        self.B = 16.25e-3 # Roller Length (m)
        self.R = 5.35e-3  
        # Physics Parameters (User Updated)
        self.Um = 0.27 # m/s (Entrainment Velocity)
        self.Vcycle = self.Um  
  
        self.mu00 = 0.01381 # Pa.s
        self.alpha_input = 15e-9 # 1/Pa
        self.P0_ref = 0.5e9 # 0.5 GPa ref
        self.Pr = 1.96e8 # Roelands Pr
        self.muinf = 6.31e-5 # Roelands mu_inf
        self.rho0 = 870.0 # kg/m3 (Standard Oil Density)
        self.Cp = 2000.0 # J/kgK (Standard Oil Specific Heat)
        
        # Grid
        self.N = 501 
        self.delta_ad = 0.05 # significantly reduced to sharpen spike and profile
        
        # Mixed Lubrication Parameters (Greenwood-Tripp)
        # STRICT USER PARAMETERS (DO NOT CHANGE)
        self.sigma = 0.2e-6  # 0.2 um
        self.eta_beta_sigma = 0.04
        self.sigma_beta_ratio = 0.001 # sigma/beta
        # K_GT Coefficient
        self.K_GT = (16 * np.pi * np.sqrt(2) / 15) * (self.eta_beta_sigma**2) * np.sqrt(self.sigma_beta_ratio) * self.E_prime
        
        # Thermal Parameters
        self.T0_C = 90.0 # Operating Temp (Inlet) - User Spec
        self.T0_K = self.T0_C + 273.15 # 363.15 K
        self.beta0 = 0.04 # 1/K 
        self.gamma_therm = 6.5e-4 # 1/K 
        self.k_therm = 0.15 # W/mK 
        
        ln_eta0 = np.log(self.mu00)
        self.S0 = self.beta0 * (self.T0_K - 138.0) / (ln_eta0 + 9.67)
        self.Z_houper = self.alpha_input / (5.11e-9 * (ln_eta0 + 9.67))
        
        # Use Max Load for Grid Sizing to ensure Domain covers the contact even at low loads?
        # Actually, using a fixed large 'a' (from 300N) ensures the physical domain is large enough (-4a to 2.5a).
        # If we shrink 'a' for 64N, the domain [-0.06, 0.03] is too short for film recovery.
        # So we should validly use the default setup (300N) or explicit max load.
        
        # Reset Grid to Max Load Basis
        self.setup_grid() # Uses 300N internally by default
        
        # Now update Load for the specific case
        target_load = 64.0 # Example, this would be passed in or set by user
        self.W = target_load
        
        # Re-calculate dependent parameters for this load (but KEEP Grid X)
        # We need Hertz P for this load to normalize correctly if needed, 
        # BUT 'setup_grid' sets self.a_Hertz and self.Pmh based on 300N.
        # We should calculate specific case parameters separately.
        
        # Update case-specifics
        Wl = self.W / self.B
        a_case = np.sqrt(8 * Wl * self.R / (np.pi * self.E_prime))
        Pmh_case = 2 * Wl / (np.pi * a_case)
        
        # IMPORTANT: The Solver uses self.X (fixed domain).
        # It normalizes Pressure by P0_ref (0.5 GPa).
        # It does NOT strictly require X to be normalized by a_case.
        # So running with a larger physical grid is fine.
        
        print(f"  Grid Setup: a_grid={self.a_Hertz*1e6:.1f}um, Domain=[{self.X[0]*self.R*1e3:.3f}, {self.X[-1]*self.R*1e3:.3f}] mm")
        print(f"  Case Phys : a_load={a_case*1e6:.1f}um, Load={self.W} N")
    
        # State
        self.F0_norm = 0.0 
        self.dt = 1e-5
        self.F0_norm = 0.0 
        self.dt = 1e-5
        # FORCE TRANSIENT on permanently
        self.is_transient = True
        self.rho_old = None
        self.H_old = None
        self.kw = 0.0
        self.sigma_factor = 1.0 
        
        # Thermal State
        self.T_current = np.full(self.N, self.T0_K)
        
        print("Init done")
    
    # ... (skipping unchanged methods usually, but replace tool needs context) ...
    # Wait, I need to implement calc_temperature_rise below.
    # Splitting into 2 edits might be safer if they are far apart. 
    # But I can do the init edit and the method edit if I grab the whole block or do 2 steps.
    # The prompt "Replace calc_temperature_rise with Energy Equation loop" implies I should do that.
    # I will stick to editing INIT here first, then calc_temperature_rise separately to be safe.
    # Actually, I can combine if I reference lines.
    # I'll restart `calc_temperature_rise` in a separate call.

    # This call is JUST for INIT updates (Cp, rho0, delta_ad).
    
    def setup_grid(self, load_override=None):
        print("  Setup grid start")
        # Dynamic Grid Sizing
        # Use target load if provided, else max 300N
        W_grid = load_override if load_override else 300.0
        Wl = W_grid / self.B
        self.a_Hertz = np.sqrt(8 * Wl * self.R / (np.pi * self.E_prime))
        
        if self.a_Hertz == 0: 
            self.Pmh = 0.0
        else:
            self.Pmh = 2 * Wl / (np.pi * self.a_Hertz)
        
        # Domain - Widened for 64N (smaller a_Hertz -> X points closer)
        # But we want fixed domain PHYSICAL size? No, usually X = x/a.
        # If we scale by 'a', then -4 to 2.5 covers the contact.
        # So we keep dimensionless limits, but 'a' changes.
        # Domain - Widened significantly to allows profiles to decay naturally (avoid boundary spreading)
        # Extended inlet to -6a to prevent starvation
        # Extended inlet to -6a to prevent starvation
        # FIX: For light loads (small a), -6 is not enough. Extend to -12.
        left = -12.0 * self.a_Hertz / self.R
        right = 4.0 * self.a_Hertz / self.R
        
        self.X_dim = np.linspace(left, right, self.N) 
        self.dx = self.X_dim[1] - self.X_dim[0]
        self.X = self.X_dim 
        
        # Parameters Update
        self.A_C = self.R * self.P0_ref / (12 * self.mu00 * self.Um)
        self.CE = -4 * self.P0_ref / (np.pi * self.E_prime)
        self.Wld = Wl / (self.R * self.P0_ref)
        self.Umd = self.Vcycle / self.Um
        self.Wld = Wl / (self.R * self.P0_ref)
        self.Umd = self.Vcycle / self.Um
        # Physics Correction: Entrainment velocity is u_avg = Um.
        # Terms normalized by 12*mu*Um. RHS is 12*mu*u_avg * dH/dx.
        # So coefficient should be 1.0. 
        self.u1d = self.Umd * 1.0 
        
        # Scaling Coefficient
        Rey_Stiffness = self.A_C / (self.dx**2)
        
        self.hmin_dim = 0.0
        self.g1 = 1e15 * Rey_Stiffness # Hard Wall
        self.gamma_h = 1e12 # Cavitation Penalty
        
        self.calculate_D_matrix()
        self.T_current = np.full(self.N, self.T0_K)
        print(f"    Setup grid done (W_grid={W_grid}N, a_Hertz={self.a_Hertz*1e3:.3f}mm)")
        
    def calculate_D_matrix(self):
        print("    Calc D Matrix start")
        N = self.N
        dx = self.dx
        D = np.zeros((N, N))
        b = dx / 2.0
        
        # Exact integral of ln|x-s|
        for i in range(N):
            xi = self.X_dim[i]
            for j in range(N):
                xj = self.X_dim[j]
                
                d1 = xi - (xj - b)
                d2 = xi - (xj + b)
                
                def F(u):
                    if abs(u) < 1e-12: return 0.0
                    return u * np.log(abs(u)) - u
                
                D[i, j] = (F(d1) - F(d2))
                
        self.D_mat = D * self.CE # Note: D_mat operates on P_dimensionless -> Deflection_dimensionless
        print("    Calc D Matrix done")

    # --- Physics ---
     # --- Physics ---

    def calc_flow_factors(self, H_dimless):
        """
        Patir & Cheng (isotropic roughness) pressure and shear flow factors.
        Lambda = h / sigma. For perfectly smooth surfaces, phi = 1.
        """
        if self.sigma_factor <= 0.0:
            ones = np.ones_like(H_dimless)
            return ones, ones

        sigma_eff = self.sigma * self.sigma_factor
        h_real = H_dimless * self.R
        lambda_ratio = h_real / sigma_eff

        # Physical floor: negative film thickness implies contact -> lambda = 0.
        lambda_ratio = np.where(lambda_ratio < 0.0, 0.0, lambda_ratio)

        # Patir & Cheng exponential fits (isotropic surfaces)
        phi_x = 1.0 - 0.9 * np.exp(-0.56 * lambda_ratio)
        phi_s = 1.0 - 0.9 * np.exp(-0.2 * lambda_ratio)

        return phi_x, phi_s
    def ro(self, P_dim_less, T_K=None):
        # Dowson-Higginson Thermal
        if T_K is None: T_K = self.T_current
        
        P = np.maximum(P_dim_less * self.P0_ref, 0)
        
        # Density Pressure Part
        a = 0.6e-9
        b = 1.7e-9
        term_p = (1 + (a * P) / (1 + b * P))
        
        # Thermal Part
        DeltaT = T_K - self.T0_K
        term_T = (1 - self.gamma_therm * DeltaT)
        
        return term_p * term_T

    def droo(self, P_dim_less, T_K=None):
        if T_K is None: T_K = self.T_current
        P = np.maximum(P_dim_less * self.P0_ref, 0)
        
        a = 0.6e-9
        b = 1.7e-9
        df_dP = a / ((1 + b*P)**2)
        
        DeltaT = T_K - self.T0_K
        term_T = (1 - self.gamma_therm * DeltaT)
        
        return df_dP * self.P0_ref * term_T

    # Skipping dro2 (2nd deriv) as it's not strictly used in Newton K matrix often
    
    def c_mu(self, P_dim_less, T_K=None):
        # Houpert's Equation (Thermal)
        if T_K is None: T_K = self.T_current
        P = np.maximum(P_dim_less * self.P0_ref, 0)
        
        ln_eta0 = np.log(self.mu00)
        C1 = ln_eta0 + 9.67
        
        T_term = (T_K - 138.0) / (self.T0_K - 138.0)
        T_term = np.maximum(T_term, 1e-5)
        
        term_T_S0 = T_term**(-self.S0)
        
        # Pressure Term
        term_P_Z = (1 + P / self.Pr)**self.Z_houper
        
        bracket = term_T_S0 * term_P_Z - 1.0
        
        exponent = C1 * bracket
        
        return self.mu00 * np.exp(exponent)

    # dmu / dP needed for Jacobian.
    def calc_temperature_rise(self, P_dim, H_dim):
        # Karthikeyan et al. Analytical Expression
        
        # Grid loop
        T_dist = np.full_like(P_dim, self.T0_K) # Start with T0
        
        if self.a_Hertz == 0: return T_dist
        
        # Convert Dimensions
        P_real = P_dim * self.P0_ref
        H_real = H_dim * self.R
        
        dx_real = (self.X_dim[1] - self.X_dim[0]) * self.R
        a_strip = dx_real / 2.0 
        
        # Marching solution
        # T[0] = T0
        
        # Sliding Velocity (Estimated for Cam-Tappet)
        # Assuming U_tappet ~ 0, U_cam ~ 2*Um ?? 
    # --- Analytical Thermal Model ---
    def calc_temperature_rise(self, P_dist, H_dist, Pa_dist=None):
        """
        Calculates Delta T using the simplified analytical model provided by the user.
        Delta T = [ (um*T* gamma* h*p_max + (2*a_hertz*eta*um^2 /h)) / 
                  ((a_hertz*k/h) - um*T*h*p_max) ]
                  
        ADJUSTMENT: The denominator term `um*T*h*p_max` is dimensionally inconsistent with `a*k/h` (W/mK).
        We assume the intended term is `um * gamma * h * p_max` which matches W/mK.
        """
        # 1. Get Dimensional Variables
        um = self.Um # Entraining velocity [m/s]
        gamma = self.gamma_therm # Thermal expansion [1/K]
        k = self.k_therm # Conductivity [W/mK]
        a_hertz = self.a_Hertz if self.a_Hertz > 0 else 1.0 # Radius [m]
        
        # P_dist is dimensionless. Convert to Pa.
        P_real = P_dist * self.P0_ref
        if Pa_dist is not None:
             pass
        
        p_max = np.max(P_real) # Scalar maximum [Pa]
        
        # H_dist is H/R. Convert to m.
        h = H_dist * self.R
        h = np.maximum(h, 1e-9) # Avoid division by zero
        
        # Eta (Viscosity) as function of pressure
        # P_dist is dimensionless, needed for c_mu
        eta = self.c_mu(P_dist, self.T_current) # [Pa.s]
        
        # T (Current Temperature) [K]
        T = self.T_current
        
        # 2. Compute Terms
        # Use P_real (Local Pressure) instead of p_max (Scalar)
        
        # Numerator Term 1: um * T * gamma * h * P(x)
        # Units: [m/s] * [K] * [1/K] * [m] * [Pa] = [W/m]
        num_term_1 = um * T * gamma * h * P_real
        
        # Numerator Term 2: 2 * a_hertz * eta * um^2 / h
        # Units: [m] * [Pa.s] * [m2/s2] / [m] = [Pa * m2/s] = [N/m2 * m2/s] = [N/s] = [J/m/s] = [W/m]
        num_term_2 = (2.0 * a_hertz * eta * um**2) / h
        
        numerator = num_term_1 + num_term_2
        
        # Denominator Term 1: a_hertz * k / h
        # Units: [m] * [W/mK] / [m] = [W/mK]
        den_term_1 = (a_hertz * k) / h
        
        # Denominator Term 2: um * gamma * h * P(x)
        # Units: [m/s] * [1/K] * [m] * [Pa] = [W/mK]. Match.
        den_term_2 = um * gamma * h * P_real
        
        denominator = den_term_1 - den_term_2
        
        # Safety: Avoid singularity or negative denominator (physical instability)
        denominator = np.where(denominator < 1e-5, 1e-5, denominator) # Clip to positive small
        
        Delta_T = numerator / denominator
        
        # Diagnostic placeholders
        Phi_dist = numerator 
        Alpha_dist = denominator
        Heff_dist = h
        
        T_new = self.T0_K + Delta_T
        
        return T_new, Phi_dist, Alpha_dist, Heff_dist

    def run_single_case(self, label, is_thermal=True):
        print(f"\n=== Running Case: {label} (Thermal={is_thermal}) ===")
        
        # Save Physics Params
        saved_gamma = self.gamma_therm
        saved_S0 = self.S0
        
        if not is_thermal:
            self.gamma_therm = 0.0
            # S0 affects viscosity. Isothermal usually means T is constant.
            # If S0=0, viscosity still depends on T, but if T is constant (T0), then S0 doesn't matter much.
            # But Houpert Z depends on S0? No.
            self.S0 = 0.0
            self.T_current = np.full(self.N, self.T0_K)
            
        target_load = 64.0 # N (User Specified)
        
        # 1. Steady Smooth
        print(f"--- 1. Computing Initial Steady State (Smooth, Load={target_load}N) ---")
        self.sigma_factor = 0.0
        V_smooth = self.solve_steady(load_target=target_load)
        
        # 2. Ramp Roughness
        print("--- 2. Ramping Roughness (Smooth -> Mixed) ---")
        steps = 10
        V_current = V_smooth.copy()
        roughness_factors = np.linspace(0.05, 1.0, steps)
        
        for i, fac in enumerate(roughness_factors):
            self.sigma_factor = fac
            # print(f"    Roughness Ramp {i+1}/{steps}: Sigma Factor = {fac:.2f}")
            
            # Thermal Loop for Roughness Step
            # Reduced iterations for Isothermal to save time? No, need robustness.
            max_t_loops = 5 if is_thermal else 1
            
            for t_iter in range(max_t_loops):
                 V_new, success, res, k = self.newton_solve(V_current, tol=1e-6, max_iter=20)
                 
                 P_rey, Pa, H_elastic = self.get_full_state(V_new)
                 if is_thermal:
                     T_new, Phi, Alpha, H_eff = self.calc_temperature_rise(P_rey, H_elastic, Pa)
                     self.T_current = 0.5 * T_new + 0.5 * self.T_current
                 
                 V_current = V_new
                 
            if not success:
                 print(f"    WARNING: Roughness Step {i+1} Not Fully Converged. Res={res:.2e}")
        
        V_rough = V_current
        print("  Roughness Ramp Complete.")
        
        # 3. Transient Run
        print(f"--- 3. Running Transient Simulation ({target_load}N) ---")
        # Run for a short duration to establish transient behavior (e.g., one pass or sufficient steps)
        # Using solve_transient_ramp with constant load to simulate time evolution
        # V_cycle in setup is Um. 
        # Duration? 2*a_Hertz / Um ~ 0.2ms. Run for 0.5ms.
        # User said "Simulate 1D Transient".
        
        # We start from Rough Steady solution.
        V_trans = self.solve_transient_ramp(V_rough, target_load, target_load, duration=0.0005, steps=20)
        
        P_rey, Pa, H = self.get_full_state(V_trans)
        
        # Use T_current from the end of transient
        # In solve_transient_ramp, we act on self.T_current directly.
        T_dist = self.T_current.copy()
        
        # Get final diagnostics
        # Get final diagnostics
        _, Phi, Alpha, H_eff = self.calc_temperature_rise(P_rey, H, Pa)
        
        # Restore Physics
        self.gamma_therm = saved_gamma
        self.S0 = saved_S0
        if not is_thermal:
             # Reset T for safety for next run
             self.T_current = np.full(self.N, self.T0_K)
        
        return self.X * self.R * 1e3, P_rey, Pa, H, T_dist, Phi, Alpha, H_eff

    def run_study(self):
        # Run Isothermal
        X_iso, P_rey_iso, Pa_iso, H_iso, T_iso, _, _, _ = self.run_single_case("Isothermal", is_thermal=False)
        
        # Run Thermal
        X_thm, P_rey_thm, Pa_thm, H_thm, T_thm, Phi_thm, Alpha_thm, Heff_thm = self.run_single_case("Thermal", is_thermal=True)
        
        # Normalize Results
        P_rey_iso_nd = (P_rey_iso * self.P0_ref) / self.Pmh
        Pa_iso_nd = (Pa_iso * self.P0_ref) / self.Pmh
        
        P_rey_thm_nd = (P_rey_thm * self.P0_ref) / self.Pmh
        Pa_thm_nd = (Pa_thm * self.P0_ref) / self.Pmh
        
        # Plotting
        print("Plotting Comparisons...")
        
        # Graph 1: Reynolds Pressure
        plt.figure(figsize=(10, 6))
        plt.plot(X_iso, P_rey_iso_nd, 'b--', label='Isothermal')
        plt.plot(X_thm, P_rey_thm_nd, 'r-', label='Thermal')
        plt.xlabel('X (mm)')
        plt.ylabel('P_rey / Pmh')
        plt.title('Graph-1: Non-dimensional Reynolds Pressure')
        plt.legend()
        plt.grid(True)
        plt.savefig('Graph1_Reynolds_Pressure.png')
        
        # Graph 2: Asperity Pressure
        plt.figure(figsize=(10, 6))
        plt.plot(X_iso, Pa_iso_nd, 'b--', label='Isothermal')
        plt.plot(X_thm, Pa_thm_nd, 'r-', label='Thermal')
        plt.xlabel('X (mm)')
        plt.ylabel('P_asp / Pmh')
        plt.title('Graph-2: Non-dimensional Asperity Pressure')
        plt.legend()
        plt.grid(True)
        plt.savefig('Graph2_Asperity_Pressure.png')
        
        # Graph 3: Film Thickness
        plt.figure(figsize=(10, 6))
        plt.plot(X_iso, H_iso * 1e5, 'b--', label='Isothermal')
        plt.plot(X_thm, H_thm * 1e5, 'r-', label='Thermal')
        plt.xlabel('X (mm)')
        plt.ylabel('H / R (x10^5)')
        plt.title('Graph3_Film_Thickness') # Fixed title
        plt.legend()
        plt.grid(True)
        plt.savefig('Graph3_Film_Thickness.png')
        
        # Graph 4: Delta T
        plt.figure(figsize=(10, 6))
        plt.plot(X_thm, T_thm - self.T0_K, 'r-', label='Thermal Rise')
        plt.xlabel('X (mm)')
        plt.ylabel('Delta T (K)')
        plt.title('Graph-4: Temperature Rise (Delta T vs X)')
        plt.legend()
        plt.grid(True)
        plt.savefig('Graph4_Temperature.png')
        
        # Graph 5: Thermal Diagnostics
        fig, ax1 = plt.subplots(figsize=(10, 6))
        
        color = 'tab:red'
        ax1.set_xlabel('X (mm)')
        ax1.set_ylabel('Heat Gen (W/m2)', color=color)
        ax1.plot(X_thm, Phi_thm, color=color, label='Phi (Source)')
        ax1.tick_params(axis='y', labelcolor=color)
        
        ax2 = ax1.twinx()  
        color = 'tab:blue'
        ax2.set_ylabel('Alpha (1/m)', color=color)  
        ax2.plot(X_thm, Alpha_thm, color=color, linestyle='--', label='Alpha (Decay)')
        ax2.tick_params(axis='y', labelcolor=color)
        
        plt.title('Graph-5: Thermal Diagnostics (Phi & Alpha)')
        fig.tight_layout()  
        plt.grid(True)
        plt.savefig('Graph5_Thermal_Diagnostics.png')
        
        # PRINT DIAGNOSTICS FOR AI ANALYSIS
        print("\n=== THERMAL DIAGNOSTICS (INTERNAL) ===")
        print(f"Max Phi: {np.max(Phi_thm):.4e} W/m2")
        print(f"Max Alpha: {np.max(Alpha_thm):.4e} 1/m")
        print(f"Min Alpha: {np.min(Alpha_thm):.4e} 1/m")
        print(f"Phi Peaks at: {X_thm[np.argmax(Phi_thm)]:.4f} mm")
        
        # Check smoothness
        dPhi = np.diff(Phi_thm)
        print(f"Mean Abs dPhi: {np.mean(np.abs(dPhi)):.4e}")
        print(f"Max Abs dPhi: {np.max(np.abs(dPhi)):.4e}")

        
        # Print Analysis Data
        print("\n=== Detailed Comparison Data ===")
        print(f"{'Metric':<25} | {'Isothermal':<15} | {'Thermal':<15} | {'% Diff':<10}")
        print("-" * 75)
        
        metrics = [
            ("Max Reynolds P (ND)", np.max(P_rey_iso_nd), np.max(P_rey_thm_nd)),
            ("Max Asperity P (ND)", np.max(Pa_iso_nd), np.max(Pa_thm_nd)),
            ("Min Film H (ND x10^5)", np.min(H_iso)*1e5, np.min(H_thm)*1e5),
            ("Central Film H (ND x10^5)", H_iso[len(H_iso)//2]*1e5, H_thm[len(H_thm)//2]*1e5),
            ("Max Delta T (K)", 0.0, np.max(T_thm - self.T0_K))
        ]
        
        for name, iso, thm in metrics:
            pct = 0.0
            if abs(iso) > 1e-9:
                pct = (thm - iso) / iso * 100
            print(f"{name:<25} | {iso:<15.4f} | {thm:<15.4f} | {pct:<10.2f}")
            
        print("-" * 75)
        print("Comparison Complete. Graphs saved.")

    
    # --- Asperity Contact ---
    def calc_asperity(self, H_dimless, calc_deriv=False):
        # H is dimensionless H/R.
        # Need actual H for H/sigma
        if self.a_Hertz == 0: # Safety
            H_real = H_dimless * 0
        else:
            # Grid H is h/R. So H_real = H * R.
            H_real = H_dimless * self.R
        Lambda = H_real / self.sigma
        
        # F_5/2 approximation (Zhu & Hu 2001 EHL)
        # F5/2(LAMBDA) approx 4.4084e-5 * (4 - LAMBDA)^6.804
        
        mask = Lambda < 4.0
        Pa_real = np.zeros_like(Lambda)
        dPa_dH_real = np.zeros_like(Lambda)
        
        if np.any(mask):
            val = 4.0 - Lambda[mask]
            # Coeffs
            A_fit = 4.4084e-5
            Z_fit = 6.804
            
            F_stat = A_fit * (val**Z_fit)
            dF_dL = -A_fit * Z_fit * (val**(Z_fit-1)) # dF/dLambda
            # Note: dF/dL is negative usually because as L increases, F decreases.
            
            # Scale by sigma_factor
            Pa_real[mask] = self.K_GT * F_stat * self.sigma_factor
            
            if calc_deriv:
                # dPa/dH = dPa/dL * dL/dH = dPa/dL * (1/sigma)
                # Scale derivative too
                dPa_dH_real[mask] = (self.K_GT * dF_dL * self.sigma_factor) / self.sigma
                # dPa/dH_dim = dPa/dH_real * dH_real/dH_dim * (1/P0_ref)? 
        # dH_real/dH_dim = R
        Pa_dim = Pa_real / self.P0_ref
        
        if calc_deriv:
            scale_H = self.R
            dPa_dH_dim = (dPa_dH_real * scale_H) / self.P0_ref
            return Pa_dim, dPa_dH_dim
        else:
            return Pa_dim

    # --- Artificial Diffusion Terms ---
    
    def beta_ad(self, P, H, eps_shift):
        idx = np.arange(2, self.N-1) 
        rho_prime = self.droo(P)
        val = self.dx * rho_prime * H 
        
        if eps_shift == 0: 
            beta = 0.5 * (val[idx] + val[idx-1])
        else: 
            beta = 0.5 * (val[idx] + val[idx+1])
            
        return beta * (self.delta_ad / self.A_C)
        
    def get_eps_beta(self, P, H):
        idx = np.arange(2, self.N-1)
        
        rho = self.ro(P)
        mu = self.c_mu(P)
        phi_x, _ = self.calc_flow_factors(H)
        
        rho_sum_1 = rho[idx] + rho[idx-1]
        mu_sum_1 = mu[idx] + mu[idx-1]
        H_sum_1 = H[idx] + H[idx-1]
        phi_x_avg_1 = 0.5 * (phi_x[idx] + phi_x[idx-1])
        
        beta1 = self.beta_ad(P, H, 0)
        eps1 = (rho_sum_1 * (H_sum_1**3) * 0.125 * phi_x_avg_1 / mu_sum_1) + beta1
        
        rho_sum_2 = rho[idx] + rho[idx+1]
        mu_sum_2 = mu[idx] + mu[idx+1]
        H_sum_2 = H[idx] + H[idx+1]
        phi_x_avg_2 = 0.5 * (phi_x[idx] + phi_x[idx+1])
        
        beta2 = self.beta_ad(P, H, 1)
        eps2 = (rho_sum_2 * (H_sum_2**3) * 0.125 * phi_x_avg_2 / mu_sum_2) + beta2
        
        return eps1, eps2

    # --- Integral Residual & Jacobian ---
    
    def calc_reynolds_residual(self, P_rey, H):
        idx = np.arange(2, self.N-1)
        
        # Reynolds
        eps1, eps2 = self.get_eps_beta(P_rey, H)
        
        term_pois = (self.A_C / self.dx**2) * (
            P_rey[idx-1]*eps1 - P_rey[idx]*(eps1+eps2) + P_rey[idx+1]*eps2
        )
        
        rho = self.ro(P_rey)
        drho = self.droo(P_rey)
        _, phi_s = self.calc_flow_factors(H)
        
        # Couette Term Discretization
        # Use Upwind 1st Order for Stability to recover film thickness.
        # Central Difference was causing collapse to 4nm.
        term_couette = (self.u1d / self.dx) * (
            rho[idx]*H[idx]*phi_s[idx] - rho[idx-1]*H[idx-1]*phi_s[idx-1]
        ) 
        
        term_squeeze = 0.0
        if self.is_transient and self.rho_old is not None:
             term_time = (rho[idx]*H[idx] - self.rho_old[idx]*self.H_old[idx]) / self.dt
             term_squeeze = (self.R / self.Um) * term_time
             
        f1 = self.gamma_h * np.minimum(P_rey[idx], 0)
        f4 = self.g1 * np.maximum(self.hmin_dim - H[idx], 0)**2
        
        F_rey = term_pois - term_couette - term_squeeze - f1 + f4
        
        # Scaling
        scale_rey = self.dx**2 / self.A_C 
        F_rey_scaled = F_rey * scale_rey
        
        return F_rey_scaled

    def system_func(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        
        # FIX: Initialize boundaries to Rigid shape to avoid H=0 -> Pa=Max
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        # Calculate Asperity
        Pa, _ = self.calc_asperity(H, calc_deriv=True)
        
        P_tot = P_rey + Pa
        
        D_term = self.D_mat @ P_tot
        H_rigid = H0 + (self.X**2)/2
        H_elastic = H_rigid + D_term
        
        # Update H boundaries
        H[0] = H_elastic[0]
        H[1] = H_elastic[1]
        H[-1] = H_elastic[-1]
        
        # Calculate Reynolds Residual using helper
        F_rey_scaled = self.calc_reynolds_residual(P_rey, H)
        
        # Film Residual
        idx = np.arange(2, self.N-1)
        F_film = H[idx] - H_elastic[idx]
        
        # Load Balance
        # FIX: Normalize Load Residual to force relative accuracy
        # F = (W_target - Integral) / W_target
        if self.Wld != 0:
            F_load = (self.Wld - np.sum(P_tot * self.dx)) / self.Wld
        else:
            F_load = self.Wld - np.sum(P_tot * self.dx)
        
        return np.concatenate([F_rey_scaled, F_film, [F_load]])

    def calc_jacobian(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        N_vars = len(V)
        epsilon = 1e-7
        J = np.zeros((N_vars, N_vars))
        
        idx_inner = np.arange(2, self.N-1)
        
        # Calculate Pa derivatives
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        _, dPa_dH = self.calc_asperity(H, calc_deriv=True)
        dPa_dH_slice = dPa_dH[idx_inner] 
        
        # 1. Analytic Block for Film
        # dF/dP_rey = -D
        D_slice = self.D_mat[np.ix_(idx_inner, idx_inner)]
        J[n_inner:2*n_inner, 0:n_inner] = -D_slice
        
        # dF/dH = I - D * dPa/dH
        Mat_dPa = D_slice * dPa_dH_slice[np.newaxis, :] 
        
        J[n_inner:2*n_inner, n_inner:2*n_inner] = np.eye(n_inner) - Mat_dPa
        
        # dF/dH0 = -1
        J[n_inner:2*n_inner, -1] = -1.0
        # 3. Load Balance Row (Last Row)
        # F_load = (Wld - sum(P*dx)) / Wld = 1 - sum(P*dx)/Wld
        # dF/dP = -dx / Wld
        if self.Wld != 0:
            J[-1, 0:n_inner] = -self.dx / self.Wld
            J[-1, n_inner:2*n_inner] = -dPa_dH_slice * self.dx / self.Wld
        else:
             J[-1, 0:n_inner] = -self.dx
             J[-1, n_inner:2*n_inner] = -dPa_dH_slice * self.dx
             
        # dF/dH0 = 0 (Load depends only on Pressure)
        J[-1, -1] = 0.0
        
        # 3. Optimized FD Block for Reynolds (Sparse update)
        # Reconstruct full P and H
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        
        # Base Residual
        F0_rey = self.calc_reynolds_residual(P_rey, H)
        
        # Loop 1: Perturb P_inner (Cols 0 to n_inner-1)
        for j in range(n_inner):
            idx_global = j + 2
            old_val = P_rey[idx_global]
            P_rey[idx_global] += epsilon
            F_new_rey = self.calc_reynolds_residual(P_rey, H)
            J[:n_inner, j] = (F_new_rey - F0_rey) / epsilon
            P_rey[idx_global] = old_val
            
        # Loop 2: Perturb H_inner (Cols n_inner to 2*n_inner-1)
        for j in range(n_inner):
            idx_global = j + 2
            col = n_inner + j
            old_val = H[idx_global]
            H[idx_global] += epsilon
            F_new_rey = self.calc_reynolds_residual(P_rey, H)
            J[:n_inner, col] = (F_new_rey - F0_rey) / epsilon
            H[idx_global] = old_val
            
        # Loop 3: Perturb H0 (Last Col)
        H0_new = H0 + epsilon
        old_H0_val = H[0]; old_H1_val = H[1]; old_Hm1_val = H[-1]
        
        H[0] = H0_new + (self.X[0]**2)/2
        H[1] = H0_new + (self.X[1]**2)/2
        H[-1] = H0_new + (self.X[-1]**2)/2
        
        F_new_rey = self.calc_reynolds_residual(P_rey, H)
        J[:n_inner, -1] = (F_new_rey - F0_rey) / epsilon
        
        H[0] = old_H0_val; H[1] = old_H1_val; H[-1] = old_Hm1_val
            
        return J

    def update_history(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        Pa = self.calc_asperity(H)
        P_tot = P_rey + Pa
        
        D_term = self.D_mat @ P_tot
        H_elastic = H0 + (self.X**2)/2 + D_term
        
        self.rho_old = self.ro(P_rey)
        self.H_old = H_elastic

    def get_full_state(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner] 
        H0 = V[-1]
        
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        Pa = self.calc_asperity(H)
        P_tot = P_rey + Pa
        
        D_term = self.D_mat @ P_tot
        H_elastic = H0 + (self.X**2)/2 + D_term
        
        return P_rey, Pa, H_elastic

    # Optimized solve_steady signature
    def solve_steady(self, load_target=None, steps=4):
        target_load_val = load_target if load_target else self.F_load
        print(f"Solving Steady State (Mixed, Thermal={self.gamma_therm>0}, Target={target_load_val} N, Steps={steps})...")
        # Initial Guess (Hertzian)
        P_init = np.zeros(self.N)
        X_dim = self.X_dim * self.R
        contact = np.abs(X_dim) <= self.a_Hertz
        P_init[contact] = self.Pmh * np.sqrt(1 - (X_dim[contact]/self.a_Hertz)**2) / self.P0_ref
        
        H0_init = 0.0
        D_term = self.D_mat @ P_init
        H_guess = H0_init + (self.X**2)/2 + D_term
        
        n_inner = self.N - 3
        V = np.concatenate([P_init[2:-1], H_guess[2:-1], [H0_init]])
        
        # Load Ramp
        # If steps=1, do single target solve
        if steps == 1:
            loads = [target_load_val]
        else:
            current_load_val = target_load_val * 0.1
            loads = np.linspace(current_load_val, target_load_val, steps)
        
        for i, w_val in enumerate(loads):
             self.Wld = w_val / self.B / (self.R * self.P0_ref)
             print(f"    Ramp {i+1}/{steps}: w={w_val:.1f} START")
             
             # Thermal Loop
             # If gamma=0, this loop runs once.
             for t_iter in range(15):
                # Solve Reynolds with current T
                 sol = root(self.system_func, V, jac=self.calc_jacobian, method='lm', options={'maxiter': 20, 'ftol': 1e-9})
                 V = sol.x
                 
                 if self.gamma_therm == 0:
                     break
                 
                 P_rey, Pa, H_elastic = self.get_full_state(V)
                 T_new = self.calc_temperature_rise(P_rey, H_elastic, Pa)
                 max_T_change = np.max(np.abs(T_new - self.T_current))
                 self.T_current = 0.2 * T_new + 0.8 * self.T_current
                 
                 if max_T_change < 0.01: 
                     break
             
             print(f"    Ramp {i+1}/{steps} Done. Res={np.linalg.norm(sol.fun):.2e}, T_range=[{np.min(self.T_current):.1f}, {np.max(self.T_current):.1f}]")

        # Final Polish 
        # Skip if steps=1/fast mode? No, polish is good.
        return sol.x
    
    # Needs updating to handle thermal loop inside
    def solve_transient_ramp(self, V_start, load_start, load_end, duration, steps):
        print(f"Solving Transient Ramp ({load_start}N -> {load_end}N, Mixed, Thermal)...")
        self.is_transient = True
        self.dt = duration / steps
        
        V_current = V_start.copy()
        current_load = load_start
        d_load = (load_end - load_start) / steps
        
        self.update_history(V_current)
        
        for i in range(steps):
            current_load += d_load
            self.Wld = current_load / self.B / (self.R * self.P0_ref)
            
            # Thermal Iterate
            for t_iter in range(5):
                # Newton Solve
                V_new, success, res, k = self.newton_solve(V_current, tol=1e-9, max_iter=10)
                
                # Update T
                P_rey, Pa, H_elastic = self.get_full_state(V_new)
                T_new = self.calc_temperature_rise(P_rey, H_elastic, Pa)
                
                max_T_change = np.max(np.abs(T_new - self.T_current))
                self.T_current = 0.5 * T_new + 0.5 * self.T_current
                
                # Check consistency
                if success and max_T_change < 0.01:
                    V_current = V_new
                    break
                
                if not success:
                    # If Newton failed, try to recover or just accept
                     V_current = V_new
            
            self.update_history(V_current)
            if i % 20 == 0:
                 print(f"  Step {i}/{steps}, Res={res:.2e}, T_max={np.max(self.T_current):.1f}K, T_Res={max_T_change:.1e}")
            
        print("  Transient ramp completed.")
        return V_current

    def newton_solve(self, V_guess, tol=1e-6, max_iter=20):
        V = V_guess.copy()
        current_res = np.linalg.norm(self.system_func(V))
        
        for k in range(max_iter):
            if current_res < tol:
                return V, True, current_res, k
            
            J = self.calc_jacobian(V)
            
            try:
                dV = np.linalg.solve(J, -self.system_func(V))
            except np.linalg.LinAlgError:
                return V, False, current_res, k
            
            # Damping / Line Search
            alpha = 1.0
            found = False
            for _ in range(4): # Try 1.0, 0.5, 0.25, 0.125
                V_new = V + alpha * dV
                new_res = np.linalg.norm(self.system_func(V_new))
                
                if new_res < current_res:
                    V = V_new
                    current_res = new_res
                    found = True
                    break
                alpha *= 0.5
            
            if not found:
                # If damping fails, force small step (0.1) to unstuck
                # or just accept step if closer?
                # EHL often needs small steps.
                V = V + 0.1 * dV
                current_res = np.linalg.norm(self.system_func(V))
            
        success = current_res < tol
        return V, success, current_res, max_iter

    def solve_transient_ramp(self, V_start, load_start, load_end, duration, steps):
        print(f"Solving Transient Ramp ({load_start}N -> {load_end}N, Mixed)...")
        self.is_transient = True
        self.dt = duration / steps
        
        V_current = V_start.copy()
        current_load = load_start
        d_load = (load_end - load_start) / steps
        
        self.update_history(V_current)
        
        for i in range(steps):
            current_load += d_load
            self.Wld = current_load / self.B / (self.R * self.P0_ref)
            
            # Predictor: 0-th Order (V_guess = V_current)
            # Custom Newton Solver (Fast Loop)
            V_new, success, res, k = self.newton_solve(V_current, tol=1e-9, max_iter=10)
            
            if success:
                V_current = V_new
                self.update_history(V_current)
                if i % 20 == 0:
                     print(f"  Step {i}/{steps}, Res={res:.2e}, Iters={k}")
            else:
                print(f"  Step {i} NOT CONVERGED. Res={res:.2e}. Keeping previous state.")
                # Strategy: Maybe try smaller step? 
                # For now just proceed. Pseudo-convergence usually fine.
                V_current = V_new 
            
        print("  Transient ramp completed.")
        return V_current
    
    def run_single_case(self, label, is_thermal=True):
        print(f"\n=== Running Case: {label} (Thermal={is_thermal}) ===")
        
        # Save Physics Params
        saved_gamma = self.gamma_therm
        saved_S0 = self.S0
        
        if not is_thermal:
            self.gamma_therm = 0.0
            self.S0 = 0.0
            self.T_current = np.full(self.N, self.T0_K)
            
        print(f"    Physics Params: Gamma={self.gamma_therm:.2e}, S0={self.S0:.2e}")
            
        target_load = 64.0 
        
        # --- 1. FAST INITIALIZATION (Direct Isothermal Steady) ---
        print(f"--- 1. Fast Initialization: Direct Isothermal Steady (Load={target_load}N) ---")
        
        # CRITICAL: Re-initialize grid for the specific target load
        # This ensures dx is small enough to capture the pressure spike and Hertzian shape.
        self.setup_grid(load_override=target_load)
        
        # Disable thermal for init
        self.gamma_therm = 0.0
        self.S0 = 0.0
        self.sigma_factor = 1.0 # Fully Rough/Mixed
        self.is_transient = False
        self.Wld = target_load / self.B / (self.R * self.P0_ref)
        
        # Improved Initial Guess (Dowson-Higginson Hc)
        # U_dim = mu0 * Um / (E' R)
        U_dim = self.mu00 * self.Um / (self.E_prime * self.R)
        # G_dim = alpha * E'
        G_dim = self.alpha_input * self.E_prime
        # W_dim = w_load / (E' * R)
        W_dim = (target_load / self.B) / (self.E_prime * self.R)
        
        H_min_nd = 2.65 * (U_dim**0.7) * (G_dim**0.54) * (W_dim**-0.13)
        # Use H0_init based on this?
        # H approx H0 + X^2/2. At center X=0, H=H0.
        # So H0_init approx H_min_nd.
        H0_init = H_min_nd 
        # Damp high initial guess slightly? H_min might be central. H_central ~ 1.3 H_min.
        
        # Hertzian Pressure (Dry)
        P_init = np.zeros(self.N)
        X_dim = self.X_dim * self.R
        contact = np.abs(X_dim) <= self.a_Hertz
        P_init[contact] = self.Pmh * np.sqrt(1 - (X_dim[contact]/self.a_Hertz)**2) / self.P0_ref
        
        D_term = self.D_mat @ P_init
        H_guess = H0_init + (self.X**2)/2 + D_term
        
        n_inner = self.N - 3
        V_guess = np.concatenate([P_init[2:-1], H_guess[2:-1], [H0_init]])
        
        # Direct Newton Solve (Isothermal)
        V_init, success, res, k = self.newton_solve(V_guess, tol=1e-6, max_iter=30)
        
        if not success:
             print(f"    WARNING: Direct Initialization failed (Res={res:.2e}). Using fast fallback...")
             # Fallback with few steps
             V_init = self.solve_steady(load_target=target_load, steps=2)
        else:
             print(f"    Direct Init Converged. Res={res:.2e}, Iters={k}")

        # Restore Physics
        self.gamma_therm = saved_gamma
        self.S0 = saved_S0
        if not is_thermal:
             self.gamma_therm = 0.0
             self.S0 = 0.0
        
        # --- 2. SMART TRANSIENT THERMAL LOOP ---
        print(f"--- 2. Smart Transient Simulation ({target_load}N) ---")
        
        # Setup Transient
        self.is_transient = True
        duration = 0.002 # 2ms to clear the contact once.
        steps = 40 # 50us steps.
        self.dt = duration / steps
        
        V_current = V_init.copy()
        
        # Update History for first step
        self.update_history(V_current)
        
        # Time Loop
        for i in range(steps):
             # 1. Solve Reynolds/Elastic (Newton)
             # We assume T is from previous step (Explicit / Staggered coupling)
             # This is standard for transient thermal EHL.
             
             V_new, success, res, k = self.newton_solve(V_current, tol=1e-9, max_iter=15)
             
             max_T_change = 0.0 
             
             # 2. Update Temperature (If Thermal)
             if is_thermal:
                 P_rey, Pa, H_elastic = self.get_full_state(V_new)
                 T_new, Phi, Alpha, H_eff = self.calc_temperature_rise(P_rey, H_elastic, Pa)
                 
                 # Relaxation / Damping on T update if needed
                 # For transient, explicit update is usually fine if dt is small.
                 self.T_current = 0.8 * T_new + 0.2 * self.T_current 
             
             # Accept Step
             V_current = V_new
             self.update_history(V_current)
             
             if i % 10 == 0:
                 T_max = np.max(self.T_current) if is_thermal else self.T0_K
                 T_res_val = max_T_change if is_thermal else 0.0
                 print(f"  Step {i}/{steps}: Res={res:.2e}, T_max={T_max:.1f}K, T_Res={T_res_val:.1e}")
                 
        print("  Transient Done.")
        
        P_rey, Pa, H = self.get_full_state(V_current)
        T_dist = self.T_current.copy()
        
        # Cleanup
        if not is_thermal:
             self.T_current = np.full(self.N, self.T0_K)
        self.gamma_therm = saved_gamma
        self.S0 = saved_S0
        
        if 'Phi' not in locals(): Phi = np.zeros(self.N)
        if 'Alpha' not in locals(): Alpha = np.zeros(self.N)
        if 'H_eff' not in locals(): H_eff = np.zeros(self.N)

        return self.X * self.R * 1e3, P_rey, Pa, H, T_dist, Phi, Alpha, H_eff

    def run_study(self):
        # Run Isothermal
        X_iso, P_rey_iso, Pa_iso, H_iso, T_iso, _, _, _ = self.run_single_case("Isothermal", is_thermal=False)
        
        # Run Thermal
        X_thm, P_rey_thm, Pa_thm, H_thm, T_thm, Phi_thm, Alpha_thm, Heff_thm = self.run_single_case("Thermal", is_thermal=True)
        
        # Normalize Results
        P_rey_iso_nd = (P_rey_iso * self.P0_ref) / self.Pmh
        Pa_iso_nd = (Pa_iso * self.P0_ref) / self.Pmh
        
        P_rey_thm_nd = (P_rey_thm * self.P0_ref) / self.Pmh
        Pa_thm_nd = (Pa_thm * self.P0_ref) / self.Pmh
        
        # Flow Factors (Thermal Final State)
        phi_x_thm, phi_s_thm = self.calc_flow_factors(H_thm)
        idx_hmin = np.argmin(H_thm)

        print("\n=== TRANSIENT THERMAL RESULTS (FINAL STATE) ===")
        print(f"Max Reynolds P (ND): {np.max(P_rey_thm_nd):.4f}")
        print(f"Max Asperity P (ND): {np.max(Pa_thm_nd):.4f}")
        print(f"Min Film H (ND): {np.min(H_thm):.4e} at X={X_thm[idx_hmin]:.4f} mm")
        print(f"Central Film H (ND): {H_thm[len(H_thm)//2]:.4e}")

        print("\n=== FLOW FACTOR IMPACT (Patir-Cheng) ===")
        print(f"Phi_x range: [{np.min(phi_x_thm):.4f}, {np.max(phi_x_thm):.4f}]")
        print(f"Phi_s range: [{np.min(phi_s_thm):.4f}, {np.max(phi_s_thm):.4f}]")
        print(
            "At H_min: "
            f"Phi_x={phi_x_thm[idx_hmin]:.4f}, "
            f"Phi_s={phi_s_thm[idx_hmin]:.4f}"
        )

        # KEY DIAGNOSTIC: Location of Peaks
        idx_p_max = np.argmax(P_rey_thm_nd)
        idx_t_max = np.argmax(T_thm)
        x_p_max = X_thm[idx_p_max]
        x_t_max = X_thm[idx_t_max]
        
        print(f"\nDIAGNOSTIC ALIGNMENT LIST:")
        print(f"  Max Reynolds P at X = {x_p_max:.4f} mm")
        print(f"  Max Delta T at    X = {x_t_max:.4f} mm")
        print(f"  Gap (T - P)       = {x_t_max - x_p_max:.4f} mm")
        
        # Width Analysis
        T_rise = T_thm - self.T0_K
        threshold = 0.1 # K
        indices = np.where(T_rise > threshold)[0]
        if len(indices) > 0:
            x_start = X_thm[indices[0]]
            x_end = X_thm[indices[-1]]
            print(f"  Delta T Width (>{threshold}K): [{x_start:.4f}, {x_end:.4f}] mm")
        else:
            print(f"  Delta T Width: < {threshold}K everywhere")
            
        # Asperity Width Diagnostic
        Pa_thresh = 0.01
        indices_pa = np.where(Pa_thm_nd > Pa_thresh)[0]
        if len(indices_pa) > 0:
            xa_start = X_thm[indices_pa[0]]
            xa_end = X_thm[indices_pa[-1]]
            print(f"  Asperity Width (>{Pa_thresh}): [{xa_start:.4f}, {xa_end:.4f}] mm")
            print(f"  Asperity P Boundaries: Left={Pa_thm_nd[0]:.4f}, Right={Pa_thm_nd[-1]:.4f}")
            # Check Normalized Width
            a_cur = self.a_Hertz * 1000 # mm
            print(f"  Current a_Hertz: {a_cur:.4f} mm")
            print(f"  Norm Asp Width: [{xa_start/a_cur:.2f}, {xa_end/a_cur:.2f}] (Target approx [-1, 1])")
        else:
            print(f"  Asperity Width: < {Pa_thresh} everywhere")
        
        # Plotting
        print("Plotting Comparisons...")
        
        # Graph 1: Reynolds Pressure
        plt.figure(figsize=(10, 6))
        plt.plot(X_iso, P_rey_iso_nd, 'b--', label='Isothermal')
        plt.plot(X_thm, P_rey_thm_nd, 'r-', label='Thermal')
        plt.xlabel('X (mm)')
        plt.ylabel('P_rey / Pmh')
        plt.title('Graph-1: Non-dimensional Reynolds Pressure')
        plt.legend()
        plt.grid(True)
        plt.savefig('Graph1_Reynolds_Pressure.png')
        
        # Graph 2: Asperity Pressure
        plt.figure(figsize=(10, 6))
        plt.plot(X_iso, Pa_iso_nd, 'b--', label='Isothermal')
        plt.plot(X_thm, Pa_thm_nd, 'r-', label='Thermal')
        plt.xlabel('X (mm)')
        plt.ylabel('P_asp / Pmh')
        plt.title('Graph-2: Non-dimensional Asperity Pressure')
        plt.legend()
        plt.grid(True)
        plt.savefig('Graph2_Asperity_Pressure.png')
        
        # Graph 3: Film Thickness
        plt.figure(figsize=(10, 6))
        plt.plot(X_iso, H_iso * 1e5, 'b--', label='Isothermal')
        plt.plot(X_thm, H_thm * 1e5, 'r-', label='Thermal')
        plt.xlabel('X (mm)')
        plt.ylabel('H / R (x10^5)')
        plt.title('Graph3_Film_Thickness')
        plt.legend()
        plt.grid(True)
        plt.savefig('Graph3_Film_Thickness.png')
        
        # Graph 4: Delta T
        plt.figure(figsize=(10, 6))
        plt.plot(X_thm, T_thm - self.T0_K, 'r-', label='Thermal Rise')
        plt.xlabel('X (mm)')
        plt.ylabel('Delta T (K)')
        plt.title('Graph-4: Temperature Rise (Delta T vs X)')
        plt.legend()
        plt.grid(True)
        plt.savefig('Graph4_Temperature.png')
        
        # Graph 5: Thermal Diagnostics
        fig, ax1 = plt.subplots(figsize=(10, 6))
        
        color = 'tab:red'
        ax1.set_xlabel('X (mm)')
        ax1.set_ylabel('Heat Gen (W/m2)', color=color)
        ax1.plot(X_thm, Phi_thm, color=color, label='Phi (Source)')
        ax1.tick_params(axis='y', labelcolor=color)
        
        ax2 = ax1.twinx()  
        color = 'tab:blue'
        ax2.set_ylabel('Alpha (1/m)', color=color)  
        ax2.plot(X_thm, Alpha_thm, color=color, linestyle='--', label='Alpha (Decay)')
        ax2.tick_params(axis='y', labelcolor=color)
        
        plt.title('Graph-5: Thermal Diagnostics (Phi & Alpha)')
        fig.tight_layout()  
        plt.grid(True)
        plt.savefig('Graph5_Thermal_Diagnostics.png')
        
        # PRINT DIAGNOSTICS FOR AI ANALYSIS
        print("\n=== THERMAL DIAGNOSTICS (DETAIL) ===")
        idx_t_max = np.argmax(T_thm)
        idx_phi_max = np.argmax(Phi_thm)
        idx_cen = np.argmax(P_rey_thm_nd) # Use P_max as functional center
        idx_inlet_peak = np.argmax(T_thm[:idx_cen]) # Check Inlet Peak specific
        
        def print_pt(label, idx):
             print(f"Location {label} (i={idx}):")
             print(f"  X = {X_thm[idx]:.4f} mm")
             print(f"  T_rise = {T_thm[idx]-self.T0_K:.4f} K")
             print(f"  Phi = {Phi_thm[idx]:.4e}")
             print(f"  Alpha = {Alpha_thm[idx]:.4e}")
             print(f"  Heff = {Heff_thm[idx]:.4e}")
             if Alpha_thm[idx] > 1e-10:
                 teq = Phi_thm[idx]/Alpha_thm[idx] # = Phi/Alpha
             else:
                 teq = 0.0
             print(f"  Calc Teq (Phi/Alpha) = {teq:.4f} K")
        
        print_pt("MAX T (Global)", idx_t_max)
        print_pt("MAX PHI", idx_phi_max)
        print_pt("CENTER", idx_cen)
        if idx_inlet_peak != idx_t_max:
             print_pt("INLET PEAK", idx_inlet_peak)
        
        # Check smoothness
        dPhi = np.diff(Phi_thm)
        print(f"Mean Abs dPhi: {np.mean(np.abs(dPhi)):.4e}")
        print(f"Max Abs dPhi: {np.max(np.abs(dPhi)):.4e}")

        # Print Analysis Data
        print("\n=== Detailed Comparison Data ===")
        print(f"{'Metric':<25} | {'Isothermal':<15} | {'Thermal':<15} | {'% Diff':<10}")
        print("-" * 75)
        
        metrics = [
            ("Max Reynolds P (ND)", np.max(P_rey_iso_nd), np.max(P_rey_thm_nd)),
            ("Max Asperity P (ND)", np.max(Pa_iso_nd), np.max(Pa_thm_nd)),
            ("Min Film H (ND x10^5)", np.min(H_iso)*1e5, np.min(H_thm)*1e5),
            ("Central (Peak P) H (ND x10^5)", H_iso[idx_p_max]*1e5, H_thm[idx_p_max]*1e5),
            ("Max Delta T (K)", 0.0, np.max(T_thm - self.T0_K))
        ]
        
        for name, iso, thm in metrics:
            pct = 0.0
            if abs(iso) > 1e-9:
                pct = (thm - iso) / iso * 100
            print(f"{name:<25} | {iso:<15.4f} | {thm:<15.4f} | {pct:<10.2f}")
            
        print("-" * 75)
        print("Comparison Complete. Graphs saved.")
        
        for name, iso, thm in metrics:
            pct = 0.0
            if abs(iso) > 1e-9:
                pct = (thm - iso) / iso * 100
            print(f"{name:<25} | {iso:<15.4f} | {thm:<15.4f} | {pct:<10.2f}")
            
        print("-" * 75)
        print("Comparison Complete. Graphs saved.")

    def solve(self):
        self.run_study()

if __name__ == "__main__":
    solver = EHLSolver()
    solver.solve()
