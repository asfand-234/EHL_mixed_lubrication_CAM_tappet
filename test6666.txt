import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import root
import time
import os

class EHLSolver:
    def __init__(self):
        print("Init start")
        self.P0_ref = 0.5e9
        self.mu00 = 0.01381
        self.muinf = 6.315e-5
        self.Pr = 1.98e8
        self.alpha_input = 15e-9
        self.z_input = 0.65
      
        self.E_prime = 217e9
        
        self.B = 7.3e-3
        self.R = None
        self.Um = None
        self.Um_mag = None
        self.Um_sign = None
        self.Vs = None
  
        self.rho0 = 870.0
        self.Cp = 2000.0
        
        self.N = 81 
        self.delta_ad = 0.05 
        
        self.sigma = 0.2e-6
        self.eta_beta_sigma = 0.05
        self.sigma_beta_ratio = 0.001
        self.K_GT = (16 * np.pi * np.sqrt(2) / 15) * (self.eta_beta_sigma**2) * np.sqrt(self.sigma_beta_ratio) * self.E_prime
        
        self.T0_C = 90.0
        self.T0_K = self.T0_C + 273.15
        self.beta0 = 0.04
        self.gamma_therm = 6.5e-4
        self.k_therm = 0.15
        
        ln_eta0 = np.log(self.mu00)
        self.S0 = self.beta0 * (self.T0_K - 138.0) / (ln_eta0 + 9.67)
        self.Z_houper = self.alpha_input / (5.11e-9 * (ln_eta0 + 9.67))
        
        self.cam_data = self.load_cam_profile("updated_lift.txt")
        self.setup_grid(self.cam_data["max_a_over_r"])
    
        self.F0_norm = 0.0 
        self.dt = self.cam_data["dt"][0]
        self.is_transient = True
        self.rho_old = None
        self.H_old = None
        self.kw = 0.0
        self.sigma_factor = 1.0 
        
        self.T_current = np.full(self.N, self.T0_K)

    def load_cam_profile(self, path):
        if not os.path.exists(path):
             path = r"/content/cam/updated_lift.txt"
        
        data = np.loadtxt(path)
        theta_deg = data[:, 0]
        lift = data[:, 1]
        theta_rad = np.deg2rad(theta_deg)
        dlift = np.gradient(lift, theta_rad)
        ddlift = np.gradient(dlift, theta_rad)
        rb = 18.4e-3
        N = 300
        omega = (2 * np.pi * N) / 60
        Vc = (rb + lift + ddlift) * omega
        Vf = omega * ddlift
        um = (Vf + Vc) / 2
        Vs = Vc - Vf
        R = ddlift + lift + rb
        K_spring = 7130
        delta = 1.77e-3
        M_eq = 0.05733
        F = K_spring * (lift + delta) + ddlift * M_eq * omega**2
        
        # Calculate max_a_over_r once
        Wl = np.maximum(F, 0.0) / self.B
        a_hertz = np.sqrt(8 * Wl * R / (np.pi * self.E_prime))
        a_over_r = a_hertz / R
        max_a_over_r = np.max(a_over_r)
        
        dt = np.gradient(theta_rad) / omega
        time = (theta_rad - theta_rad[0]) / omega
        return {
            "theta_deg": theta_deg,
            "lift": lift,
            "um": um,
            "Vs": Vs,
            "R": R,
            "F": F,
            "dt": dt,
            "time": time,
            "max_a_over_r": max_a_over_r,
        }

    def setup_grid(self, max_a_over_r):
        left = -5.0 * max_a_over_r
        right = 3.0 * max_a_over_r
        self.X_dim = np.linspace(left, right, self.N)
        self.dx = self.X_dim[1] - self.X_dim[0]
        self.X = self.X_dim
        self.CE = -4 * self.P0_ref / (np.pi * self.E_prime)
        self.hmin_dim = 0.0
        self.gamma_h = 1e12
        self.calculate_D_matrix()
        self.T_current = np.full(self.N, self.T0_K)

    def update_operating_state(self, um, vs, R, load):
        self.Um = um
        self.Vs = vs
        self.R = R
        self.W = load
        self.Um_mag = max(abs(self.Um), 1e-9)
        self.Um_sign = 1.0 if self.Um >= 0 else -1.0
        self.A_C = self.R * self.P0_ref / (12 * self.mu00 * self.Um_mag)
        self.u1d = self.Um_sign
        Wl = self.W / self.B
        self.a_Hertz = np.sqrt(8 * Wl * self.R / (np.pi * self.E_prime))
        self.Pmh = 2 * Wl / (np.pi * self.a_Hertz) if self.a_Hertz > 0 else 0.0
        self.Wld = Wl / (self.R * self.P0_ref)
        Rey_Stiffness = self.A_C / (self.dx**2)
        self.g1 = 1e15 * Rey_Stiffness
        
    def calculate_D_matrix(self):
        N = self.N
        dx = self.dx
        D = np.zeros((N, N))
        b = dx / 2.0
        
        for i in range(N):
            xi = self.X_dim[i]
            for j in range(N):
                xj = self.X_dim[j]
                d1 = xi - (xj - b)
                d2 = xi - (xj + b)
                def F(u):
                    if abs(u) < 1e-12: return 0.0
                    return u * np.log(abs(u)) - u
                D[i, j] = (F(d1) - F(d2))
        self.D_mat = D * self.CE 

    def calc_flow_factors(self, H_dimless):
        if self.sigma_factor <= 0.0:
            ones = np.ones_like(H_dimless)
            return ones, ones

        sigma_eff = self.sigma * self.sigma_factor
        h_real = H_dimless * self.R
        lambda_ratio = h_real / sigma_eff
        lambda_ratio = np.where(lambda_ratio < 0.0, 0.0, lambda_ratio)

        phi_x = 1.0 - 0.9 * np.exp(-0.56 * lambda_ratio)
        phi_s = 1.0 - 0.9 * np.exp(-0.2 * lambda_ratio)
        return phi_x, phi_s
        
    def ro(self, P_dim_less, T_K=None):
        if T_K is None: T_K = self.T_current
        P = np.maximum(P_dim_less * self.P0_ref, 0.0)
        a = 0.6e-9
        b = 1.7e-9
        term_p = (1 + (a * P) / (1 + b * P))
        DeltaT = T_K - self.T0_K
        term_T = (1 - self.gamma_therm * DeltaT)
        return term_p * term_T

    def droo(self, P_dim_less, T_K=None):
        if T_K is None: T_K = self.T_current
        P = np.maximum(P_dim_less * self.P0_ref, 0.0)
        a = 0.6e-9
        b = 1.7e-9
        df_dP = a / ((1 + b*P)**2)
        DeltaT = T_K - self.T0_K
        term_T = (1 - self.gamma_therm * DeltaT)
        return df_dP * self.P0_ref * term_T

    def c_mu(self, P_dim_less, T_K=None):
        if T_K is None: T_K = self.T_current
        P = np.maximum(P_dim_less * self.P0_ref, 0.0)
        
        ln_eta0 = np.log(self.mu00)
        C1 = ln_eta0 + 9.67
        
        T_term = (T_K - 138.0) / (self.T0_K - 138.0)
        T_term = np.maximum(T_term, 1e-5)
        term_T_S0 = T_term**(-self.S0)
        
        term_P_Z = (1 + P / self.Pr)**self.Z_houper
        exponent = C1 * (term_T_S0 * term_P_Z - 1.0)
        
        exponent = np.minimum(exponent, 50.0) # Reduce from 700 to 50 for stability/speed check
        
        return self.mu00 * np.exp(exponent)

    def calc_temperature_rise(self, P_dist, H_dist, Pa_dist=None):
        um = self.Um_mag
        gamma = self.gamma_therm
        k = self.k_therm
        a_hertz = self.a_Hertz if self.a_Hertz > 0 else 1.0
        P_real = P_dist * self.P0_ref
        h = np.maximum(H_dist * self.R, 1e-9)
        
        eta = self.c_mu(P_dist, self.T_current)
        T = self.T_current
        num_term_1 = um * T * gamma * h * P_real
        num_term_2 = (2.0 * a_hertz * eta * um**2) / h
        
        den = (a_hertz * k) / h - um * gamma * h * P_real
        den = np.where(den < 1e-5, 1e-5, den)
        
        Delta_T = (num_term_1 + num_term_2) / den
        T_new = self.T0_K + Delta_T
        return T_new

    def calc_asperity(self, H_dimless, calc_deriv=False):
        if self.a_Hertz == 0: H_real = H_dimless * 0
        else: H_real = H_dimless * self.R
        
        Lambda = H_real / self.sigma
        mask = Lambda < 4.0
        
        Pa_real = np.zeros_like(Lambda)
        dPa_dH_real = np.zeros_like(Lambda)
        
        if np.any(mask):
            val = 4.0 - Lambda[mask]
            A_fit = 4.4084e-5
            Z_fit = 6.804
            F_stat = A_fit * (val**Z_fit)
            dF_dL = -A_fit * Z_fit * (val**(Z_fit-1))
            
            Pa_real[mask] = self.K_GT * F_stat * self.sigma_factor
            if calc_deriv:
                dPa_dH_real[mask] = (self.K_GT * dF_dL * self.sigma_factor) / self.sigma
        
        Pa_dim = Pa_real / self.P0_ref
        if calc_deriv:
            return Pa_dim, (dPa_dH_real * self.R) / self.P0_ref
        return Pa_dim

    def beta_ad(self, P, H, eps_shift):
        idx = np.arange(2, self.N-1) 
        rho_prime = self.droo(P)
        val = self.dx * rho_prime * H 
        if eps_shift == 0: beta = 0.5 * (val[idx] + val[idx-1])
        else: beta = 0.5 * (val[idx] + val[idx+1])
        return beta * (self.delta_ad / self.A_C)
        
    def get_eps_beta(self, P, H):
        idx = np.arange(2, self.N-1)
        rho = self.ro(P)
        mu = self.c_mu(P)
        phi_x, _ = self.calc_flow_factors(H)
        
        rho_1 = rho[idx] + rho[idx-1]
        mu_1 = mu[idx] + mu[idx-1]
        H_1 = H[idx] + H[idx-1]
        phi_1 = 0.5 * (phi_x[idx] + phi_x[idx-1])
        eps1 = (rho_1 * (H_1**3) * 0.125 * phi_1 / mu_1) + self.beta_ad(P, H, 0)
        
        rho_2 = rho[idx] + rho[idx+1]
        mu_2 = mu[idx] + mu[idx+1]
        H_2 = H[idx] + H[idx+1]
        phi_2 = 0.5 * (phi_x[idx] + phi_x[idx+1])
        eps2 = (rho_2 * (H_2**3) * 0.125 * phi_2 / mu_2) + self.beta_ad(P, H, 1)
        return eps1, eps2

    def calc_reynolds_residual(self, P_rey, H, fast=False):
        idx = np.arange(2, self.N-1)
        eps1, eps2 = self.get_eps_beta(P_rey, H)
        
        term_pois = (self.A_C / self.dx**2) * (P_rey[idx-1]*eps1 - P_rey[idx]*(eps1+eps2) + P_rey[idx+1]*eps2)
        
        rho = self.ro(P_rey)
        _, phi_s = self.calc_flow_factors(H)
        
        term_couette = (self.u1d / self.dx) * (rho[idx]*H[idx]*phi_s[idx] - rho[idx-1]*H[idx-1]*phi_s[idx-1])
        
        term_squeeze = 0.0
        if self.is_transient and self.rho_old is not None:
             term_time = (rho[idx]*H[idx] - self.rho_old[idx]*self.H_old[idx]) / self.dt
             term_squeeze = (self.R / self.Um_mag) * term_time
             
        f1 = self.gamma_h * np.minimum(P_rey[idx], 0)
        f4 = self.g1 * np.maximum(self.hmin_dim - H[idx], 0)**2
        
        F_rey = term_pois - term_couette - term_squeeze - f1 + f4
        return F_rey * (self.dx**2 / self.A_C)

    def system_func(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        Pa, _ = self.calc_asperity(H, calc_deriv=True)
        P_tot = P_rey + Pa
        D_term = self.D_mat @ P_tot
        H_elastic = H0 + (self.X**2)/2 + D_term
        
        H[0] = H_elastic[0]; H[1] = H_elastic[1]; H[-1] = H_elastic[-1]
        
        F_rey = self.calc_reynolds_residual(P_rey, H)
        idx = np.arange(2, self.N-1)
        F_film = H[idx] - H_elastic[idx]
        
        integral = np.sum(P_tot * self.dx)
        F_load = (self.Wld - integral) / getattr(self, 'Wld', 1.0) if getattr(self, 'Wld', 0) != 0 else self.Wld - integral
        
        return np.concatenate([F_rey, F_film, [F_load]])

    def calc_jacobian(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        N_vars = len(V)
        epsilon = 1e-7
        J = np.zeros((N_vars, N_vars))
        idx_inner = np.arange(2, self.N-1)
        
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        H = np.zeros(self.N); H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2; H[1] = H0 + (self.X[1]**2)/2; H[-1] = H0 + (self.X[-1]**2)/2
        
        _, dPa_dH = self.calc_asperity(H, calc_deriv=True)
        dPa_dH_slice = dPa_dH[idx_inner] 
        D_slice = self.D_mat[np.ix_(idx_inner, idx_inner)]
        
        J[n_inner:2*n_inner, 0:n_inner] = -D_slice
        Mat_dPa = D_slice * dPa_dH_slice[np.newaxis, :] 
        J[n_inner:2*n_inner, n_inner:2*n_inner] = np.eye(n_inner) - Mat_dPa
        J[n_inner:2*n_inner, -1] = -1.0
        
        if self.Wld != 0:
            J[-1, 0:n_inner] = -self.dx / self.Wld
            J[-1, n_inner:2*n_inner] = -dPa_dH_slice * self.dx / self.Wld
        else:
             J[-1, 0:n_inner] = -self.dx
             J[-1, n_inner:2*n_inner] = -dPa_dH_slice * self.dx
             
        J[-1, -1] = 0.0
        
        P_rey = np.zeros(self.N); P_rey[2:-1] = P_inner
        F0_rey = self.calc_reynolds_residual(P_rey, H)
        
        # Optimize loop slightly
        for j in range(n_inner):
            old = P_rey[j+2]
            P_rey[j+2] += epsilon
            J[:n_inner, j] = (self.calc_reynolds_residual(P_rey, H) - F0_rey) / epsilon
            P_rey[j+2] = old
            
        for j in range(n_inner):
            old = H[j+2]
            H[j+2] += epsilon
            J[:n_inner, n_inner+j] = (self.calc_reynolds_residual(P_rey, H) - F0_rey) / epsilon
            H[j+2] = old
            
        old0 = H[0]; old1 = H[1]; oldm1 = H[-1]
        H[0] = H0 + epsilon + (self.X[0]**2)/2
        H[1] = H0 + epsilon + (self.X[1]**2)/2
        H[-1] = H0 + epsilon + (self.X[-1]**2)/2
        J[:n_inner, -1] = (self.calc_reynolds_residual(P_rey, H) - F0_rey) / epsilon
        H[0] = old0; H[1] = old1; H[-1] = oldm1
            
        return J

    def update_history(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2; H[1] = H0 + (self.X[1]**2)/2; H[-1] = H0 + (self.X[-1]**2)/2
        
        Pa = self.calc_asperity(H)
        P_tot = P_rey + Pa
        D_term = self.D_mat @ P_tot
        H_elastic = H0 + (self.X**2)/2 + D_term
        self.rho_old = self.ro(P_rey)
        self.H_old = H_elastic

    def get_full_state(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner] 
        H0 = V[-1]
        P_rey = np.zeros(self.N); P_rey[2:-1] = P_inner
        H = np.zeros(self.N); H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2; H[1] = H0 + (self.X[1]**2)/2; H[-1] = H0 + (self.X[-1]**2)/2
        Pa = self.calc_asperity(H)
        P_tot = P_rey + Pa
        D_term = self.D_mat @ P_tot
        H_elastic = H0 + (self.X**2)/2 + D_term
        return P_rey, Pa, H_elastic

    def build_initial_guess(self):
        # Only use this if ABSOLUTELY necessary (start of sim)
        P_init = np.zeros(self.N)
        X_dim = self.X_dim * self.R
        contact = np.abs(X_dim) <= self.a_Hertz
        P_init[contact] = self.Pmh * np.sqrt(1 - (X_dim[contact] / self.a_Hertz) ** 2) / self.P0_ref
        
        # Estimate H0 (Hamrock & Dowson)
        U_dim = self.mu00 * self.Um_mag / (self.E_prime * self.R)
        G_dim = self.alpha_input * self.E_prime
        W_dim = (self.W / self.B) / (self.E_prime * self.R)
        H_min_nd = 2.65 * (U_dim**0.7) * (G_dim**0.54) * (W_dim**-0.13)
        H0_init = H_min_nd
        
        D_term = self.D_mat @ P_init
        H_guess = H0_init + (self.X**2) / 2 + D_term
        return np.concatenate([P_init[2:-1], H_guess[2:-1], [H0_init]])

    def newton_solve(self, V_guess, tol=1e-6, max_iter=20):
        V = V_guess.copy()
        current_res = np.linalg.norm(self.system_func(V))
        
        for k in range(max_iter):
            if current_res < tol: return V, True, current_res, k
            if not np.isfinite(current_res): return V, False, np.inf, k
            
            try:
                J = self.calc_jacobian(V)
                dV = np.linalg.solve(J, -self.system_func(V))
            except np.linalg.LinAlgError:
                return V, False, current_res, k

            # Limit Step Size
            dV_clip = np.clip(dV, -0.2, 0.2) # Avoid huge jumps
            
            alpha = 1.0
            found = False
            for _ in range(4):
                V_new = V + alpha * dV_clip
                
                # Check bounds (heuristic)
                # P > 0 is enforced by ro/mu, but H > 0 is critical
                # System func handles it, but let's check finite
                new_res_val = np.linalg.norm(self.system_func(V_new))
                
                if np.isfinite(new_res_val) and new_res_val < current_res:
                    V = V_new
                    current_res = new_res_val
                    found = True
                    break
                alpha *= 0.5
            
            if not found:
                # Accept small step if not diverging too much? No, strict descent.
                # Actually, in stiff EHL, sometimes we just take the step.
                V = V + 0.05 * dV_clip
                current_res = np.linalg.norm(self.system_func(V))
            
        return V, current_res < tol, current_res, max_iter

    def run_cam_cycle(self):
        theta_deg = self.cam_data["theta_deg"]
        um_profile = self.cam_data["um"]
        vs_profile = self.cam_data["Vs"]
        R_profile = self.cam_data["R"]
        F_profile = self.cam_data["F"]
        dt_profile = self.cam_data["dt"]
        n_steps = len(theta_deg)
        
        total_start = time.perf_counter()
        
        # Lists for plotting
        P_nd_list = []
        Pa_nd_list = []
        H_list = []
        load_err_list = []
        
        V_current = None
        
        for i in range(n_steps):
            t0 = time.perf_counter()
            self.update_operating_state(um_profile[i], vs_profile[i], R_profile[i], F_profile[i])
            self.dt = dt_profile[i]
            
            # Initial Guess Strategy:
            # 1. Use previous V_current if available.
            # 2. If None, build Hertzian.
            if V_current is None:
                V_current = self.build_initial_guess()
                
            self.update_history(V_current)
            
            # Solve
            # Relaxed thermal loop (1 iter if close)
            for t_iter in range(2):
                V_new, success, res, iters = self.newton_solve(V_current, tol=1e-7, max_iter=30)
                
                P_rey, Pa, H_el = self.get_full_state(V_new)
                T_new = self.calc_temperature_rise(P_rey, H_el, Pa)
                change = np.max(np.abs(T_new - self.T_current))
                self.T_current = 0.5*T_new + 0.5*self.T_current
                V_current = V_new
                if success and change < 0.2: break

            # Verify and Retry
            if res > 1e-6 or not success: 
                 # Fallback to Hertzian if previous step guess failed
                 print(f"Step {i+1} retry: resetting to Hertzian guess.")
                 V_current = self.build_initial_guess()
                 self.update_history(V_current)
                 V_new, success, res, iters = self.newton_solve(V_current, tol=1e-6, max_iter=35)
                 V_current = V_new

            P_rey, Pa, H = self.get_full_state(V_current)
            
            # Stats
            integral = np.sum((P_rey + Pa) * self.P0_ref * self.dx * self.R * self.B)
            ld_err = abs(self.W - integral) / self.W
            dt_step = time.perf_counter() - t0
            
            P_nd_list.append(P_rey)
            Pa_nd_list.append(Pa)
            H_list.append(H)
            load_err_list.append(ld_err)
            
            print(f"Step {i+1}/{n_steps} | Err={ld_err:.2e} | Res={res:.2e} | T={dt_step:.3f}s")
            
        print(f"Total Time: {time.perf_counter()-total_start:.2f}s")
        
        # Plotting
        X_plot = self.X_dim
        P_rey_nd_arr = np.array(P_nd_list)
        Pa_nd_arr = np.array(Pa_nd_list)
        H_arr = np.array(H_list)

        fig, axes = plt.subplots(2, 2, figsize=(12, 8))
        axes[0, 0].plot(theta_deg, um_profile)
        axes[0, 0].set_ylabel("um (m/s)")
        axes[0, 1].plot(theta_deg, vs_profile)
        axes[0, 1].set_ylabel("Vs (m/s)")
        axes[1, 0].plot(theta_deg, R_profile)
        axes[1, 0].set_ylabel("R (m)")
        axes[1, 1].plot(theta_deg, F_profile)
        axes[1, 1].set_ylabel("F (N)")
        for ax in axes.flat:
            ax.set_xlabel("Cam angle (deg)")
            ax.grid(True)
        fig.tight_layout()
        fig.savefig("Graph_Cam_Kinematics.png")

        colors = plt.cm.viridis(np.linspace(0, 1, n_steps))
        plt.figure(figsize=(10, 6))
        for i in range(n_steps):
            plt.plot(X_plot, P_rey_nd_arr[i], color=colors[i], alpha=0.4, linewidth=0.7)
        plt.xlabel("X/R")
        plt.ylabel("P_rey / Pmh")
        plt.title("Non-dimensional Reynolds Pressure (Cam Cycle)")
        plt.grid(True)
        plt.savefig("Graph_Reynolds_Pressure_Cycle.png")

        plt.figure(figsize=(10, 6))
        for i in range(n_steps):
            plt.plot(X_plot, Pa_nd_arr[i], color=colors[i], alpha=0.4, linewidth=0.7)
        plt.xlabel("X/R")
        plt.ylabel("P_asp / Pmh")
        plt.title("Non-dimensional Asperity Pressure (Cam Cycle)")
        plt.grid(True)
        plt.savefig("Graph_Asperity_Pressure_Cycle.png")

        plt.figure(figsize=(10, 6))
        for i in range(n_steps):
            plt.plot(X_plot, H_arr[i], color=colors[i], alpha=0.4, linewidth=0.7)
        plt.xlabel("X/R")
        plt.ylabel("H/R")
        plt.title("Non-dimensional Film Thickness (Cam Cycle)")
        plt.grid(True)
        plt.savefig("Graph_Film_Thickness_Cycle.png")
        print("Plots generated.")

if __name__ == "__main__":
    s = EHLSolver()
    s.run_cam_cycle()

