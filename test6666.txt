"""
1D Thermal Transient Mixed Lubrication - Cam-Follower Cycle
Optimized solver: Load error <1%, Residual <1e-7, Runtime <160s

===============================================================================
Model & Numerics Map (extracted from this file; updated as changes are made)
===============================================================================
Governing sub-models present
- Hydrodynamics: 1D (line-contact) transient Reynolds-type equation with
  roughness flow factors (Patir–Cheng style) and pressure/temperature dependent
  density and viscosity.
- Elasticity: linear elastic half-space line-contact deformation via a
  logarithmic convolution kernel (discretized in cell-averaged form).
- Mixed lubrication: asperity contact pressure via a Greenwood–Tripp-like
  empirical power law in separation parameter (Lambda = h/sigma).
- Thermal: algebraic (lumped) temperature update feeding viscosity/density
  (not a full TEHL energy PDE).

Independent variable / cycle parameterization
- Cam angle θ is the primary cycle parameter; time step is derived from
  θ via ω (θ = ω t). DO NOT CHANGE the kinematics formulas in load_cam_profile().

State variables and scalings used in the solver
- X = x/R (dimensionless coordinate, R varies with cam angle but grid is built
  using max(a/R) over the cycle).
- P = p/P0_ref (dimensionless hydrodynamic pressure).
- H = h/R (dimensionless film thickness).
- Pa = p_asp/P0_ref (dimensionless asperity contact pressure).
- Load balance target: Wld = Wl/(P0_ref*R) such that ∫(P+Pa) dX ≈ Wld.

Boundary conditions (current implementation)
- p = 0 at both ends of the computational domain.
- Cavitation is treated with a mass-conserving Elrod–Adams formulation using a
  universal variable φ such that:
    p = max(φ, 0),  θ = 1            when φ >= 0  (full film)
    p = 0,          θ = 1 + φ        when -1 <= φ < 0 (cavitation; θ is fluid fraction)
  This enforces nonnegative hydrodynamic pressure without ad-hoc clipping.
- Inlet full-film condition: θ=1 is naturally satisfied at boundaries by φ=0.

Solver strategy (current implementation after refactor below)
- Unknowns per cam angle: φ on interior nodes + central film thickness H0.
- Film thickness H is eliminated as an explicit unknown; it is obtained from:
    H = H0 + X^2/2 + D[p + Pa(H)]
  where D[·] is the elastic convolution operator. Because Pa depends on H,
  H is solved inside the residual evaluation by a short Picard iteration.
- Nonlinear solve: damped Newton with LU factorization reuse and feasibility
  line-search (reject steps that would make H <= 0 or θ < 0).

Diagnostics (mandatory checks)
- Load balance error per step.
- Reynolds/cavitation residual norm per step.
- Mass flux balance at domain boundaries (for cavitation/mass conservation).

===============================================================================
References & Rationale (why these numerical choices are made)
===============================================================================
- Elrod–Adams mass-conserving cavitation (universal variable formulation):
  avoids negative pressures without non-physical clipping and conserves mass
  in cavitated + full-film regions.
  Elrod, H.G. & Adams, M.L. (1974), "A computer program for cavitation and
  starvation problems", Proc. 1st Leeds-Lyon Symposium.
  (Also consistent with JFO mass-conserving cavitation treatment.)
- Elastic line-contact kernel: δ(x) = (2/(πE')) ∫ p(s) ln|x-s| ds + C.
  The constant C is absorbed into H0; discretization uses cell-averaged ln-kernel.
  Johnson, K.L., "Contact Mechanics", Cambridge University Press.
- Damped Newton + feasibility line search:
  ensures convergence and prevents non-physical intermediate iterates (negative
  film thickness or negative fluid fraction) without “clipping” the final solution.
"""

import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import time
from scipy.linalg import lu_factor, lu_solve


class EHLSolver:
    def __init__(self):
        print("Init EHL Solver...")
        
        self.P0_ref = 0.5e9
        self.mu00 = 0.01381
        self.Pr = 1.96e8
        self.alpha_input = 15e-9
        self.E_prime = 217e9
        self.B = 7.3e-3
        
        self.sigma = 0.2e-6
        self.eta_beta_sigma = 0.04
        self.sigma_beta_ratio = 0.001
        self.K_GT = (16 * np.pi * np.sqrt(2) / 15) * (self.eta_beta_sigma**2) * \
                   np.sqrt(self.sigma_beta_ratio) * self.E_prime
        
        self.T0_K = 363.15
        self.gamma_therm = 6.5e-4
        self.k_therm = 0.15
        self.P_max = 5.0e9
        self.beta0 = 0.04
        
        ln_eta0 = np.log(self.mu00)
        self.S0 = self.beta0 * (self.T0_K - 138.0) / (ln_eta0 + 9.67)
        self.Z_houper = self.alpha_input / (5.11e-9 * (ln_eta0 + 9.67))
        
        # Grid: tuned for stability/runtime; domain scaling handled in setup_grid()
        # (Smaller N is much faster; domain is widened instead of relying on large N.)
        self.N = 81
        self.delta_ad = 0.05
        self.sigma_factor = 1.0
        # Smoothing parameter for the Elrod–Adams universal variable switch.
        # This enables robust Newton convergence without altering physics at
        # practical pressure scales (p_smooth ~ P0_ref*cav_eps).
        self.cav_eps = 1e-8
        
        self.cam_data = self.load_cam_profile("updated_lift.txt")
        # Use a fixed dimensional x-grid based on max Hertz half-width.
        self.setup_grid(self.cam_data["max_a"])
        
        self.R = self.Um = self.Vs = self.W = None
        self.Um_mag = 1e-9
        self.Um_sign = 1.0
        self.a_Hertz = self.Pmh = self.Wld = 0.0
        self.dt = 1e-5
        self.is_transient = True
        self.rho_old = self.H_old = None
        self.T_current = np.full(self.N, self.T0_K)
        self.prev_V = None
        # History for transient mass-conserving cavitation (m = rho*H*theta)
        self.m_old = None
        self.hmin_dim = 0.0
        
        print("Init complete.")
    
    def load_cam_profile(self, path):
        data = np.loadtxt(path)
        theta_deg, lift = data[:, 0], data[:, 1]
        theta_rad = np.deg2rad(theta_deg)
        dlift = np.gradient(lift, theta_rad)
        ddlift = np.gradient(dlift, theta_rad)
        rb = 18.4e-3
        omega = (2 * np.pi * 300) / 60
        Vc = (rb + lift + ddlift) * omega
        Vf = omega * ddlift
        um = (Vf + Vc) / 2
        Vs = Vc - Vf
        R = ddlift + lift + rb
        F = 7130 * (lift + 1.77e-3) + ddlift * 0.05733 * omega**2
        Wl = np.maximum(F, 0.0) / self.B
        a_hertz = np.sqrt(8 * Wl * R / (np.pi * self.E_prime))
        max_a = float(np.max(a_hertz))
        max_a_over_r = np.max(a_hertz / R)
        dt = np.gradient(theta_rad) / omega
        time_arr = (theta_rad - theta_rad[0]) / omega
        return dict(theta_deg=theta_deg, um=um, Vs=Vs, R=R, F=F, dt=dt, 
                   time=time_arr, max_a_over_r=max_a_over_r, max_a=max_a)
    
    def setup_grid(self, max_a):
        """
        Fixed dimensional x-grid based on max Hertz half-width over the cycle.
        This keeps the transient history well-defined (no moving-grid term).
        """
        self.a_max_ref = max(float(max_a), 1e-12)
        self.x = np.linspace(-8.0 * self.a_max_ref, 4.0 * self.a_max_ref, self.N)
        self.dx = float(self.x[1] - self.x[0])
        # Elastic line-contact coefficient for dimensional displacement δ (meters):
        #   δ(x) = (2/(πE')) ∫ p(s) ln|x-s| ds + const
        self.CE = 2.0 / (np.pi * self.E_prime)
        self._compute_D_matrix()

    def _compute_D_matrix(self):
        N = self.N
        dx = self.dx
        D = np.zeros((N, N))
        b = dx / 2.0
        for i in range(N):
            xi = self.x[i]
            for j in range(N):
                xj = self.x[j]
                d1, d2 = xi - (xj - b), xi - (xj + b)
                v1 = d1 * np.log(abs(d1) + 1e-30) - d1 if abs(d1) > 1e-12 else 0.0
                v2 = d2 * np.log(abs(d2) + 1e-30) - d2 if abs(d2) > 1e-12 else 0.0
                D[i, j] = v1 - v2
        self.D_mat = D * self.CE
    
    def update_operating_state(self, um, vs, R, load):
        self.Um, self.Vs, self.R, self.W = um, vs, R, load
        self.Um_mag = max(abs(um), 1e-9)
        self.Um_sign = 1.0 if um >= 0 else -1.0
        self.u1d = self.Um_sign
        Wl = load / self.B
        self.a_Hertz = np.sqrt(8 * Wl * R / (np.pi * self.E_prime)) if Wl > 0 else 1e-9
        self.Pmh = 2 * Wl / (np.pi * self.a_Hertz) if self.a_Hertz > 0 else 0.0
        self.Wl = Wl  # [N/m] load per unit length for dimensional load balance
    
    def ro(self, p):
        """Density ratio ρ/ρ0 as function of dimensional pressure p [Pa]."""
        Pp = np.clip(p, 0, self.P_max)
        rho_T = np.maximum(1 - self.gamma_therm * (self.T_current - self.T0_K), 0.1)
        return (1 + 0.6e-9 * Pp / (1 + 1.7e-9 * Pp)) * rho_T
    
    def droo(self, p):
        """d(ρ/ρ0)/dp with p in Pa."""
        Pp = np.clip(p, 0, self.P_max)
        rho_T = np.maximum(1 - self.gamma_therm * (self.T_current - self.T0_K), 0.1)
        return 0.6e-9 / ((1 + 1.7e-9 * Pp)**2) * rho_T
    
    def c_mu(self, p):
        """Dynamic viscosity η(p,T) with p in Pa."""
        Pp = np.clip(p, 0, self.P_max)
        ln_eta0 = np.log(self.mu00)
        C1 = ln_eta0 + 9.67
        T_term = np.maximum((self.T_current - 138.0) / (self.T0_K - 138.0), 1e-5)
        bracket = T_term**(-self.S0) * (1 + Pp / self.Pr)**self.Z_houper - 1.0
        return self.mu00 * np.exp(np.clip(C1 * bracket, -50, 50))
    
    def calc_flow_factors(self, H):
        lam = np.maximum(H * self.R / (self.sigma * self.sigma_factor), 0)
        return 1 - 0.9 * np.exp(-0.56 * lam), 1 - 0.9 * np.exp(-0.2 * lam)
    
    def calc_asperity(self, h, deriv=False):
        """
        Asperity contact pressure p_asp [Pa] as function of separation h [m].
        Uses the same Greenwood–Tripp-like law as before, but returns dimensional pressure.
        """
        Lambda = np.clip(h / self.sigma, 0, 4)
        Pa = np.zeros_like(Lambda)  # [Pa]
        dPa = np.zeros_like(Lambda)  # dp/dh [Pa/m]
        mask = Lambda < 4
        if np.any(mask):
            val = np.maximum(4 - Lambda[mask], 0)
            Pa[mask] = self.K_GT * 4.4084e-5 * val**6.804 * self.sigma_factor
            if deriv:
                dPa[mask] = -self.K_GT * 4.4084e-5 * 6.804 * val**5.804 * self.sigma_factor / self.sigma
        return (Pa, dPa) if deriv else Pa
    
    # ---------------------------
    # Mass-conserving cavitation
    # ---------------------------
    def _phi_to_p_theta(self, phi):
        """
        Elrod–Adams universal variable:
          phi >= 0  -> p = P0_ref * phi, theta = 1
          -1 <= phi < 0 -> p = 0,   theta = 1 + phi
        """
        # Smooth "max(phi,0)" and indicator for semismooth robustness
        e = self.cav_eps
        s = np.sqrt(phi * phi + e * e)
        p_nd = 0.5 * (phi + s)  # ~max(phi,0)
        H = 0.5 * (1.0 + phi / s)  # ~Heaviside(phi)
        p = self.P0_ref * p_nd
        theta = 1.0 + (1.0 - H) * phi  # -> 1 (full film) or 1+phi (cavitation)
        return p, theta

    def _solve_film_thickness(self, p, H0, max_iter=30, tol=5e-13):
        """
        Solve implicit film equation with asperity deformation:
            h = h0 + x^2/(2R) + D[p + p_asp(h)]
        using a short Picard iteration with relaxation.
        """
        h0 = H0
        # Elastic displacement is defined up to an additive constant. For numerical
        # conditioning we anchor the deformation such that δ(x_left)=0, which is
        # equivalent to re-defining h0 by the absorbed constant (no physics change).
        delta = (self.D_mat @ p)
        delta = delta - delta[0]
        h = h0 + (self.x**2) / (2.0 * max(self.R, 1e-12)) + delta
        # Under-relaxation for robustness in mixed regime
        w = 0.6
        for _ in range(max_iter):
            p_asp = self.calc_asperity(h)
            delta = (self.D_mat @ (p + p_asp))
            delta = delta - delta[0]
            h_new = h0 + (self.x**2) / (2.0 * max(self.R, 1e-12)) + delta
            d = np.max(np.abs(h_new - h))
            h = w * h_new + (1.0 - w) * h
            if d < tol:
                break
        p_asp = self.calc_asperity(h)
        return h, p_asp

    def _reynolds_residual_elrod(self, phi, H0):
        """
        Conservative FV form of mass-conserving Reynolds (Elrod–Adams):
          d/dX( K dP/dX ) = d/dX( u * (rho*H*theta*phi_s) ) + transient squeeze
        where K = (rho * phi_x * H^3)/mu scaled by A_C.

        Unknowns are phi (universal variable), not P directly.
        """
        # Enforce boundary pressure = 0 (phi=0 => p=0, theta=1). This provides
        # a consistent inlet condition regardless of velocity sign; the upwind
        # flux uses interior values at the outlet.
        phi_full = np.zeros(self.N)
        phi_full[1:-1] = phi

        p, theta = self._phi_to_p_theta(phi_full)

        # Film thickness (implicit via asperity deformation)
        h, p_asp = self._solve_film_thickness(p, H0)

        # Properties depend on hydrodynamic pressure (not asperity pressure)
        rho = self.ro(p)
        mu = self.c_mu(p)
        Hnd = h / max(self.R, 1e-12)
        phi_x, phi_s = self.calc_flow_factors(np.maximum(Hnd, 0.0))

        # Diffusive flux at faces: J = -K dp/dx
        pf = p[1:] - p[:-1]
        hf = 0.5 * (h[1:] + h[:-1])
        rhof = 0.5 * (rho[1:] + rho[:-1])
        muf = 0.5 * (mu[1:] + mu[:-1])
        phixf = 0.5 * (phi_x[1:] + phi_x[:-1])
        Kf = rhof * phixf * (hf**3) / (12.0 * np.maximum(muf, 1e-30))
        Jf = -Kf * (pf / self.dx)  # length N-1

        # Convective (Couette) flux at faces with upwind
        Qn = rho * h * theta * phi_s
        U = self.Um  # signed entrainment speed [m/s]
        if U >= 0:
            Ff = U * Qn[:-1]
        else:
            Ff = U * Qn[1:]

        # Divergences on interior control volumes (nodes 1..N-2)
        idx = np.arange(1, self.N - 1)
        div_pois = (Jf[idx] - Jf[idx - 1]) / self.dx
        div_conv = (Ff[idx] - Ff[idx - 1]) / self.dx

        # Transient squeeze term for mass conservation: m = rho*H*theta
        squeeze = 0.0
        if self.is_transient and self.m_old is not None:
            m = rho[idx] * h[idx] * theta[idx]
            squeeze = (m - self.m_old[idx]) / self.dt

        # Residual at interior nodes (dimensional conservation):
        #   div_pois - div_conv - squeeze = 0
        #
        # Scale to dimensionless magnitude for better conditioning vs load equation.
        U_scale = max(abs(self.Um), 1e-6)
        F = (div_pois - div_conv - squeeze) / U_scale

        # Cache for diagnostics
        self._cache_last = dict(p=p, theta=theta, h=h, p_asp=p_asp, Jf=Jf, Ff=Ff)
        return F

    def system_func(self, V):
        # V = [phi_interior(1..N-2), H0]
        phi = V[:-1]
        H0 = V[-1]

        F_rey = self._reynolds_residual_elrod(phi, H0)

        # Load balance uses total contact pressure (hydro + asperity)
        p = self._cache_last["p"]
        p_asp = self._cache_last["p_asp"]
        F_load = (self.Wl - np.sum((p + p_asp) * self.dx)) / max(self.Wl, 1e-15)

        return np.concatenate([F_rey, [F_load]])

    def calc_jacobian(self, V, eps=1e-7):
        """
        Finite-difference Jacobian with sign-aware perturbations to avoid
        crossing the cavitation non-smooth point at phi=0 whenever possible.
        """
        m = len(V)
        J = np.zeros((m, m))
        F0 = self.system_func(V)

        for j in range(m):
            Vp = V.copy()
            # Use physically meaningful perturbations:
            # - phi is dimensionless but maps to pressure via p=P0_ref*phi, so
            #   we perturb phi enough to create an O(1e5 Pa) pressure change.
            # - h0 is dimensional (meters), so perturb on a fraction of h0.
            if j < m - 1:
                step = max(2e-4, 5e-4 * (1.0 + abs(V[j])))
            else:
                # h0 is ~O(1e-7..1e-6) m; use a small *relative* perturbation.
                step = max(1e-12, 1e-2 * max(abs(V[j]), 1e-10))
            if j < m - 1:
                # phi component: perturb in a direction that keeps sign when possible
                if V[j] > 10 * step:
                    Vp[j] += step
                elif V[j] < -10 * step:
                    Vp[j] -= step
                else:
                    Vp[j] += step
            else:
                # H0 component
                Vp[j] += step

            Fp = self.system_func(Vp)
            J[:, j] = (Fp - F0) / (Vp[j] - V[j])

        return J
    
    def update_history(self, V):
        # Store mass state for transient cavitation: m_old = rho*H*theta
        phi = V[:-1]
        H0 = V[-1]
        _ = self._reynolds_residual_elrod(phi, H0)
        p = self._cache_last["p"]
        h = self._cache_last["h"]
        theta = self._cache_last["theta"]
        rho = self.ro(p)
        self.m_old = rho * h * theta
    
    def get_full_state(self, V):
        # Return hydrodynamic pressure p [Pa], asperity p_asp [Pa], and film thickness h [m]
        phi = V[:-1]
        H0 = V[-1]
        _ = self._reynolds_residual_elrod(phi, H0)
        return self._cache_last["p"], self._cache_last["p_asp"], self._cache_last["h"]
    
    def calc_load_error(self, V):
        p, p_asp, _ = self.get_full_state(V)
        return abs(self.Wl - np.sum((p + p_asp) * self.dx)) / max(self.Wl, 1e-15)
    
    def calc_solution_change(self, V_new, V_old):
        """Max(|p_total_new - p_total_old|, |h_new - h_old|)"""
        p_new, pa_new, h_new = self.get_full_state(V_new)
        p_old, pa_old, h_old = self.get_full_state(V_old)
        max_dp = np.max(np.abs((p_new + pa_new) - (p_old + pa_old)))
        max_dh = np.max(np.abs(h_new - h_old))
        return max(max_dp, max_dh)

    def _balance_h0_with_fixed_phi(self, phi, h0, max_iter=12, tol=5e-4):
        """
        Robust 1D load-balance correction for the scalar h0 with phi held fixed.
        This is a block-Newton style update that strongly improves convergence of
        the coupled Newton system (pressure/cavitation already nearly satisfies
        Reynolds, while load balance can be off by O(1)).
        """
        h0 = float(max(h0, 1e-12))
        for _ in range(max_iter):
            V = np.concatenate([phi, [h0]])
            p, p_asp, h = self.get_full_state(V)
            W = float(np.sum((p + p_asp) * self.dx))
            r = (self.Wl - W) / max(self.Wl, 1e-15)
            if abs(r) < tol:
                break
            dh = max(1e-12, 0.2 * max(h0, 1e-10))
            Vp = np.concatenate([phi, [h0 + dh]])
            p2, p_asp2, _ = self.get_full_state(Vp)
            W2 = float(np.sum((p2 + p_asp2) * self.dx))
            dWdh = (W2 - W) / dh
            # Expect dWdh < 0. If not, fall back to a small safe increase.
            if not np.isfinite(dWdh) or dWdh >= 0:
                h0 *= 1.2
                continue
            # Newton update: W(h0) -> W_target
            h0 = h0 + (self.Wl - W) / dWdh
            h0 = float(max(h0, 1e-12))
        return h0
    
    def build_initial_guess(self):
        p = np.zeros(self.N)  # [Pa]
        if self.a_Hertz > 0:
            c = np.abs(self.x) <= self.a_Hertz
            p[c] = self.Pmh * np.sqrt(np.maximum(1 - (self.x[c] / self.a_Hertz) ** 2, 0))
        
        U = self.mu00 * self.Um_mag / (self.E_prime * self.R) if self.R else 1e-12
        G = self.alpha_input * self.E_prime
        W = max((self.W / self.B) / (self.E_prime * self.R), 1e-15) if self.R else 1e-15
        # Convert a correlation-like H0 (dimensionless h/R) into dimensional h0
        H0_nd = max(2.65 * U**0.7 * G**0.54 * W**-0.13, 1e-8)
        h0 = H0_nd * max(self.R, 1e-12)
        
        # Initial cavitation variable: set phi=P (full film everywhere initially)
        phi0 = p / self.P0_ref
        # Unknowns are interior nodes 1..N-2 + H0
        return np.concatenate([phi0[1:-1], [h0]])
    
    def _feasible(self, V):
        # Feasibility: theta >= 0 (phi >= -1), and film thickness strictly positive.
        phi = V[:-1]
        H0 = V[-1]
        phi_full = np.zeros(self.N)
        phi_full[1:-1] = phi
        _, theta = self._phi_to_p_theta(phi_full)
        if np.min(theta) < -1e-14:
            return False
        p = self.P0_ref * np.maximum(phi_full, 0.0)
        h, _ = self._solve_film_thickness(p, H0, max_iter=10)
        if np.min(h) <= 0.0:
            return False
        return True

    def newton_solve(self, V0, tol_change=1e-10, tol_res=1e-6, max_iter=30):
        """Damped Newton: converges primarily on residual norm (and change)."""
        V = V0.copy()
        F = self.system_func(V)
        sys_res = float(np.linalg.norm(F))

        best_V = V.copy()
        best_res = sys_res if self._feasible(V) else float("inf")
        best_change = float("inf")
        
        lu = None
        stall = 0
        
        for k in range(max_iter):
            if k == 0 or stall > 2:
                J = self.calc_jacobian(V)
                reg = 1e-8 * (1 + np.abs(np.diag(J)).mean())
                try:
                    lu = lu_factor(J + reg * np.eye(len(V)))
                    stall = 0
                except:
                    break
            
            try:
                dV = lu_solve(lu, -F)
            except:
                break
            
            dV_n = np.linalg.norm(dV)
            V_n = np.linalg.norm(V) + 1e-10
            if dV_n > 0.3 * V_n:
                dV *= 0.3 * V_n / dV_n
            
            V_old = V.copy()
            improved = False
            alpha = 1.0
            for _ in range(12):
                Vn = V + alpha * dV
                if not self._feasible(Vn):
                    alpha *= 0.5
                    continue
                Fn = self.system_func(Vn)
                rn = float(np.linalg.norm(Fn))
                if np.isfinite(rn) and rn < sys_res:
                    V, F, sys_res = Vn, Fn, rn
                    improved = True
                    break
                alpha *= 0.5
            
            if not improved:
                # If line search cannot reduce residual, force a Jacobian refresh
                # and allow the next iteration to try again.
                stall += 3
            
            change = float(np.max(np.abs(V - V_old)))
            if sys_res < best_res and self._feasible(V):
                best_V, best_res = V.copy(), sys_res
                best_change = change
            
            if change < tol_change and sys_res < tol_res:
                return V, sys_res, change
        
        return best_V, best_res, best_change
    
    def solve_step(self, V_start, dt):
        """Single transient step with retries."""
        self.update_history(V_start)
        self.dt = dt
        
        V_pred = 0.85 * V_start + 0.15 * self.prev_V if self.prev_V is not None else V_start.copy()
        if not self._feasible(V_pred):
            V_pred = V_start.copy()
        # Make a good *initial guess* for load balance by scaling phi uniformly.
        # This is not a post-solution "pressure scaling"; it only improves the
        # starting point for the coupled Newton solve.
        try:
            p0, p_asp0, _ = self.get_full_state(V_pred)
            W0 = float(np.sum((p0 + p_asp0) * self.dx))
            if W0 > 1e-12 and self.Wl > 0:
                scale = float(self.Wl / W0)
                if 0.3 < scale < 3.0:
                    V_pred[:-1] *= scale
        except Exception:
            pass

        # After bringing pressure level closer, correct h0 with phi held fixed.
        try:
            V_pred[-1] = self._balance_h0_with_fixed_phi(V_pred[:-1].copy(), V_pred[-1], max_iter=10, tol=1e-3)
        except Exception:
            pass

        V, res, chg = self.newton_solve(V_pred, tol_change=1e-10, tol_res=1e-6, max_iter=30)
        err = self.calc_load_error(V)
        
        # Retry from fresh guess if load error or residual are high
        if err > 0.005 or res > 1e-7:
            V2, res2, chg2 = self.newton_solve(self.build_initial_guess(), tol_change=1e-10, tol_res=1e-6, max_iter=35)
            err2 = self.calc_load_error(V2)
            if err2 < err:
                V, res, err = V2, res2, err2
        
        err = self.calc_load_error(V)
        
        # Thermal
        if self.gamma_therm > 0:
            p, p_asp, h = self.get_full_state(V)
            h = np.clip(h, 1e-12, 1e-2)
            eta = self.c_mu(p)
            a = max(self.a_Hertz, 1e-9)
            p_r = np.clip(p, 0, self.P_max)
            num = self.Um_mag * self.T_current * self.gamma_therm * h * p_r + 2 * a * eta * self.Um_mag**2 / h
            den = np.maximum(a * self.k_therm / h - self.Um_mag * self.gamma_therm * h * p_r, 1e-5)
            T_new = np.clip(self.T0_K + num / den, self.T0_K - 50, self.T0_K + 250)
            self.T_current = 0.7 * T_new + 0.3 * self.T_current
        
        self.update_history(V)
        self.prev_V = V_start.copy()
        
        # Diagnostics: mass flux balance (should not blow up)
        flux_err = self._mass_flux_balance()
        return V, res, err, flux_err

    def _mass_flux_balance(self):
        """
        Simple boundary mass-flux diagnostic (dimensionless):
          compare inflow and outflow flux of (rho*H*theta*phi_s).
        For cavitation, outflow may differ due to squeeze, but large drift
        indicates discretization/BC issues.
        """
        if not hasattr(self, "_cache_last"):
            return np.nan
        rho = self.ro(self._cache_last["p"])
        h = self._cache_last["h"]
        theta = self._cache_last["theta"]
        Hnd = h / max(self.R, 1e-12)
        _, phi_s = self.calc_flow_factors(np.maximum(Hnd, 0.0))
        Q = rho * h * theta * phi_s
        # Upwind boundary faces consistent with convective flux
        if self.Um >= 0:
            Qin, Qout = Q[0], Q[-2]
        else:
            Qin, Qout = Q[-1], Q[1]
        return abs(Qout - Qin) / (abs(Qin) + 1e-12)
    
    def run_cam_cycle(self):
        theta = self.cam_data["theta_deg"]
        um, vs = self.cam_data["um"], self.cam_data["Vs"]
        R, F = self.cam_data["R"], self.cam_data["F"]
        dt_arr = self.cam_data["dt"]
        n = len(theta)
        
        P_list, Pa_list, H_list = [], [], []
        errs, resids = [], []
        
        V = None
        t0 = time.perf_counter()
        
        print(f"Running {n} steps...")
        
        for i in range(n):
            self.update_operating_state(um[i], vs[i], R[i], F[i])
            
            if V is None:
                V = self.build_initial_guess()
                self.update_history(V)
            
            V, res, err, flux_err = self.solve_step(V, abs(dt_arr[i]))
            
            p, p_asp, h = self.get_full_state(V)
            P_list.append((p / self.Pmh) if self.Pmh > 0 else p)
            Pa_list.append((p_asp / self.Pmh) if self.Pmh > 0 else p_asp)
            H_list.append(h)
            errs.append(err)
            resids.append(res if np.isfinite(res) else 1e10)
            
            if i % 50 == 0 or err > 0.008 or res > 1e-7:
                # Pressure magnitude check requested by user (normalized by Hertz mean pressure)
                pmax = float(np.max(P_list[-1])) if len(P_list) else 0.0
                pamax = float(np.max(Pa_list[-1])) if len(Pa_list) else 0.0
                p_sum = pmax + pamax
                print(
                    f"Step {i+1:3d}/{n} θ={theta[i]:6.1f}° "
                    f"err={err:.2e} res={res:.2e} flux={flux_err:.2e} "
                    f"(p+pa)_max={p_sum:.3f} t={time.perf_counter()-t0:.1f}s"
                )
        
        total = time.perf_counter() - t0
        max_err, max_res = max(errs) * 100, max(resids)
        avg_err = np.mean(errs) * 100
        max_res_idx = np.argmax(resids)
        
        print("-" * 60)
        print(f"Done! Time={total:.1f}s MaxErr={max_err:.4f}% AvgErr={avg_err:.5f}% MaxRes={max_res:.2e}")
        
        ok = max_err <= 1 and max_res <= 1e-6 and total <= 160
        if max_err > 1:
            print(f"FAIL: Load {max_err:.3f}% > 1%")
        if max_res > 1e-6:
            print(f"FAIL: Res {max_res:.2e} > 1e-6")
        if total > 160:
            print(f"FAIL: Time {total:.1f}s > 160s")
        if ok:
            print("SUCCESS: All criteria met!")
        
        self._plot(theta, um, vs, R, F, P_list, Pa_list, H_list)
        return dict(time=total, max_err=max_err, max_res=max_res, ok=ok)
    
    def _plot(self, theta, um, vs, R, F, P_list, Pa_list, H_list):
        fig, ax = plt.subplots(2, 2, figsize=(12, 8))
        ax[0,0].plot(theta, um); ax[0,0].set_ylabel("um")
        ax[0,1].plot(theta, vs); ax[0,1].set_ylabel("Vs")
        ax[1,0].plot(theta, R); ax[1,0].set_ylabel("R")
        ax[1,1].plot(theta, F); ax[1,1].set_ylabel("F")
        for a in ax.flat:
            a.set_xlabel("θ"); a.grid()
        fig.tight_layout()
        fig.savefig("Graph_Cam_Kinematics.png")
        plt.close()
        
        nc = len(theta)
        c = plt.cm.viridis(np.linspace(0, 1, nc))
        for name, data in [("Reynolds_Pressure", P_list), ("Asperity_Pressure", Pa_list), ("Film_Thickness", H_list)]:
            plt.figure(figsize=(10, 6))
            for i in range(nc):
                plt.plot(self.x / self.a_max_ref, data[i], color=c[i], alpha=0.4, lw=0.7)
            plt.xlabel("x / a_max"); plt.ylabel(name.replace("_"," ")); plt.grid()
            plt.savefig(f"Graph_{name}_Cycle.png")
            plt.close()
        print("Plots saved.")
    
    def solve(self):
        return self.run_cam_cycle()


if __name__ == "__main__":
    EHLSolver().solve()
