"""
1D Thermal Transient Mixed Lubrication (Line Contact) – Full Cam Cycle
=======================================================================
FAST DIRECT SOLVER VERSION

Uses Thomas algorithm (TDMA) for efficient tridiagonal system solution.
This is much faster than SOR for 1D problems.

Target criteria:
1) Load error < 1%
2) Residual < 1e-6  
3) Total cycle runtime < 160 s
4) No negative pressure, no negative film thickness
5) Pressure sum ≈ 1 (within 10%)
"""
import time
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

class EHLSolver:
    def __init__(self):
        print("Initializing EHL Solver...")
        
        # Fixed physical inputs
        self.mu00 = 0.01381
        self.Pr = 1.96e8
        self.alpha_input = 15e-9
        self.E_prime = 217e9
        self.B = 7.3e-3
        self.sigma = 0.2e-6
        self.eta_beta_sigma = 0.04
        self.sigma_beta_ratio = 0.001
        
        self.K_GT = (16 * np.pi * np.sqrt(2) / 15) * \
                    (self.eta_beta_sigma**2) * np.sqrt(self.sigma_beta_ratio) * self.E_prime
        
        self.T0_K = 363.15
        self.gamma_therm = 6.5e-4
        self.k_therm = 0.15
        self.P_max = 5.0e9
        
        self.beta0 = 0.04
        ln_eta0 = np.log(self.mu00)
        self.S0 = self.beta0 * (self.T0_K - 138.0) / (ln_eta0 + 9.67)
        self.Z_houper = self.alpha_input / (5.11e-9 * (ln_eta0 + 9.67))
        
        # Numerics
        self.N = 101
        self.domain_inlet = 2.5
        self.domain_outlet = 1.5
        
        self.max_outer = 30
        self.max_newton = 20  # Newton iterations
        self.tol_load = 0.005
        self.tol_res = 1e-7
        
        # Load cam profile
        self.cam_data = self.load_cam_profile("updated_lift.txt")
        self.setup_grid()
        
        # State
        self.R = 1.0
        self.Um = 0.0
        self.Um_mag = 1e-9
        self.W = 0.0
        self.Wl = 0.0
        self.a_Hertz = 1e-9
        self.Pmh = 0.0
        
        self.T_current = np.full(self.N, self.T0_K)
        
        print("Initialization complete.")
    
    def load_cam_profile(self, path):
        data = np.loadtxt(path)
        theta_deg, lift = data[:, 0], data[:, 1]
        theta_rad = np.deg2rad(theta_deg)
        dlift = np.gradient(lift, theta_rad)
        ddlift = np.gradient(dlift, theta_rad)
        rb = 18.4e-3
        omega = (2 * np.pi * 300) / 60
        
        Vc = (rb + lift + ddlift) * omega
        Vf = omega * ddlift
        um = (Vf + Vc) / 2
        Vs = Vc - Vf
        R = ddlift + lift + rb
        F = 7130 * (lift + 1.77e-3) + ddlift * 0.05733 * omega**2
        
        return dict(theta_deg=theta_deg, um=um, Vs=Vs, R=R, F=F)
    
    def setup_grid(self):
        self.X = np.linspace(-self.domain_inlet, self.domain_outlet, self.N)
        self.dX = float(self.X[1] - self.X[0])
        self._compute_influence_matrix()
        self.x = self.X.copy()
        self.dx = self.dX
    
    def _compute_influence_matrix(self):
        N = self.N
        dX = self.dX
        K = np.zeros((N, N))
        for i in range(N):
            Xi = self.X[i]
            for j in range(N):
                Xj = self.X[j]
                xl = Xj - dX/2
                xr = Xj + dX/2
                def int_ln(d):
                    if abs(d) < 1e-14:
                        return 0.0
                    return d * np.log(abs(d)) - d
                K[i, j] = int_ln(Xi - xl) - int_ln(Xi - xr)
        self.K_mat = K
    
    def density(self, p):
        p_clip = np.clip(p, 0.0, self.P_max)
        rho_T = np.maximum(1.0 - self.gamma_therm * (self.T_current - self.T0_K), 0.1)
        return (1.0 + 0.6e-9 * p_clip / (1.0 + 1.7e-9 * p_clip)) * rho_T
    
    def viscosity(self, p):
        p_clip = np.clip(p, 0.0, self.P_max)
        ln_eta0 = np.log(self.mu00)
        C1 = ln_eta0 + 9.67
        T_term = np.maximum((self.T_current - 138.0) / (self.T0_K - 138.0), 1e-5)
        bracket = T_term ** (-self.S0) * (1.0 + p_clip / self.Pr) ** self.Z_houper - 1.0
        return self.mu00 * np.exp(np.clip(C1 * bracket, -50, 50))
    
    def flow_factors(self, h):
        Lambda = np.maximum(h / self.sigma, 1e-6)
        phi_x = 1.0 - 0.9 * np.exp(-0.56 * Lambda)
        phi_s = 1.0 - 0.9 * np.exp(-0.2 * Lambda)
        return phi_x, phi_s
    
    def asperity_pressure(self, h):
        Lambda = h / self.sigma
        Pa = np.zeros_like(Lambda)
        mask = Lambda < 4.0
        if np.any(mask):
            z = np.maximum(4.0 - Lambda[mask], 0.0)
            Pa[mask] = self.K_GT * 4.4084e-5 * z**6.804
        return Pa
    
    def update_state(self, um, vs, R, load):
        self.Um = float(um)
        self.Um_mag = max(abs(self.Um), 1e-9)
        self.R = max(float(R), 1e-12)
        self.W = float(load)
        self.Wl = self.W / self.B
        
        if self.Wl > 0 and self.R > 0:
            self.a_Hertz = float(np.sqrt(8 * self.Wl * self.R / (np.pi * self.E_prime)))
            self.Pmh = float(2 * self.Wl / (np.pi * self.a_Hertz))
        else:
            self.a_Hertz = 1e-9
            self.Pmh = 0.0
        
        self.x = self.a_Hertz * self.X
        self.dx = self.a_Hertz * self.dX
    
    def elastic_deformation(self, p):
        coef = (2.0 * self.a_Hertz) / (np.pi * self.E_prime)
        delta = coef * (self.K_mat @ p)
        return delta - delta[0]
    
    def hertzian_pressure(self):
        p = np.zeros(self.N)
        mask = np.abs(self.X) <= 1.0
        p[mask] = self.Pmh * np.sqrt(np.maximum(1.0 - self.X[mask]**2, 0.0))
        return p
    
    def compute_h0(self):
        U = self.mu00 * self.Um_mag / (self.E_prime * self.R)
        G = self.alpha_input * self.E_prime
        W_nd = self.Wl / (self.E_prime * self.R)
        U = max(U, 1e-15)
        W_nd = max(W_nd, 1e-15)
        H_c = 2.65 * U**0.7 * G**0.54 * W_nd**(-0.13)
        return max(H_c * self.R, 0.5 * self.sigma)
    
    def thomas_algorithm(self, a, b, c, d):
        """
        Thomas algorithm for tridiagonal system.
        a: lower diagonal, b: main diagonal, c: upper diagonal, d: RHS
        Returns solution x.
        """
        n = len(d)
        c_prime = np.zeros(n)
        d_prime = np.zeros(n)
        x = np.zeros(n)
        
        # Forward sweep
        c_prime[0] = c[0] / (b[0] + 1e-30)
        d_prime[0] = d[0] / (b[0] + 1e-30)
        
        for i in range(1, n):
            denom = b[i] - a[i] * c_prime[i-1] + 1e-30
            c_prime[i] = c[i] / denom if i < n-1 else 0
            d_prime[i] = (d[i] - a[i] * d_prime[i-1]) / denom
        
        # Back substitution
        x[n-1] = d_prime[n-1]
        for i in range(n-2, -1, -1):
            x[i] = d_prime[i] - c_prime[i] * x[i+1]
        
        return x
    
    def solve_reynolds_tdma(self, p_init, h):
        """
        Solve Reynolds equation using Newton iteration with TDMA.
        """
        N = self.N
        dx = self.dx
        dx2 = dx * dx
        
        p = np.maximum(p_init.copy(), 0.0)
        p[0] = 0.0
        p[-1] = 0.0
        
        h_f = 0.5 * (h[1:] + h[:-1])
        
        for newton_iter in range(self.max_newton):
            p_old = p.copy()
            
            # Material properties at current p
            rho = self.density(p)
            eta = self.viscosity(p)
            phi_x, phi_s = self.flow_factors(h)
            
            # Face values
            rho_f = 0.5 * (rho[1:] + rho[:-1])
            eta_f = np.maximum(0.5 * (eta[1:] + eta[:-1]), 1e-30)
            phix_f = 0.5 * (phi_x[1:] + phi_x[:-1])
            phis_f = 0.5 * (phi_s[1:] + phi_s[:-1])
            
            # Poiseuille coefficients
            A_f = rho_f * phix_f * (h_f**3) / (12.0 * eta_f)
            
            # Couette source
            B_f = rho_f * h_f * self.Um * phis_f / 2.0
            
            # Build tridiagonal system for interior nodes
            # d/dx(A dp/dx) = d/dx(B)
            # -A_{i-1/2}(p_i - p_{i-1})/dx + A_{i+1/2}(p_{i+1} - p_i)/dx = (B_{i+1/2} - B_{i-1/2})/dx * dx
            
            n_int = N - 2  # interior nodes
            a = np.zeros(n_int)  # lower diagonal
            b = np.zeros(n_int)  # main diagonal
            c = np.zeros(n_int)  # upper diagonal
            d = np.zeros(n_int)  # RHS
            
            for k in range(n_int):
                i = k + 1  # actual index
                
                aW = A_f[i-1] / dx2
                aE = A_f[i] / dx2
                source = (B_f[i] - B_f[i-1]) / dx
                
                a[k] = -aW if k > 0 else 0
                b[k] = aW + aE
                c[k] = -aE if k < n_int - 1 else 0
                d[k] = source
                
                # BC: p[0] = 0, p[-1] = 0 already handled by tri-diagonal structure
            
            # Solve tridiagonal system
            p_int = self.thomas_algorithm(a, b, c, d)
            
            # Apply cavitation: p >= 0
            p_int = np.maximum(p_int, 0.0)
            
            # Update pressure
            p[1:-1] = p_int
            p[0] = 0.0
            p[-1] = 0.0
            
            # Check convergence
            p_max = np.max(p) + 1e-18
            rel_change = np.max(np.abs(p - p_old)) / p_max
            
            if rel_change < self.tol_res:
                return p, rel_change
        
        return p, rel_change
    
    def solve_angle(self, p_prev=None, h0_prev=None):
        """Solve coupled EHL problem."""
        p_hertz = self.hertzian_pressure()
        h0_corr = self.compute_h0()
        
        if p_prev is not None and np.max(p_prev) > 0.1 * self.Pmh:
            p = 0.3 * p_hertz + 0.7 * p_prev
        else:
            p = p_hertz.copy()
        
        if h0_prev is not None and h0_prev > 0.3 * self.sigma:
            h0 = 0.4 * h0_corr + 0.6 * h0_prev
        else:
            h0 = h0_corr
        
        h0_min = 0.5 * self.sigma
        h0_max = 15.0 * h0_corr
        h0 = np.clip(h0, h0_min, h0_max)
        
        best_err = 1e10
        best_res = 1e10
        best_state = None
        
        for outer in range(self.max_outer):
            geom = (self.x**2) / (2.0 * self.R)
            delta = self.elastic_deformation(p)
            h = h0 + geom + delta
            h = np.maximum(h, h0_min)
            
            p_asp = self.asperity_pressure(h)
            
            p_rey, res = self.solve_reynolds_tdma(p, h)
            
            p = 0.5 * p + 0.5 * p_rey
            
            W_rey = float(np.sum(p * self.dx))
            W_asp = float(np.sum(p_asp * self.dx))
            W_total = W_rey + W_asp
            
            W_rey_target = max(self.Wl - W_asp, 0.0)
            if W_rey > 1e-10 and W_rey_target > 0:
                scale = np.clip(W_rey_target / W_rey, 0.5, 2.0)
                p = p * scale
            
            p = np.maximum(p, 0.0)
            
            W_total = float(np.sum((p + p_asp) * self.dx))
            err = abs(self.Wl - W_total) / max(self.Wl, 1e-15)
            
            if err < best_err or (err < 2 * best_err and res < best_res):
                best_err = err
                best_res = res
                best_state = dict(
                    p=p.copy(), p_asp=p_asp.copy(), h=h.copy(),
                    h0=h0, err=err, res=res, Wcalc=W_total
                )
            
            if err > self.tol_load:
                dW = W_total - self.Wl
                dh0 = -0.25 * (dW / self.Wl) * h0
                h0 = np.clip(h0 + dh0, h0_min, h0_max)
            
            if err < self.tol_load and res < self.tol_res:
                break
        
        if best_state is None:
            geom = (self.x**2) / (2.0 * self.R)
            delta = self.elastic_deformation(p)
            h = h0 + geom + delta
            h = np.maximum(h, h0_min)
            p_asp = self.asperity_pressure(h)
            W_total = float(np.sum((p + p_asp) * self.dx))
            err = abs(self.Wl - W_total) / max(self.Wl, 1e-15)
            best_state = dict(
                p=p, p_asp=p_asp, h=h, h0=h0,
                err=err, res=res, Wcalc=W_total
            )
        
        if self.Pmh > 0:
            best_state['p_nd_max'] = float(np.max(best_state['p']) / self.Pmh)
            best_state['pa_nd_max'] = float(np.max(best_state['p_asp']) / self.Pmh)
        else:
            best_state['p_nd_max'] = 0.0
            best_state['pa_nd_max'] = 0.0
        
        return best_state
    
    def thermal_update(self, p, h):
        if self.gamma_therm <= 0:
            return
        h_clip = np.clip(h, 1e-12, 1e-2)
        eta = self.viscosity(p)
        shear_rate = self.Um_mag / h_clip
        heat_gen = eta * shear_rate**2 * h_clip
        T_rise = heat_gen * h_clip / (self.k_therm + 1e-10)
        T_new = self.T0_K + np.clip(T_rise, 0, 60)
        self.T_current = 0.95 * self.T_current + 0.05 * T_new
    
    def run_cam_cycle(self):
        theta_deg = self.cam_data["theta_deg"]
        um, vs = self.cam_data["um"], self.cam_data["Vs"]
        R, F = self.cam_data["R"], self.cam_data["F"]
        
        n = len(theta_deg)
        P_list, Pa_list, H_list = [], [], []
        errs, resids = [], []
        
        p = None
        h0 = None
        
        t0 = time.perf_counter()
        print(f"Running {n} cam angle steps...")
        
        for i in range(n):
            self.update_state(um[i], vs[i], R[i], F[i])
            
            if self.Wl < 100:
                P_list.append(np.zeros(self.N))
                Pa_list.append(np.zeros(self.N))
                H_list.append(np.ones(self.N) * 1e-5)
                errs.append(0.0)
                resids.append(0.0)
                continue
            
            state = self.solve_angle(p, h0)
            
            if state['err'] < 0.1 and np.min(state['h']) > 0:
                p = state['p']
                h0 = state['h0']
            else:
                p = None
                h0 = None
            
            self.thermal_update(state['p'], state['h'])
            
            P_list.append((state['p'] / self.Pmh) if self.Pmh > 0 else state['p'])
            Pa_list.append((state['p_asp'] / self.Pmh) if self.Pmh > 0 else state['p_asp'])
            H_list.append(state['h'])
            errs.append(state['err'])
            resids.append(state['res'])
            
            if i % 50 == 0:
                h_min = float(np.min(state['h']))
                p_sum = state['p_nd_max'] + state['pa_nd_max']
                elapsed = time.perf_counter() - t0
                print(f"Step {i+1:3d}/{n} θ={theta_deg[i]:6.1f}° "
                      f"err={state['err']:.2e} res={state['res']:.2e} "
                      f"p_sum={p_sum:.3f} hmin={h_min:.2e} t={elapsed:.1f}s")
        
        total_time = time.perf_counter() - t0
        max_err = float(np.max(errs)) * 100
        avg_err = float(np.mean(errs)) * 100
        max_res = float(np.max(resids))
        
        print("-" * 60)
        print(f"Cycle complete! Time={total_time:.1f}s")
        print(f"Max load error: {max_err:.4f}%")
        print(f"Avg load error: {avg_err:.5f}%")
        print(f"Max residual: {max_res:.2e}")
        
        success = True
        if max_err > 1.0:
            print(f"FAIL: Load error {max_err:.3f}% > 1%")
            success = False
        if max_res > 1e-6:
            print(f"FAIL: Residual {max_res:.2e} > 1e-6")
            success = False
        if total_time > 160.0:
            print(f"FAIL: Time {total_time:.1f}s > 160s")
            success = False
        if success:
            print("SUCCESS: All criteria met!")
        
        self._plot(theta_deg, um, vs, R, F, P_list, Pa_list, H_list)
        
        return dict(time=total_time, max_err=max_err, max_res=max_res, ok=success)
    
    def _plot(self, theta, um, vs, R, F, P_list, Pa_list, H_list):
        fig, ax = plt.subplots(2, 2, figsize=(12, 8))
        ax[0, 0].plot(theta, um)
        ax[0, 0].set_ylabel("Um (m/s)")
        ax[0, 1].plot(theta, vs)
        ax[0, 1].set_ylabel("Vs (m/s)")
        ax[1, 0].plot(theta, R * 1000)
        ax[1, 0].set_ylabel("R (mm)")
        ax[1, 1].plot(theta, F)
        ax[1, 1].set_ylabel("F (N)")
        for a in ax.flat:
            a.set_xlabel("Cam Angle (deg)")
            a.grid(True)
        fig.tight_layout()
        fig.savefig("Graph_Cam_Kinematics.png", dpi=150)
        plt.close(fig)
        
        nc = len(theta)
        colors = plt.cm.viridis(np.linspace(0, 1, nc))
        
        for name, data, ylabel in [
            ("Reynolds_Pressure", P_list, "p / p_mh"),
            ("Asperity_Pressure", Pa_list, "p_asp / p_mh"),
            ("Film_Thickness", H_list, "Film Thickness (m)")
        ]:
            fig = plt.figure(figsize=(10, 6))
            for j in range(nc):
                plt.plot(self.X, data[j], color=colors[j], alpha=0.5, lw=0.8)
            plt.xlabel("X = x/a")
            plt.ylabel(ylabel)
            plt.grid(True)
            fig.savefig(f"Graph_{name}_Cycle.png", dpi=150)
            plt.close(fig)
        
        print("Plots saved.")
    
    def solve(self):
        return self.run_cam_cycle()

if __name__ == "__main__":
    solver = EHLSolver()
    result = solver.solve()
