


import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import root
import time
class EHLSolver:
    def __init__(self):
        print("Init start")
        # Constants
        self.P0_ref = 0.5e9 # 0.5 GPa Ref
        self.mu00 = 0.01381
        self.muinf = 6.315e-5
        self.Pr = 1.98e8
        self.alpha_input = 15e-9
        self.z_input = 0.65
        
        self.E1 = 210e9
        self.E2 = 210e9
        self.nu1 = 0.3
        self.nu2 = 0.3
        self.E_prime = 217e9
        
        self.B = 7.3e-3 # contact Length (m)
        self.R = None
        self.Um = None
        self.Um_mag = None
        self.Um_sign = None
        self.Vs = None
  
        self.mu00 = 0.01381 # Pa.s
        self.alpha_input = 15e-9 # 1/Pa
        self.P0_ref = 0.5e9 # 0.5 GPa ref
        self.Pr = 1.96e8 # Roelands Pr
        self.muinf = 6.31e-5 # Roelands mu_inf
        self.rho0 = 870.0 # kg/m3 (Standard Oil Density)
        self.Cp = 2000.0 # J/kgK (Standard Oil Specific Heat)
        
        # Grid
        self.N = 121 
        self.delta_ad = 0.05 # significantly reduced to sharpen spike and profile
        
        # Mixed Lubrication Parameters (Greenwood-Tripp)
        # STRICT USER PARAMETERS (DO NOT CHANGE)
        self.sigma = 0.2e-6  # 0.2 um
        self.eta_beta_sigma = 0.04
        self.sigma_beta_ratio = 0.001 # sigma/beta
        # K_GT Coefficient
        self.K_GT = (16 * np.pi * np.sqrt(2) / 15) * (self.eta_beta_sigma**2) * np.sqrt(self.sigma_beta_ratio) * self.E_prime
        
        # Thermal Parameters
        self.T0_C = 90.0 # Operating Temp (Inlet) - User Spec
        self.T0_K = self.T0_C + 273.15 # 363.15 K
        self.beta0 = 0.04 # 1/K 
        self.gamma_therm = 6.5e-4 # 1/K 
        self.k_therm = 0.15 # W/mK 
        self.P_max = 5.0e9

        ln_eta0 = np.log(self.mu00)
        self.S0 = self.beta0 * (self.T0_K - 138.0) / (ln_eta0 + 9.67)
        self.Z_houper = self.alpha_input / (5.11e-9 * (ln_eta0 + 9.67))
        
        self.cam_data = self.load_cam_profile("/content/am/updated_lift.txt")
        self.setup_grid(self.cam_data["max_a_over_r"])
    
        # State
        self.F0_norm = 0.0 
        self.dt = self.cam_data["dt"][0]
        self.is_transient = True
        self.rho_old = None
        self.H_old = None
        self.kw = 0.0
        self.sigma_factor = 1.0 
        
        # Thermal State
        self.T_current = np.full(self.N, self.T0_K)

    def load_cam_profile(self, path):
        data = np.loadtxt(path)
        theta_deg = data[:, 0]
        lift = data[:, 1]
        theta_rad = np.deg2rad(theta_deg)
        dlift = np.gradient(lift, theta_rad)
        ddlift = np.gradient(dlift, theta_rad)
        rb = 18.4e-3
        N = 300
        omega = (2 * np.pi * N) / 60
        Vc = (rb + lift + ddlift) * omega
        Vf = omega * ddlift
        um = (Vf + Vc) / 2
        Vs = Vc - Vf
        R = ddlift + lift + rb
        K_spring = 7130
        delta = 1.77e-3
        M_eq = 0.05733
        F = K_spring * (lift + delta) + ddlift * M_eq * omega**2
        Wl = np.maximum(F, 0.0) / self.B
        a_hertz = np.sqrt(8 * Wl * R / (np.pi * self.E_prime))
        a_over_r = a_hertz / R
        max_a_over_r = np.max(a_over_r)
        dt = np.gradient(theta_rad) / omega
        time = (theta_rad - theta_rad[0]) / omega
        return {
            "theta_deg": theta_deg,
            "theta_rad": theta_rad,
            "lift": lift,
            "dlift": dlift,
            "ddlift": ddlift,
            "um": um,
            "Vs": Vs,
            "R": R,
            "F": F,
            "dt": dt,
            "time": time,
            "max_a_over_r": max_a_over_r,
        }

    def setup_grid(self, max_a_over_r):
        left = -4.0 * max_a_over_r
        right = 3.0 * max_a_over_r
        self.X_dim = np.linspace(left, right, self.N)
        self.dx = self.X_dim[1] - self.X_dim[0]
        self.X = self.X_dim
        self.CE = -4 * self.P0_ref / (np.pi * self.E_prime)
        self.hmin_dim = 0.0
        self.gamma_h = 1e12
        self.calculate_D_matrix()
        self.T_current = np.full(self.N, self.T0_K)

    def update_operating_state(self, um, vs, R, load):
        self.Um = um
        self.Vs = vs
        self.R = R
        self.W = load
        self.Um_mag = max(abs(self.Um), 1e-9)
        self.Um_sign = 1.0 if self.Um >= 0 else -1.0
        self.A_C = self.R * self.P0_ref / (12 * self.mu00 * self.Um_mag)
        self.u1d = self.Um_sign
        Wl = self.W / self.B
        self.a_Hertz = np.sqrt(8 * Wl * self.R / (np.pi * self.E_prime))
        self.Pmh = 2 * Wl / (np.pi * self.a_Hertz) if self.a_Hertz > 0 else 0.0
        self.Wld = Wl / (self.R * self.P0_ref)
        Rey_Stiffness = self.A_C / (self.dx**2)
        self.g1 = 1e15 * Rey_Stiffness
        
    def calculate_D_matrix(self):
        N = self.N
        dx = self.dx
        D = np.zeros((N, N))
        b = dx / 2.0
        
        # Exact integral of ln|x-s|
        for i in range(N):
            xi = self.X_dim[i]
            for j in range(N):
                xj = self.X_dim[j]
                
                d1 = xi - (xj - b)
                d2 = xi - (xj + b)
                
                def F(u):
                    if abs(u) < 1e-12: return 0.0
                    return u * np.log(abs(u)) - u
                
                D[i, j] = (F(d1) - F(d2))
                
        self.D_mat = D * self.CE # Note: D_mat operates on P_dimensionless -> Deflection_dimensionless

    # --- Physics ---
     # --- Physics ---

    def calc_flow_factors(self, H_dimless):
        """
        Patir & Cheng (isotropic roughness) pressure and shear flow factors.
        Lambda = h / sigma. For perfectly smooth surfaces, phi = 1.
        """
        if self.sigma_factor <= 0.0:
            ones = np.ones_like(H_dimless)
            return ones, ones

        sigma_eff = self.sigma * self.sigma_factor
        h_real = H_dimless * self.R
        lambda_ratio = h_real / sigma_eff

        # Physical floor: negative film thickness implies contact -> lambda = 0.
        lambda_ratio = np.where(lambda_ratio < 0.0, 0.0, lambda_ratio)

        # Patir & Cheng exponential fits (isotropic surfaces)
        phi_x = 1.0 - 0.9 * np.exp(-0.56 * lambda_ratio)
        phi_s = 1.0 - 0.9 * np.exp(-0.2 * lambda_ratio)

        return phi_x, phi_s
    def ro(self, P_dim_less, T_K=None):
        # Dowson-Higginson Thermal
        if T_K is None: T_K = self.T_current
        P = np.clip(P_dim_less * self.P0_ref, 0.0, self.P_max)
        
        # Density Pressure Part
        a = 0.6e-9
        b = 1.7e-9
        term_p = (1 + (a * P) / (1 + b * P))
        
        # Thermal Part
        DeltaT = T_K - self.T0_K
        term_T = (1 - self.gamma_therm * DeltaT)
        term_T = np.maximum(term_T, 1e-3)
        
        return np.nan_to_num(term_p * term_T, nan=1.0, posinf=1e6, neginf=1e-6)

    def droo(self, P_dim_less, T_K=None):
        if T_K is None: T_K = self.T_current
        P = np.clip(P_dim_less * self.P0_ref, 0.0, self.P_max)
        
        a = 0.6e-9
        b = 1.7e-9
        df_dP = a / ((1 + b*P)**2)
        
        DeltaT = T_K - self.T0_K
        term_T = (1 - self.gamma_therm * DeltaT)
        term_T = np.maximum(term_T, 1e-3)
        
        return np.nan_to_num(df_dP * self.P0_ref * term_T, nan=0.0, posinf=0.0, neginf=0.0)

    # Skipping dro2 (2nd deriv) as it's not strictly used in Newton K matrix often
    
    def c_mu(self, P_dim_less, T_K=None):
        # Houpert's Equation (Thermal)
        if T_K is None: T_K = self.T_current
        P = np.clip(P_dim_less * self.P0_ref, 0.0, self.P_max)
        
        ln_eta0 = np.log(self.mu00)
        C1 = ln_eta0 + 9.67
        
        T_term = (T_K - 138.0) / (self.T0_K - 138.0)
        T_term = np.maximum(T_term, 1e-5)
        
        term_T_S0 = T_term**(-self.S0)
        
        # Pressure Term
        term_P_Z = (1 + P / self.Pr)**self.Z_houper
        
        bracket = term_T_S0 * term_P_Z - 1.0
        
        exponent = C1 * bracket
        exponent = np.clip(exponent, -50.0, 50.0)
        
        return self.mu00 * np.exp(exponent)

    def calc_temperature_rise(self, P_dist, H_dist, Pa_dist=None):
        um = self.Um_mag
        gamma = self.gamma_therm
        k = self.k_therm
        a_hertz = self.a_Hertz if self.a_Hertz > 0 else 1.0
        P_real = np.clip(P_dist * self.P0_ref, 0.0, self.P_max)
        H_safe = np.clip(H_dist, 1e-12, 1e-2)
        h = H_safe * self.R
        eta = self.c_mu(P_dist, self.T_current)
        T = self.T_current
        num_term_1 = um * T * gamma * h * P_real
        num_term_2 = (2.0 * a_hertz * eta * um**2) / h
        numerator = num_term_1 + num_term_2
        den_term_1 = (a_hertz * k) / h
        den_term_2 = um * gamma * h * P_real
        denominator = den_term_1 - den_term_2
        denominator = np.where(denominator < 1e-5, 1e-5, denominator)
        Delta_T = numerator / denominator
        Phi_dist = numerator
        Alpha_dist = denominator
        Heff_dist = h
        T_new = self.T0_K + Delta_T
        T_new = np.clip(T_new, self.T0_K - 50.0, self.T0_K + 250.0)
        return T_new, Phi_dist, Alpha_dist, Heff_dist
    
    # --- Asperity Contact ---
    def calc_asperity(self, H_dimless, calc_deriv=False):
        # H is dimensionless H/R.
        # Need actual H for H/sigma
        if self.a_Hertz == 0: # Safety
            H_real = H_dimless * 0
        else:
            # Grid H is h/R. So H_real = H * R.
            H_real = H_dimless * self.R
        Lambda = H_real / self.sigma
        Lambda = np.clip(Lambda, 0.0, 4.0)
        
        # F_5/2 approximation (Zhu & Hu 2001 EHL)
        # F5/2(LAMBDA) approx 4.4084e-5 * (4 - LAMBDA)^6.804
        
        mask = Lambda <= 4.0
        Pa_real = np.zeros_like(Lambda)
        dPa_dH_real = np.zeros_like(Lambda)
        
        if np.any(mask):
            val = 4.0 - Lambda[mask]
            # Coeffs
            A_fit = 4.4084e-5
            Z_fit = 6.804
            
            F_stat = A_fit * (val**Z_fit)
            dF_dL = -A_fit * Z_fit * (val**(Z_fit-1)) # dF/dLambda
            # Note: dF/dL is negative usually because as L increases, F decreases.
            
            # Scale by sigma_factor
            Pa_real[mask] = self.K_GT * F_stat * self.sigma_factor
            
            if calc_deriv:
                # dPa/dH = dPa/dL * dL/dH = dPa/dL * (1/sigma)
                # Scale derivative too
                dPa_dH_real[mask] = (self.K_GT * dF_dL * self.sigma_factor) / self.sigma
                # dPa/dH_dim = dPa/dH_real * dH_real/dH_dim * (1/P0_ref)? 
        # dH_real/dH_dim = R
        Pa_dim = Pa_real / self.P0_ref
        
        if calc_deriv:
            scale_H = self.R
            dPa_dH_dim = (dPa_dH_real * scale_H) / self.P0_ref
            return Pa_dim, dPa_dH_dim
        else:
            return Pa_dim

    # --- Artificial Diffusion Terms ---
    
    def beta_ad(self, P, H, eps_shift):
        idx = np.arange(2, self.N-1) 
        rho_prime = self.droo(P)
        val = self.dx * rho_prime * H 
        
        if eps_shift == 0: 
            beta = 0.5 * (val[idx] + val[idx-1])
        else: 
            beta = 0.5 * (val[idx] + val[idx+1])
            
        return beta * (self.delta_ad / self.A_C)
        
    def get_eps_beta(self, P, H):
        idx = np.arange(2, self.N-1)
        H_eff = np.clip(H, 1e-12, 1e-2)
        rho = self.ro(P)
        mu = self.c_mu(P)
        phi_x, _ = self.calc_flow_factors(H_eff)
        
        rho_sum_1 = rho[idx] + rho[idx-1]
        mu_sum_1 = mu[idx] + mu[idx-1]
        H_sum_1 = H_eff[idx] + H_eff[idx-1]
        phi_x_avg_1 = 0.5 * (phi_x[idx] + phi_x[idx-1])
        
        beta1 = self.beta_ad(P, H, 0)
        eps1 = (rho_sum_1 * (H_sum_1**3) * 0.125 * phi_x_avg_1 / mu_sum_1) + beta1
        eps1 = np.nan_to_num(eps1, nan=0.0, posinf=0.0, neginf=0.0)
        
        rho_sum_2 = rho[idx] + rho[idx+1]
        mu_sum_2 = mu[idx] + mu[idx+1]
        H_sum_2 = H_eff[idx] + H_eff[idx+1]
        phi_x_avg_2 = 0.5 * (phi_x[idx] + phi_x[idx+1])
        
        beta2 = self.beta_ad(P, H, 1)
        eps2 = (rho_sum_2 * (H_sum_2**3) * 0.125 * phi_x_avg_2 / mu_sum_2) + beta2
        eps2 = np.nan_to_num(eps2, nan=0.0, posinf=0.0, neginf=0.0)
        
        return eps1, eps2

    # --- Integral Residual & Jacobian ---
    
    def calc_reynolds_residual(self, P_rey, H):
        idx = np.arange(2, self.N-1)
        H_eff = np.clip(H, 1e-12, 1e-2)
        
        # Reynolds
        eps1, eps2 = self.get_eps_beta(P_rey, H_eff)
        
        term_pois = (self.A_C / self.dx**2) * (
            P_rey[idx-1]*eps1 - P_rey[idx]*(eps1+eps2) + P_rey[idx+1]*eps2
        )
        
        rho = self.ro(P_rey)
        drho = self.droo(P_rey)
        _, phi_s = self.calc_flow_factors(H_eff)
        
        # Couette Term Discretization
        # Use Upwind 1st Order for Stability to recover film thickness.
        # Central Difference was causing collapse to 4nm.
        term_couette = (self.u1d / self.dx) * (
            rho[idx]*H_eff[idx]*phi_s[idx] - rho[idx-1]*H_eff[idx-1]*phi_s[idx-1]
        ) 
        
        term_squeeze = 0.0
        if self.is_transient and self.rho_old is not None:
             term_time = (rho[idx]*H_eff[idx] - self.rho_old[idx]*self.H_old[idx]) / self.dt
             term_squeeze = (self.R / self.Um_mag) * term_time
             
        f1 = self.gamma_h * np.minimum(P_rey[idx], 0)
        f4 = self.g1 * np.maximum(self.hmin_dim - H[idx], 0)**2
        
        F_rey = term_pois - term_couette - term_squeeze - f1 + f4
        
        # Scaling
        scale_rey = self.dx**2 / self.A_C 
        F_rey_scaled = F_rey * scale_rey
        
        return F_rey_scaled

    def system_func(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        p_limit = self.P_max / self.P0_ref
        P_rey = np.clip(P_rey, -p_limit, p_limit)
        p_limit = self.P_max / self.P0_ref
        P_rey = np.clip(P_rey, -p_limit, p_limit)
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H = np.clip(H, -1e-3, 1e-2)
        # FIX: Initialize boundaries to Rigid shape to avoid H=0 -> Pa=Max
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        # Calculate Asperity
        Pa, _ = self.calc_asperity(H, calc_deriv=True)
        
        P_tot = P_rey + Pa
        
        D_term = self.D_mat @ P_tot
        H_rigid = H0 + (self.X**2)/2
        H_elastic = H_rigid + D_term
        
        # Update H boundaries
        H[0] = H_elastic[0]
        H[1] = H_elastic[1]
        H[-1] = H_elastic[-1]
        
        # Calculate Reynolds Residual using helper
        F_rey_scaled = self.calc_reynolds_residual(P_rey, H)
        
        # Film Residual
        idx = np.arange(2, self.N-1)
        F_film = H[idx] - H_elastic[idx]
        
        # Load Balance
        # FIX: Normalize Load Residual to force relative accuracy
        # F = (W_target - Integral) / W_target
        if self.Wld != 0:
            F_load = (self.Wld - np.sum(P_tot * self.dx)) / self.Wld
        else:
            F_load = self.Wld - np.sum(P_tot * self.dx)
        
        return np.concatenate([F_rey_scaled, F_film, [F_load]])

    def calc_jacobian(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        N_vars = len(V)
        epsilon = 1e-7
        J = np.zeros((N_vars, N_vars))
        
        idx_inner = np.arange(2, self.N-1)
        
        # Calculate Pa derivatives
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        _, dPa_dH = self.calc_asperity(H, calc_deriv=True)
        dPa_dH_slice = dPa_dH[idx_inner] 
        
        # 1. Analytic Block for Film
        # dF/dP_rey = -D
        D_slice = self.D_mat[np.ix_(idx_inner, idx_inner)]
        J[n_inner:2*n_inner, 0:n_inner] = -D_slice
        
        # dF/dH = I - D * dPa/dH
        Mat_dPa = D_slice * dPa_dH_slice[np.newaxis, :] 
        
        J[n_inner:2*n_inner, n_inner:2*n_inner] = np.eye(n_inner) - Mat_dPa
        
        # dF/dH0 = -1
        J[n_inner:2*n_inner, -1] = -1.0
        # 3. Load Balance Row (Last Row)
        # F_load = (Wld - sum(P*dx)) / Wld = 1 - sum(P*dx)/Wld
        # dF/dP = -dx / Wld
        if self.Wld != 0:
            J[-1, 0:n_inner] = -self.dx / self.Wld
            J[-1, n_inner:2*n_inner] = -dPa_dH_slice * self.dx / self.Wld
        else:
             J[-1, 0:n_inner] = -self.dx
             J[-1, n_inner:2*n_inner] = -dPa_dH_slice * self.dx
             
        # dF/dH0 = 0 (Load depends only on Pressure)
        J[-1, -1] = 0.0
        
        # 3. Optimized FD Block for Reynolds (Sparse update)
        # Reconstruct full P and H
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        
        # Base Residual
        F0_rey = self.calc_reynolds_residual(P_rey, H)
        
        # Loop 1: Perturb P_inner (Cols 0 to n_inner-1)
        for j in range(n_inner):
            idx_global = j + 2
            old_val = P_rey[idx_global]
            P_rey[idx_global] += epsilon
            F_new_rey = self.calc_reynolds_residual(P_rey, H)
            J[:n_inner, j] = (F_new_rey - F0_rey) / epsilon
            P_rey[idx_global] = old_val
            
        # Loop 2: Perturb H_inner (Cols n_inner to 2*n_inner-1)
        for j in range(n_inner):
            idx_global = j + 2
            col = n_inner + j
            old_val = H[idx_global]
            H[idx_global] += epsilon
            F_new_rey = self.calc_reynolds_residual(P_rey, H)
            J[:n_inner, col] = (F_new_rey - F0_rey) / epsilon
            H[idx_global] = old_val
            
        # Loop 3: Perturb H0 (Last Col)
        H0_new = H0 + epsilon
        old_H0_val = H[0]; old_H1_val = H[1]; old_Hm1_val = H[-1]
        
        H[0] = H0_new + (self.X[0]**2)/2
        H[1] = H0_new + (self.X[1]**2)/2
        H[-1] = H0_new + (self.X[-1]**2)/2
        
        F_new_rey = self.calc_reynolds_residual(P_rey, H)
        J[:n_inner, -1] = (F_new_rey - F0_rey) / epsilon
        
        H[0] = old_H0_val; H[1] = old_H1_val; H[-1] = old_Hm1_val
            
        return J

    def update_history(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner]
        H0 = V[-1]
        
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        Pa = self.calc_asperity(H)
        P_tot = P_rey + Pa
        
        D_term = self.D_mat @ P_tot
        H_elastic = H0 + (self.X**2)/2 + D_term
        
        self.rho_old = self.ro(P_rey)
        self.H_old = H_elastic

    def get_full_state(self, V):
        n_inner = self.N - 3
        P_inner = V[:n_inner]
        H_inner = V[n_inner:2*n_inner] 
        H0 = V[-1]
        
        P_rey = np.zeros(self.N)
        P_rey[2:-1] = P_inner
        
        H = np.zeros(self.N)
        H[2:-1] = H_inner
        H[0] = H0 + (self.X[0]**2)/2
        H[1] = H0 + (self.X[1]**2)/2
        H[-1] = H0 + (self.X[-1]**2)/2
        
        Pa = self.calc_asperity(H)
        P_tot = P_rey + Pa
        
        D_term = self.D_mat @ P_tot
        H_elastic = H0 + (self.X**2)/2 + D_term
        
        return P_rey, Pa, H_elastic

    # Optimized solve_steady signature
    def solve_steady(self, load_target=None, steps=4):
        target_load_val = load_target if load_target is not None else self.W
        # Initial Guess (Hertzian)
        P_init = np.zeros(self.N)
        X_dim = self.X_dim * self.R
        contact = np.abs(X_dim) <= self.a_Hertz
        P_init[contact] = self.Pmh * np.sqrt(1 - (X_dim[contact]/self.a_Hertz)**2) / self.P0_ref
        
        H0_init = 0.0
        D_term = self.D_mat @ P_init
        H_guess = H0_init + (self.X**2)/2 + D_term
        
        n_inner = self.N - 3
        V = np.concatenate([P_init[2:-1], H_guess[2:-1], [H0_init]])
        
        # Load Ramp
        # If steps=1, do single target solve
        if steps == 1:
            loads = [target_load_val]
        else:
            current_load_val = target_load_val * 0.1
            loads = np.linspace(current_load_val, target_load_val, steps)
        
        for i, w_val in enumerate(loads):
             self.Wld = w_val / self.B / (self.R * self.P0_ref)
             
             # Thermal Loop
             # If gamma=0, this loop runs once.
             for t_iter in range(8):
                # Solve Reynolds with current T
                 V, success, res, _ = self.newton_solve(V, tol=1e-7, max_iter=10)
                 
                 if self.gamma_therm == 0:
                     break
                 
                 P_rey, Pa, H_elastic = self.get_full_state(V)
                 T_new, _, _, _ = self.calc_temperature_rise(P_rey, H_elastic, Pa)
                 max_T_change = np.max(np.abs(T_new - self.T_current))
                 self.T_current = 0.2 * T_new + 0.8 * self.T_current
                 
                 if max_T_change < 0.01: 
                     break

        # Final Polish 
        # Skip if steps=1/fast mode? No, polish is good.
        return V, res

    def build_initial_guess(self):
        P_init = np.zeros(self.N)
        X_dim = self.X_dim * self.R
        contact = np.abs(X_dim) <= self.a_Hertz
        P_init[contact] = self.Pmh * np.sqrt(1 - (X_dim[contact] / self.a_Hertz) ** 2) / self.P0_ref
        U_dim = self.mu00 * self.Um_mag / (self.E_prime * self.R)
        G_dim = self.alpha_input * self.E_prime
        W_dim = (self.W / self.B) / (self.E_prime * self.R)
        H_min_nd = 2.65 * (U_dim**0.7) * (G_dim**0.54) * (W_dim**-0.13)
        H0_init = H_min_nd
        D_term = self.D_mat @ P_init
        H_guess = H0_init + (self.X**2) / 2 + D_term
        n_inner = self.N - 3
        return np.concatenate([P_init[2:-1], H_guess[2:-1], [H0_init]])

    def newton_solve(self, V_guess, tol=1e-6, max_iter=20):
        V = V_guess.copy()
        current_res = np.linalg.norm(self.system_func(V))
        
        for k in range(max_iter):
            if not np.isfinite(current_res):
                return V, False, current_res, k
            if current_res < tol:
                return V, True, current_res, k
            
            J = self.calc_jacobian(V)
            
            try:
                dV = np.linalg.solve(J, -self.system_func(V))
            except np.linalg.LinAlgError:
                return V, False, current_res, k
            # Damping / Line Search
            alpha = 1.0
            found = False
            for _ in range(4): # Try 1.0, 0.5, 0.25, 0.125
                V_new = V + alpha * dV
                new_res = np.linalg.norm(self.system_func(V_new))
                
                if new_res < current_res:
                    V = V_new
                    current_res = new_res
                    found = True
                    break
                alpha *= 0.5
            
            if not found:
                # If damping fails, force small step (0.1) to unstuck
                # or just accept step if closer?
                # EHL often needs small steps.
                V = V + 0.1 * dV
                current_res = np.linalg.norm(self.system_func(V))
            
        success = current_res < tol
        return V, success, current_res, max_iter

    def solve_transient_step(self, V_start, tol=1e-7, max_iter=8, thermal_iters=2):
        V_current = V_start.copy()
        self.update_history(V_current)
        for _ in range(thermal_iters):
            V_new, success, res, _ = self.newton_solve(V_current, tol=tol, max_iter=max_iter)
            P_rey, Pa, H_elastic = self.get_full_state(V_new)
            T_new, Phi, Alpha, H_eff = self.calc_temperature_rise(P_rey, H_elastic, Pa)
            max_T_change = np.max(np.abs(T_new - self.T_current))
            self.T_current = 0.5 * T_new + 0.5 * self.T_current
            V_current = V_new
            if success and max_T_change < 0.1:
                break
        self.update_history(V_current)
        return V_current, res

    def run_cam_cycle(self):
        theta_deg = self.cam_data["theta_deg"]
        um_profile = self.cam_data["um"]
        vs_profile = self.cam_data["Vs"]
        R_profile = self.cam_data["R"]
        F_profile = self.cam_data["F"]
        dt_profile = self.cam_data["dt"]
        n_steps = len(theta_deg)
        um_abs_profile = np.abs(um_profile)
        um_low = np.percentile(um_abs_profile, 20)
        load_high = np.percentile(F_profile, 80)
        P_rey_nd_list = []
        Pa_nd_list = []
        H_list = []
        load_error = []
        V_current = None
        total_start = time.perf_counter()

        for i in range(n_steps):
            step_start = time.perf_counter()
            self.update_operating_state(um_profile[i], vs_profile[i], R_profile[i], F_profile[i])
            self.dt = dt_profile[i]
            um_abs = um_abs_profile[i]
            load_val = F_profile[i]
            if um_abs <= um_low or load_val >= load_high:
                tol = 1e-8
                max_iter = 14
                thermal_iters = 3
            else:
                tol = 1e-8
                max_iter = 9
                thermal_iters = 2

            if V_current is None:
                self.is_transient = True
                V_current = self.build_initial_guess()
                self.update_history(V_current)
                V_current, res = self.solve_transient_step(
                    V_current,
                    tol=tol,
                    max_iter=max_iter,
                    thermal_iters=thermal_iters,
                )
            else:
                V_current, res = self.solve_transient_step(
                    V_current,
                    tol=tol,
                    max_iter=max_iter,
                    thermal_iters=thermal_iters,
                )

            P_rey, Pa, H = self.get_full_state(V_current)
            if not np.isfinite(res):
                res = np.inf
            if res > 1e-7 or not (np.isfinite(P_rey).all() and np.isfinite(Pa).all() and np.isfinite(H).all()):
                for _ in range(3):
                    V_current = self.build_initial_guess()
                    self.update_history(V_current)
                    V_current, res = self.solve_transient_step(
                        V_current,
                        tol=1e-8,
                        max_iter=max_iter + 12,
                        thermal_iters=thermal_iters + 2,
                    )
                    P_rey, Pa, H = self.get_full_state(V_current)
                    if np.isfinite(res) and res <= 1e-7 and np.isfinite(P_rey).all() and np.isfinite(Pa).all() and np.isfinite(H).all():
                        break
            if self.Pmh > 0:
                P_rey_nd = (P_rey * self.P0_ref) / self.Pmh
                Pa_nd = (Pa * self.P0_ref) / self.Pmh
            else:
                P_rey_nd = P_rey
                Pa_nd = Pa
            P_rey_nd_list.append(P_rey_nd)
            Pa_nd_list.append(Pa_nd)
            H_list.append(H)
            step_load_error = abs(self.Wld - np.sum((P_rey + Pa) * self.dx)) / max(self.Wld, 1e-12)
            load_error.append(step_load_error)
            step_runtime = time.perf_counter() - step_start
            total_runtime = time.perf_counter() - total_start
            print(
                f"Step {i+1}/{n_steps} | "
                f"Load err={step_load_error:.4e} | "
                f"Res={res:.4e} | "
                f"Step time={step_runtime:.3f}s | "
                f"Total time={total_runtime:.1f}s"
            )

        X_plot = self.X_dim
        P_rey_nd_arr = np.array(P_rey_nd_list)
        Pa_nd_arr = np.array(Pa_nd_list)
        H_arr = np.array(H_list)

        fig, axes = plt.subplots(2, 2, figsize=(12, 8))
        axes[0, 0].plot(theta_deg, um_profile)
        axes[0, 0].set_ylabel("um (m/s)")
        axes[0, 1].plot(theta_deg, vs_profile)
        axes[0, 1].set_ylabel("Vs (m/s)")
        axes[1, 0].plot(theta_deg, R_profile)
        axes[1, 0].set_ylabel("R (m)")
        axes[1, 1].plot(theta_deg, F_profile)
        axes[1, 1].set_ylabel("F (N)")
        for ax in axes.flat:
            ax.set_xlabel("Cam angle (deg)")
            ax.grid(True)
        fig.tight_layout()
        fig.savefig("Graph_Cam_Kinematics.png")

        colors = plt.cm.viridis(np.linspace(0, 1, n_steps))
        plt.figure(figsize=(10, 6))
        for i in range(n_steps):
            plt.plot(X_plot, P_rey_nd_arr[i], color=colors[i], alpha=0.4, linewidth=0.7)
        plt.xlabel("X/R")
        plt.ylabel("P_rey / Pmh")
        plt.title("Non-dimensional Reynolds Pressure (Cam Cycle)")
        plt.grid(True)
        plt.savefig("Graph_Reynolds_Pressure_Cycle.png")

        plt.figure(figsize=(10, 6))
        for i in range(n_steps):
            plt.plot(X_plot, Pa_nd_arr[i], color=colors[i], alpha=0.4, linewidth=0.7)
        plt.xlabel("X/R")
        plt.ylabel("P_asp / Pmh")
        plt.title("Non-dimensional Asperity Pressure (Cam Cycle)")
        plt.grid(True)
        plt.savefig("Graph_Asperity_Pressure_Cycle.png")

        plt.figure(figsize=(10, 6))
        for i in range(n_steps):
            plt.plot(X_plot, H_arr[i], color=colors[i], alpha=0.4, linewidth=0.7)
        plt.xlabel("X/R")
        plt.ylabel("H/R")
        plt.title("Non-dimensional Film Thickness (Cam Cycle)")
        plt.grid(True)
        plt.savefig("Graph_Film_Thickness_Cycle.png")

    def solve(self):
        self.run_cam_cycle()

if __name__ == "__main__":
    solver = EHLSolver()
    solver.solve()
