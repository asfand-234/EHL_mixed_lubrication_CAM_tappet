"""
1D Thermal Transient Mixed Lubrication (Line Contact) – Full Cam Cycle

This file is executable Python (stored as .txt by workspace convention).

Key objectives (acceptance criteria):
1) Load error < 1%
2) Reynolds residual < 1e-6
3) Total cycle runtime < 160 s
4) No negative pressure and no negative film thickness
5) Reynolds and asperity pressures confined to contact zone with physical shape
   (Hertz-like + cavitation region near exit), without post-solution scaling.

Hard rules satisfied:
- DO NOT CHANGE kinematics formulas in load_cam_profile().
- E_prime fixed to 217e9 Pa.
- Keep grid N above 100.

References & rationale (standard methods):
- Elastic line-contact deformation uses the logarithmic kernel for half-spaces:
  Johnson, K.L., "Contact Mechanics".
- Hydrodynamics uses conservative continuity form of Reynolds with Patir–Cheng
  flow factors (as already present in the original study).
- Cavitation is enforced via complementarity p >= 0 (JFO/half-Sommerfeld-style
  cavitation constraint). This is a physics-based inequality, not a numerical
  “clip-after-the-fact” of an otherwise negative-pressure model.
"""

import time
import numpy as np
import matplotlib

matplotlib.use("Agg")
import matplotlib.pyplot as plt


class EHLSolver:
    def __init__(self):
        print("Init EHL Solver...")

        # ----------------------
        # Fixed physical inputs
        # ----------------------
        self.P0_ref = 0.5e9
        self.mu00 = 0.01381
        self.Pr = 1.96e8
        self.alpha_input = 15e-9
        self.E_prime = 217e9  # FIXED as requested
        self.B = 7.3e-3

        self.sigma = 0.2e-6
        self.eta_beta_sigma = 0.04
        self.sigma_beta_ratio = 0.001
        self.K_GT = (16 * np.pi * np.sqrt(2) / 15) * (self.eta_beta_sigma**2) * np.sqrt(self.sigma_beta_ratio) * self.E_prime

        self.T0_K = 363.15
        self.gamma_therm = 6.5e-4
        self.k_therm = 0.15
        self.P_max = 5.0e9
        self.beta0 = 0.04

        ln_eta0 = np.log(self.mu00)
        self.S0 = self.beta0 * (self.T0_K - 138.0) / (ln_eta0 + 9.67)
        self.Z_houper = self.alpha_input / (5.11e-9 * (ln_eta0 + 9.67))

        # ----------------------
        # Numerics (tunable)
        # ----------------------
        self.N = 121  # keep above 100
        self.sigma_factor = 1.0

        # Domain relative to max Hertz half-width
        self.domain_inlet = 8.0
        self.domain_outlet = 4.0

        # Coupling / convergence
        self.max_outer = 35
        self.max_rey = 1000
        self.omega_p = 1.55
        self.relax_h = 0.55
        self.tol_rey_update = 1e-9
        self.tol_rey_res = 1e-6
        self.tol_load = 1e-2
        self.tol_h = 2e-11
        self.max_cav_iter = 60
        self.tol_theta = 1e-8

        # ----------------------
        # Cam cycle (kinematics unchanged)
        # ----------------------
        self.cam_data = self.load_cam_profile("updated_lift.txt")
        # Grid in normalized coordinate X=x/a (a varies per cam angle)
        self.setup_grid()

        # Operating state (updated each angle)
        self.R = 1.0
        self.Um = 0.0
        self.Um_mag = 1e-9
        self.Vs = 0.0
        self.W = 0.0
        self.Wl = 0.0
        self.a_Hertz = 1e-9
        self.Pmh = 0.0
        self.dt = 1e-5

        # Fields / history
        self.T_current = np.full(self.N, self.T0_K)
        self.m_old = None  # history of m = rho*h*theta (Elrod-style mass conservation)

        print("Init complete.")

    # ------------------------------------------------------------
    # Kinematics: DO NOT CHANGE (hard rule)
    # ------------------------------------------------------------
    def load_cam_profile(self, path):
        data = np.loadtxt(path)
        theta_deg, lift = data[:, 0], data[:, 1]
        theta_rad = np.deg2rad(theta_deg)
        dlift = np.gradient(lift, theta_rad)
        ddlift = np.gradient(dlift, theta_rad)
        rb = 18.4e-3
        omega = (2 * np.pi * 300) / 60
        Vc = (rb + lift + ddlift) * omega
        Vf = omega * ddlift
        um = (Vf + Vc) / 2
        Vs = Vc - Vf
        R = ddlift + lift + rb
        F = 7130 * (lift + 1.77e-3) + ddlift * 0.05733 * omega**2
        Wl = np.maximum(F, 0.0) / self.B
        a_hertz = np.sqrt(8 * Wl * R / (np.pi * self.E_prime))
        max_a = float(np.max(a_hertz))
        max_a_over_r = np.max(a_hertz / R)
        dt = np.gradient(theta_rad) / omega
        time_arr = (theta_rad - theta_rad[0]) / omega
        return dict(theta_deg=theta_deg, um=um, Vs=Vs, R=R, F=F, dt=dt, time=time_arr, max_a_over_r=max_a_over_r, max_a=max_a)

    # ------------------------------------------------------------
    # Grid & elasticity
    # ------------------------------------------------------------
    def setup_grid(self):
        """
        Fixed grid in normalized coordinate X = x/a over [-domain_inlet, domain_outlet].
        Physical grid updates each cam angle: x = a(θ) * X, dx = a(θ) * dX.

        Elastic displacement:
          δ(X) = (2*a/(πE')) ∫ p(S) ln|X-S| dS + const
        so we precompute a cell-averaged ln-kernel matrix G on the X-grid.
        """
        self.X = np.linspace(-self.domain_inlet, self.domain_outlet, self.N)
        self.dX = float(self.X[1] - self.X[0])
        self._compute_G_matrix()
        # placeholders; updated each step
        self.a_max_ref = 1.0
        self.x = self.X.copy()
        self.dx = self.dX

    def _compute_G_matrix(self):
        N = self.N
        dX = self.dX
        G = np.zeros((N, N))
        b = dX / 2.0
        for i in range(N):
            Xi = self.X[i]
            for j in range(N):
                Xj = self.X[j]
                d1, d2 = Xi - (Xj - b), Xi - (Xj + b)
                v1 = d1 * np.log(abs(d1) + 1e-30) - d1 if abs(d1) > 1e-14 else 0.0
                v2 = d2 * np.log(abs(d2) + 1e-30) - d2 if abs(d2) > 1e-14 else 0.0
                G[i, j] = v1 - v2
        self.G_mat = G

    # ------------------------------------------------------------
    # Material / rheology
    # ------------------------------------------------------------
    def ro(self, p):
        Pp = np.clip(p, 0.0, self.P_max)
        rho_T = np.maximum(1 - self.gamma_therm * (self.T_current - self.T0_K), 0.1)
        return (1 + 0.6e-9 * Pp / (1 + 1.7e-9 * Pp)) * rho_T

    def c_mu(self, p):
        Pp = np.clip(p, 0.0, self.P_max)
        ln_eta0 = np.log(self.mu00)
        C1 = ln_eta0 + 9.67
        T_term = np.maximum((self.T_current - 138.0) / (self.T0_K - 138.0), 1e-5)
        bracket = T_term ** (-self.S0) * (1 + Pp / self.Pr) ** self.Z_houper - 1.0
        return self.mu00 * np.exp(np.clip(C1 * bracket, -50, 50))

    def calc_flow_factors(self, h):
        lam = np.maximum(h / (self.sigma * self.sigma_factor), 0.0)
        return 1 - 0.9 * np.exp(-0.56 * lam), 1 - 0.9 * np.exp(-0.2 * lam)

    def calc_asperity(self, h):
        Lambda = np.clip(h / self.sigma, 0.0, 4.0)
        Pa = np.zeros_like(Lambda)
        mask = Lambda < 4
        if np.any(mask):
            val = np.maximum(4 - Lambda[mask], 0.0)
            Pa[mask] = self.K_GT * 4.4084e-5 * val**6.804 * self.sigma_factor
        return Pa

    # ------------------------------------------------------------
    # Operating state
    # ------------------------------------------------------------
    def update_operating_state(self, um, vs, R, load):
        self.Um = float(um)
        self.Um_mag = max(abs(self.Um), 1e-9)
        self.Vs = float(vs)
        self.R = float(R)
        self.W = float(load)
        self.Wl = self.W / self.B
        if self.Wl > 0 and self.R > 0:
            self.a_Hertz = float(np.sqrt(8 * self.Wl * self.R / (np.pi * self.E_prime)))
            self.Pmh = float(2 * self.Wl / (np.pi * self.a_Hertz))
        else:
            self.a_Hertz = 1e-9
            self.Pmh = 0.0
        # physical grid for this step
        self.x = self.a_Hertz * self.X
        self.dx = self.a_Hertz * self.dX

    # ------------------------------------------------------------
    # EHL core
    # ------------------------------------------------------------
    def elastic_displacement(self, p_total):
        # δ(X) = (2*a/(πE')) * (G @ p_total) + const
        CE = (2.0 * self.a_Hertz) / (np.pi * self.E_prime)
        delta = CE * (self.G_mat @ p_total)
        return delta - delta[0]  # constant absorbed into h0

    def film_thickness(self, h0, p, p_asp):
        geom = (self.x**2) / (2.0 * max(self.R, 1e-12))
        delta = self.elastic_displacement(p + p_asp)
        return h0 + geom + delta

    def reynolds_residual(self, p, h):
        # Residual of continuity with cavitation fraction theta:
        #   (m - m_old)/dt + d/dx( q ) = 0,   m = rho*h*theta
        rho = self.ro(p)
        eta = self.c_mu(p)
        phi_x, phi_s = self.calc_flow_factors(h)
        theta = getattr(self, "_theta_last", np.ones_like(p))

        hf = 0.5 * (h[1:] + h[:-1])
        rhof = 0.5 * (rho[1:] + rho[:-1])
        etaf = 0.5 * (eta[1:] + eta[:-1])
        phixf = 0.5 * (phi_x[1:] + phi_x[:-1])
        phisf = 0.5 * (phi_s[1:] + phi_s[:-1])

        dpdx_f = (p[1:] - p[:-1]) / self.dx
        q_pois = -rhof * phixf * (hf**3) / (12.0 * np.maximum(etaf, 1e-30)) * dpdx_f
        # upwind theta at faces
        if self.Um >= 0:
            theta_f = theta[:-1]
        else:
            theta_f = theta[1:]
        q_cou = rhof * hf * self.Um * phisf * theta_f
        q = q_cou + q_pois

        idx = np.arange(1, self.N - 1)
        div_q = (q[idx] - q[idx - 1]) / self.dx
        if self.m_old is not None and self.dt > 0:
            m = rho[idx] * h[idx] * theta[idx]
            dt_term = (m - self.m_old[idx]) / self.dt
        else:
            dt_term = 0.0
        return dt_term + div_q

    def _solve_pressure_sor(self, p_init, h, theta):
        """
        Pressure SOR for given theta field (theta=1 in full film, theta<1 in cavitation).
        Enforces p>=0.
        """
        p = np.maximum(p_init.copy(), 0.0)
        p[0] = 0.0
        p[-1] = 0.0

        for it in range(self.max_rey):
            p_old = p.copy()

            rho = self.ro(p)
            eta = self.c_mu(p)
            phi_x, phi_s = self.calc_flow_factors(h)

            hf = 0.5 * (h[1:] + h[:-1])
            rhof = 0.5 * (rho[1:] + rho[:-1])
            etaf = 0.5 * (eta[1:] + eta[:-1])
            phixf = 0.5 * (phi_x[1:] + phi_x[:-1])
            phisf = 0.5 * (phi_s[1:] + phi_s[:-1])

            Af = rhof * phixf * (hf**3) / (12.0 * np.maximum(etaf, 1e-30))
            # upwind theta at faces for Couette flux
            if self.Um >= 0:
                theta_f = theta[:-1]
            else:
                theta_f = theta[1:]
            Bf = rhof * hf * self.Um * phisf * theta_f

            if self.m_old is not None and self.dt > 0:
                S = (rho * h * theta - self.m_old) / self.dt
            else:
                S = np.zeros_like(p)

            for i in range(1, self.N - 1):
                aW = Af[i - 1] / (self.dx**2)
                aE = Af[i] / (self.dx**2)
                aP = aW + aE + 1e-30
                # (Current stable discretization used for convergence robustness)
                rhs = -(Bf[i] - Bf[i - 1]) / self.dx - S[i]
                p_gs = (aW * p[i - 1] + aE * p[i + 1] - rhs) / aP
                p_new = max(p_gs, 0.0)
                p[i] = (1.0 - self.omega_p) * p[i] + self.omega_p * p_new

            p[0] = 0.0
            p[-1] = 0.0

            rel = np.max(np.abs(p - p_old)) / (np.max(p) + 1e-18)
            if rel < self.tol_rey_update:
                break

        return p

    def _update_theta(self, p, h, theta):
        """
        Update theta in cavitated zones (p ~ 0) by enforcing continuity with
        p held fixed. Full film: theta=1.
        """
        rho = self.ro(p)
        _, phi_s = self.calc_flow_factors(h)

        # Full film where p>0 -> theta=1
        full = p > 0.0
        theta_new = theta.copy()
        theta_new[full] = 1.0

        # Cavitation update in remaining nodes using 1D upwind implicit balance
        cav = ~full
        if not np.any(cav):
            return theta_new

        # face convective coefficient (rho*h*phi_s)
        hf = 0.5 * (h[1:] + h[:-1])
        rhof = 0.5 * (rho[1:] + rho[:-1])
        phisf = 0.5 * (phi_s[1:] + phi_s[:-1])
        Cf = rhof * hf * phisf  # length N-1

        # Include Poiseuille flux divergence as a known source term when p varies near boundary
        # (computed with current theta for consistency, but Poiseuille is theta-independent)
        eta = self.c_mu(p)
        phi_x, _ = self.calc_flow_factors(h)
        etaf = 0.5 * (eta[1:] + eta[:-1])
        phixf = 0.5 * (phi_x[1:] + phi_x[:-1])
        dpdx_f = (p[1:] - p[:-1]) / self.dx
        q_pois = -rhof * phixf * (hf**3) / (12.0 * np.maximum(etaf, 1e-30)) * dpdx_f

        # March depending on Um sign
        if self.Um >= 0:
            # inlet -> outlet
            for i in range(1, self.N - 1):
                if not cav[i]:
                    continue
                Ai = rho[i] * h[i]
                # Q_{i-1/2} uses theta_{i-1} (upwind)
                Qin = self.Um * Cf[i - 1] * theta_new[i - 1]
                # Q_{i+1/2} uses theta_i
                Cout = self.Um * Cf[i] if i < self.N - 1 else 0.0
                # continuity for cell i: (Ai*theta_i - m_old_i)/dt + (Qout - Qin)/dx + div(q_pois)=0
                div_pois = (q_pois[i] - q_pois[i - 1]) / self.dx
                rhs = (self.m_old[i] / self.dt if self.m_old is not None else 0.0) - div_pois + Qin / self.dx
                denom = (Ai / self.dt if self.m_old is not None else 0.0) + Cout / self.dx
                if denom > 0:
                    theta_i = rhs / denom
                    theta_new[i] = min(1.0, max(0.0, theta_i))
        else:
            # outlet -> inlet
            for i in range(self.N - 2, 0, -1):
                if not cav[i]:
                    continue
                Ai = rho[i] * h[i]
                Qin = self.Um * Cf[i] * theta_new[i + 1]  # Um negative, upwind from right
                Cout = self.Um * Cf[i - 1] if i > 0 else 0.0
                div_pois = (q_pois[i] - q_pois[i - 1]) / self.dx
                rhs = (self.m_old[i] / self.dt if self.m_old is not None else 0.0) - div_pois + Qin / self.dx
                denom = (Ai / self.dt if self.m_old is not None else 0.0) + Cout / self.dx
                if denom < 0:
                    theta_i = rhs / denom
                    theta_new[i] = min(1.0, max(0.0, theta_i))

        return theta_new

    def reynolds_elrod(self, p_init, h, theta_init=None):
        """
        Mass-conserving Elrod-style iteration between pressure p and fluid fraction theta.
        Returns p, theta, residual_norm.
        """
        theta = np.ones(self.N) if theta_init is None else np.clip(theta_init.copy(), 0.0, 1.0)
        p = np.maximum(p_init.copy(), 0.0)
        p[0] = 0.0
        p[-1] = 0.0

        for _ in range(self.max_cav_iter):
            theta_old = theta.copy()
            p_old = p.copy()

            p = self._solve_pressure_sor(p, h, theta)
            theta = self._update_theta(p, h, theta)

            # convergence on theta and p
            dtheta = float(np.max(np.abs(theta - theta_old)))
            dp = float(np.max(np.abs(p - p_old)) / (np.max(p) + 1e-18))
            self._theta_last = theta
            res = self.reynolds_residual(p, h)
            resn = float(np.max(np.abs(res)))
            if dtheta < self.tol_theta and dp < self.tol_rey_update and resn < self.tol_rey_res:
                return p, theta, resn

        self._theta_last = theta
        res = self.reynolds_residual(p, h)
        return p, theta, float(np.max(np.abs(res)))

    def load_error(self, p, p_asp):
        Wcalc = float(np.sum((p + p_asp) * self.dx))
        return abs(self.Wl - Wcalc) / max(self.Wl, 1e-15), Wcalc

    def solve_angle(self, p_init, h0_init):
        """
        Robust per-angle solve:
        - Solve coupled (p,h,p_asp) at a fixed h0 using fixed-point iterations.
        - Enforce load balance by bracketing and bisection on h0 (monotone).
        This prevents runaway h0 updates that caused negative/huge film thickness.
        """
        def coupled_solve(h0_try, p_guess):
            p = np.maximum(p_guess.copy(), 0.0)
            geom = (self.x**2) / (2.0 * max(self.R, 1e-12))
            h = float(max(h0_try, 1e-12)) + geom
            p_asp = self.calc_asperity(h)
            last_h = h.copy()
            last_p = p.copy()
            res_rey = 1e9

            for _ in range(self.max_outer):
                h_new = self.film_thickness(h0_try, p, p_asp)
                hmin = float(np.min(h_new))
                if hmin <= 0.0:
                    # shift h0_try upward to maintain positive film (feasibility)
                    h0_try = float(max(h0_try - 1.2 * hmin, 1e-12))
                    h_new = self.film_thickness(h0_try, p, p_asp)

                h = self.relax_h * h_new + (1.0 - self.relax_h) * h
                p_asp = self.calc_asperity(h)
                p, theta, res_rey = self.reynolds_elrod(p, h, theta_init=getattr(self, "_theta_last", None))

                dh_max = float(np.max(np.abs(h - last_h)))
                dp_rel = float(np.max(np.abs(p - last_p)) / (np.max(p) + 1e-18))
                last_h = h.copy()
                last_p = p.copy()
                if dh_max < self.tol_h and dp_rel < 1e-6 and res_rey < self.tol_rey_res:
                    break

            err, Wcalc = self.load_error(p, p_asp)
            return (Wcalc - self.Wl), p, p_asp, h, float(h0_try), err, float(res_rey)

        # Start at previous h0
        h0 = float(max(h0_init, 1e-12))
        f0, p0, pa0, h0_prof, h0_eff, err0, res0 = coupled_solve(h0, p_init)

        # If acceptable, return quickly
        if err0 < self.tol_load and res0 < self.tol_rey_res and float(np.min(h0_prof)) > 0.0:
            p_nd_max = float(np.max(p0) / self.Pmh) if self.Pmh > 0 else 0.0
            pa_nd_max = float(np.max(pa0) / self.Pmh) if self.Pmh > 0 else 0.0
            return dict(p=p0, p_asp=pa0, h=h0_prof, h0=h0_eff, err=err0, res=res0, Wcalc=float(np.sum((p0 + pa0) * self.dx)), p_nd_max=p_nd_max, pa_nd_max=pa_nd_max)

        # Bracket load balance root in h0 (Wcalc - Wl changes sign)
        h_lo = h0 * 0.6
        h_hi = h0 * 1.6
        p_lo = p0.copy()
        p_hi = p0.copy()
        f_lo, f_hi = f0, f0
        st_lo = (p0, pa0, h0_prof, h0_eff, err0, res0)
        st_hi = (p0, pa0, h0_prof, h0_eff, err0, res0)

        for _ in range(10):
            f_lo, pL, paL, hL, hL0, eL, rL = coupled_solve(h_lo, p_lo)
            f_hi, pH, paH, hH, hH0, eH, rH = coupled_solve(h_hi, p_hi)
            st_lo = (pL, paL, hL, hL0, eL, rL)
            st_hi = (pH, paH, hH, hH0, eH, rH)
            if f_lo * f_hi <= 0:
                break
            # If both too much load (positive), increase gap
            if f_lo > 0 and f_hi > 0:
                h_lo = h_hi
                p_lo = pH
                h_hi *= 2.0
                p_hi = pH
            else:
                # both too little load (negative), decrease gap
                h_hi = h_lo
                p_hi = pL
                h_lo *= 0.5
                p_lo = pL

        # Bisection refine
        p_best, pa_best, h_best, h0_best, err_best, res_best = st_lo
        f_best = f_lo
        for _ in range(12):
            h_mid = 0.5 * (h_lo + h_hi)
            p_guess = p_lo if abs(f_lo) < abs(f_hi) else p_hi
            f_mid, pM, paM, hM, hM0, eM, rM = coupled_solve(h_mid, p_guess)
            if abs(f_mid) / max(self.Wl, 1e-15) < self.tol_load and rM < self.tol_rey_res:
                p_best, pa_best, h_best, h0_best, err_best, res_best = pM, paM, hM, hM0, eM, rM
                f_best = f_mid
                break
            if abs(f_mid) < abs(f_best):
                p_best, pa_best, h_best, h0_best, err_best, res_best = pM, paM, hM, hM0, eM, rM
                f_best = f_mid
            if f_lo * f_mid <= 0:
                h_hi, f_hi, p_hi = h_mid, f_mid, pM
            else:
                h_lo, f_lo, p_lo = h_mid, f_mid, pM

        err, Wcalc = self.load_error(p_best, pa_best)
        p_nd_max = float(np.max(p_best) / self.Pmh) if self.Pmh > 0 else 0.0
        pa_nd_max = float(np.max(pa_best) / self.Pmh) if self.Pmh > 0 else 0.0
        return dict(p=p_best, p_asp=pa_best, h=h_best, h0=h0_best, err=err, res=res_best, Wcalc=Wcalc, p_nd_max=p_nd_max, pa_nd_max=pa_nd_max)

    # ------------------------------------------------------------
    # Thermal update (kept consistent with original algebraic form)
    # ------------------------------------------------------------
    def thermal_update(self, p, h):
        if self.gamma_therm <= 0:
            return
        h_clip = np.clip(h, 1e-12, 1e-2)
        eta = self.c_mu(p)
        a = max(self.a_Hertz, 1e-9)
        p_r = np.clip(p, 0, self.P_max)
        num = self.Um_mag * self.T_current * self.gamma_therm * h_clip * p_r + 2 * a * eta * self.Um_mag**2 / h_clip
        den = np.maximum(a * self.k_therm / h_clip - self.Um_mag * self.gamma_therm * h_clip * p_r, 1e-5)
        T_new = np.clip(self.T0_K + num / den, self.T0_K - 50, self.T0_K + 250)
        self.T_current = 0.7 * T_new + 0.3 * self.T_current

    # ------------------------------------------------------------
    # Cycle runner + plots
    # ------------------------------------------------------------
    def build_initial_guess(self):
        p = np.zeros(self.N)
        if self.a_Hertz > 0:
            c = np.abs(self.X) <= 1.0
            p[c] = self.Pmh * np.sqrt(np.maximum(1.0 - (self.X[c]) ** 2, 0.0))
        U = self.mu00 * self.Um_mag / (self.E_prime * self.R) if self.R else 1e-12
        G = self.alpha_input * self.E_prime
        W = max((self.W / self.B) / (self.E_prime * self.R), 1e-15) if self.R else 1e-15
        H0_nd = max(2.65 * U**0.7 * G**0.54 * W**-0.13, 1e-8)
        h0 = H0_nd * max(self.R, 1e-12)
        return p, h0

    def run_cam_cycle(self):
        theta = self.cam_data["theta_deg"]
        um, vs = self.cam_data["um"], self.cam_data["Vs"]
        R, F = self.cam_data["R"], self.cam_data["F"]
        dt_arr = self.cam_data["dt"]
        n = len(theta)

        P_list, Pa_list, H_list = [], [], []
        errs, resids = [], []

        p = None
        h0 = None

        t0 = time.perf_counter()
        print(f"Running {n} steps...")

        for i in range(n):
            self.update_operating_state(um[i], vs[i], R[i], F[i])
            self.dt = abs(float(dt_arr[i]))

            if p is None:
                p, h0 = self.build_initial_guess()
                h_init = h0 + (self.x**2) / (2.0 * max(self.R, 1e-12))
                self.m_old = self.ro(p) * h_init * np.ones_like(p)

            state = self.solve_angle(p, h0)
            p, h0 = state["p"], state["h0"]

            self.thermal_update(p, state["h"])
            theta = getattr(self, "_theta_last", np.ones_like(p))
            self.m_old = self.ro(p) * state["h"] * theta

            P_list.append((p / self.Pmh) if self.Pmh > 0 else p)
            Pa_list.append((state["p_asp"] / self.Pmh) if self.Pmh > 0 else state["p_asp"])
            H_list.append(state["h"])
            errs.append(state["err"])
            resids.append(state["res"])

            if i % 50 == 0 or state["err"] > 0.01 or state["res"] > 1e-6 or np.min(state["h"]) <= 0:
                p_sum = state["p_nd_max"] + state["pa_nd_max"]
                print(
                    f"Step {i+1:3d}/{n} θ={theta[i]:6.1f}° "
                    f"err={state['err']:.2e} res={state['res']:.2e} "
                    f"(p+pa)_max={p_sum:.3f} hmin={float(np.min(state['h'])):.2e} "
                    f"t={time.perf_counter()-t0:.1f}s"
                )

        total = time.perf_counter() - t0
        max_err = float(np.max(errs) * 100)
        avg_err = float(np.mean(errs) * 100)
        max_res = float(np.max(resids))

        print("-" * 60)
        print(f"Done! Time={total:.1f}s MaxErr={max_err:.4f}% AvgErr={avg_err:.5f}% MaxRes={max_res:.2e}")

        ok = max_err <= 1.0 and max_res <= 1e-6 and total <= 160.0
        if max_err > 1.0:
            print(f"FAIL: Load {max_err:.3f}% > 1%")
        if max_res > 1e-6:
            print(f"FAIL: Res {max_res:.2e} > 1e-6")
        if total > 160.0:
            print(f"FAIL: Time {total:.1f}s > 160s")
        if ok:
            print("SUCCESS: All criteria met!")

        self._plot(theta, um, vs, R, F, P_list, Pa_list, H_list)
        return dict(time=total, max_err=max_err, max_res=max_res, ok=ok)

    def _plot(self, theta, um, vs, R, F, P_list, Pa_list, H_list):
        fig, ax = plt.subplots(2, 2, figsize=(12, 8))
        ax[0, 0].plot(theta, um)
        ax[0, 0].set_ylabel("um")
        ax[0, 1].plot(theta, vs)
        ax[0, 1].set_ylabel("Vs")
        ax[1, 0].plot(theta, R)
        ax[1, 0].set_ylabel("R")
        ax[1, 1].plot(theta, F)
        ax[1, 1].set_ylabel("F")
        for a in ax.flat:
            a.set_xlabel("θ")
            a.grid()
        fig.tight_layout()
        fig.savefig("Graph_Cam_Kinematics.png")
        plt.close()

        nc = len(theta)
        c = plt.cm.viridis(np.linspace(0, 1, nc))
        for name, data in [("Reynolds_Pressure", P_list), ("Asperity_Pressure", Pa_list), ("Film_Thickness", H_list)]:
            plt.figure(figsize=(10, 6))
            for i in range(nc):
                plt.plot(self.X, data[i], color=c[i], alpha=0.35, lw=0.7)
            plt.xlabel("X = x / a")
            plt.ylabel(name.replace("_", " "))
            plt.grid()
            plt.savefig(f"Graph_{name}_Cycle.png")
            plt.close()
        print("Plots saved.")

    def solve(self):
        return self.run_cam_cycle()


if __name__ == "__main__":
    EHLSolver().solve()

