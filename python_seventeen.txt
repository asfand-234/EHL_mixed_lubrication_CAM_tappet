# ============================================================
# CAM–SHIM (Bucket Tappet) — 1D Mixed Lubrication line contact)
# ============================================================

DATA_DIR = "/content/cam"   # <--- put your folder path here
CAM_FILE = "updated_lift.txt"

import os, numpy as np, pandas as pd
import matplotlib.pyplot as plt
from math import pi, ceil
from scipy.signal import savgol_filter
plt.rcParams.update({"figure.dpi": 120})

# =======================
# USER: set test temperature (°C) 
# =======================
TEMP_C = 90  # <-- set to 60, 90, or 110 before running
def _load_cam(data_dir, fname):
    path = os.path.join(data_dir, fname)
    _cam = pd.read_csv(
        path, sep=r"\s+", engine="python", comment="#", header=None,
        names=["angle_deg", "lift_m"], usecols=[0, 1]
    )
    _cam["angle_deg"] = pd.to_numeric(_cam["angle_deg"], errors="raise")
    _cam["lift_m"]    = pd.to_numeric(_cam["lift_m"],    errors="raise")
    return _cam.sort_values("angle_deg").reset_index(drop=True)

CAM = _load_cam(DATA_DIR, CAM_FILE)
th_deg = CAM["angle_deg"].to_numpy(dtype=float)
th     = np.deg2rad(th_deg)
lift   = CAM["lift_m"].to_numpy(dtype=float)
TH_DEG = th_deg.copy()
lift_s = lift.copy()
dlift_s  = np.gradient(lift, th)           # dL/dθ
d2lift_s = np.gradient(dlift_s, th)
# ============================================================
# Materials / geometry / fluid (Fixed)
# ============================================================
rb       = 18.5e-3      # base circle radius [m]
k_spring = 7130.0       # spring rate [N/m]
delta    = 1.77e-3      # preload [m]
Meq      = 0.05733      # equivalent mass [kg]
L        = 7.2e-3       # out-of-plane length [m]
E_star   = 217e9        # [Pa]

# ============================================================
# Temperature-dependent parameter tables
# ============================================================
ETA0_TABLE     = {60: 0.04096, 90: 0.01381, 110: 0.008155}    # Pa·s
ALPHA0_TABLE   = {60: 20e-9,   90: 13e-9,    110: 10e-9}      # Pa^-1
RHO0_TABLE     = {60: 887.0,   90: 858.44,   110: 840.0}      # kg/m^3
MU_B_TABLE     = {60: 0.13,    90: 0.12,     110: 0.11}
GAMMA_LIM_TABLE= {60: 0.08,    90: 0.07,     110: 0.06}       # 1/Pa
LAM_C_TABLE    = {60: 7e-6,    90: 3.5e-6,   110: 2.0e-6}
N_C_TABLE      = {60: 0.85,    90: 0.65,     110: 0.52}
PHI_IN_TABLE   = {60: 0.5,     90: 0.60,     110: 0.7}
ETA_INF_TABLE  = {60: 0.010,   90: 0.006,    110: 0.004}

BETA0_CONST    = 0.68
P0_HOUPERT     = 1.98e8
C_ROELANDS     = 5.1e-9
T_SHIFT        = 138.0

K_THERM_TABLE  = {60: 0.14, 90: 0.14, 110: 0.14}
GAMMA_TH_TABLE = {60: 6.5e-4, 90: 6.5e-4, 110: 6.5e-4}

if TEMP_C not in (60, 90, 110):
    raise ValueError("TEMP_C must be one of {60, 90, 110}.")

eta0      = ETA0_TABLE[TEMP_C]
alpha0    = ALPHA0_TABLE[TEMP_C]
rho0      = RHO0_TABLE[TEMP_C]
mu_b      = MU_B_TABLE[TEMP_C]
gamma_lim = GAMMA_LIM_TABLE[TEMP_C]
lam_c     = LAM_C_TABLE[TEMP_C]
n_c       = N_C_TABLE[TEMP_C]
PHI_IN    = PHI_IN_TABLE[TEMP_C]
eta_inf   = ETA_INF_TABLE[TEMP_C]
k_lub     = K_THERM_TABLE[TEMP_C]
gamma_th  = GAMMA_TH_TABLE[TEMP_C]

# ============================================================
# Textured-only flash temperature & traction (calibration params; guesses)
# ============================================================
F0_COVERAGE_TABLE   = {60: 0.9, 90: 0.92, 110: 0.92}
NF_COVERAGE_TABLE   = {60: 1.0,  90: 2.0,  110: 2.0}
CHI_TEX_TABLE       = {60: 0.55, 90: 0.45, 110: 0.40}
BETA_EDGE_TABLE     = {60: 1.10, 90: 1.10, 110: 1.10}
K_EFF_TABLE         = {60: 60.0, 90: 45.0, 110: 45.0}
BETA_ETA_FLASH_TABLE= {60: 0.018, 90: 0.020, 110: 0.022}
C_LSS_TEX_TABLE     = {60: 0.03,  90: 0.07,  110: 0.06}
M_LSS_TEX           = 1.0
KAPPA_SRR_TABLE     = {60: 0.10, 90: 0.30, 110: 0.30}
F0_COVERAGE = F0_COVERAGE_TABLE[TEMP_C]
NFCOV       = NF_COVERAGE_TABLE[TEMP_C]
CHI_TEX     = CHI_TEX_TABLE[TEMP_C]
BETA_EDGE   = BETA_EDGE_TABLE[TEMP_C]
K_EFF       = K_EFF_TABLE[TEMP_C]
BETA_ETA_F  = BETA_ETA_FLASH_TABLE[TEMP_C]
C_LSS_TEX   = C_LSS_TEX_TABLE[TEMP_C]
KAPPA_SRR   = KAPPA_SRR_TABLE[TEMP_C]
MASK_THR_MULT = 4.0

# ============================================================
# Greenwood–Tripp constants 
# ============================================================
sigma_combined = 0.24e-6
beta_a         = sigma_combined/0.001
eta_R          = (0.053/(sigma_combined*beta_a))

# GT F_{3/2} lookup (pressure/load)
_gt_w = np.linspace(0.0, 8.0, 400)
_gt_w_pow = _gt_w**1.5
_gt_norm = np.sqrt(2.0*np.pi)
_lam_grid = np.linspace(0.0, 6.0, 360)
_kern = _gt_w_pow[None, :] * np.exp(-0.5 * (_lam_grid[:, None] + _gt_w) ** 2)
_F32_lookup = np.trapezoid(_kern, _gt_w, axis=1) / _gt_norm
_F32_lookup[-1] = 0.0

# ============================================================
# Houpert viscosity + DH density + ΔT model
# ============================================================
def _houpert_params(eta0_local, T0_c, alpha0_local, beta0_local=BETA0_CONST):
    lneta0_plus = (np.log(max(eta0_local, 1e-16)) + 9.67)
    Z  = alpha0_local / (C_ROELANDS * lneta0_plus + 1e-30)
    S0 = beta0_local * (T0_c - T_SHIFT) / (lneta0_plus + 1e-30)
    return Z, S0, lneta0_plus

def _alpha_star(p, T_c, eta0_local, T0_c, Z, S0, lneta0_plus):
    p_eff = np.maximum(p, 0.0)
    temp_ratio = ((np.asarray(T_c, float) - T_SHIFT) /
                  (T0_c - T_SHIFT + 1e-30))
    temp_factor = np.power(np.maximum(temp_ratio, 1e-12), -S0)
    press_factor = np.power(1.0 + p_eff / P0_HOUPERT, Z)
    numer = lneta0_plus * (temp_factor * press_factor - 1.0)
    return numer / (p_eff + 1e-30)

def deltaT_karthikeyan(u_av, h, p, a, eta_abs, k_l, gamma_c, T_c):
    h_eff = np.maximum(h, 1e-12)
    a_eff = np.maximum(a, 1e-12)
    u_abs = np.abs(u_av)
    num = u_abs * T_c * gamma_c * h_eff * np.maximum(p, 0.0) + 2.0 * a_eff * (np.maximum(eta_abs, 1e-7)**2) / h_eff
    den = a_eff * k_l / h_eff - u_abs * gamma_c * h_eff * np.maximum(p, 0.0)
    den = np.where(np.abs(den) < 1e-9, np.sign(den)*1e-9, den)
    dT = num / den
    return np.clip(dT, -40.0, 180.0)

def eta_houpert(p, T0_c, Ve_local, h_local, a_local):
    Z, S0, lneta0_plus = _houpert_params(eta0, T0_c, alpha0, BETA0_CONST)
    # First pass at T0_c
    alpha_s = _alpha_star(p, T0_c, eta0, T0_c, Z, S0, lneta0_plus)
    eta_init = np.maximum(eta0 * np.exp(np.clip(alpha_s*np.maximum(p,0.0), -50.0, 50.0)), 1e-7)
    # Use ABSOLUTE viscosity (Pa·s) in ΔT model
    dT = deltaT_karthikeyan(Ve_local, h_local, p, a_local, eta_init, k_lub, gamma_th, T0_c)
    T_upd = T0_c + dT
    # Second pass at updated temperature
    alpha_s2 = _alpha_star(p, T_upd, eta0, T0_c, Z, S0, lneta0_plus)
    eta_new = np.maximum(eta0 * np.exp(np.clip(alpha_s2*np.maximum(p,0.0), -50.0, 50.0)), 1e-7)
    return eta_new, dT

def rho_dowson_higginson(p, dT):
    p_eff = np.maximum(p, 0.0)
    frac = (1.0 + 0.6e-9 * p_eff) / (1.0 + 1.7e-9 * p_eff)
    therm = (1.0 - gamma_th * dT)
    return np.maximum(rho0 * frac * therm, 1.0)

def drho_dp_numeric(p, dT, Ve_local, h_local, a_local):
    dp = 1.0e3
    p_lo = np.maximum(p - dp, 0.0)
    p_hi = p + dp
    eta_lo, dT_lo = eta_houpert(p_lo, TEMP_C, Ve_local, h_local, a_local)
    eta_hi, dT_hi = eta_houpert(p_hi, TEMP_C, Ve_local, h_local, a_local)
    rho_lo = rho_dowson_higginson(p_lo, dT_lo)
    rho_hi = rho_dowson_higginson(p_hi, dT_hi)
    return (rho_hi - rho_lo) / (2.0*dp + 1e-30)

# ============================================================
# Shear-thinning (Carreau)
# ============================================================
def eta_carreau(etaN,h,gdot):
    h_eff = np.maximum(h,1e-12)
    gdot_eff = np.maximum(gdot, 1e-6)
    return np.maximum(eta_inf + (etaN-eta_inf)*(1.0 + (lam_c*gdot_eff)**2.0)**((n_c-1.0)/2.0), 1e-7)

# ============================================================
# Asperity pressure (Greenwood–Tripp)
# ============================================================
def asperity_pressure_greenwood_tripp(h):
    lam = np.maximum(np.asarray(h, float)/(sigma_combined + 1e-18), 0.0)
    lam_clipped = np.clip(lam, _lam_grid[0], _lam_grid[-1])
    F32 = np.interp(lam_clipped, _lam_grid, _F32_lookup)
    pref = (4.739075) * E_star * np.sqrt(sigma_combined/beta_a) * (beta_a *eta_R * sigma_combined)**2
    return (pref * F32).reshape(lam.shape)

# ============================================================
# Film seed (Hamrock–Dowson, line-contact 
# ============================================================
def central_film_thickness(R, W, Ve):
    R = float(np.clip(R, 1e-7, None))
    W = float(np.clip(W, 0.0, None))
    U = (eta0 * np.abs(Ve))/(E_star * R + 1e-30)
    G = alpha0 * E_star
    W_star = W / (E_star * L * R + 1e-30)
    hc = 3.06 * (U**0.69) * (G**0.56) * (W_star**-0.1) * R
    return float(np.clip(hc, 5e-9, 600e-9))


# ============================================================
# KINEMATICS (lift smoothing, curvature, speeds, load)
# ============================================================
def kin_arrays(rpm):
    R = np.maximum(rb + lift + d2lift_s, 1e-7)
    w = 2.0*np.pi*float(rpm)/60.0
    Vf = d2lift_s  * w
    Vc = (rb + lift + d2lift_s ) * w
    Ve = 0.5 * (Vc + Vf)
    Vs = Vc - Vf
    W = k_spring * (lift + delta) + Meq * (w**2) * d2lift_s 
    return R, Ve, Vs, W, w

# ============================================================
# Hertz line-contact — ***FIXED*** half-width formula
# ============================================================
def a_hertz(W,R):
    return np.sqrt( np.maximum(4.0*np.maximum(W,1e-9)*np.maximum(R,1e-12),0.0)/(np.pi*E_star*L + 1e-30) )
def ph_hertz(W,a):
    return 2.0*np.maximum(W,0.0)/(np.pi*np.maximum(a,1e-12)*L + 1e-30)
# ============================================================
# Elastic deflection (plane strain log-kernel) 
# ============================================================
def elastic_deflection(x, p):
    x = np.asarray(x, float); p = np.asarray(p, float)
    N  = len(x); dx = x[1]-x[0]; eps = 0.9*dx
    u = np.zeros_like(x)
    for i in range(N):
        u[i] = np.sum(p * np.log(np.sqrt((x[i]-x)**2 + eps*eps))) * dx
    u *= (2.0/(np.pi*E_star))
    u -= np.mean(u)
    return u

# ============================================================
# Rusanov advection (for ∂x(ρhU))
# ============================================================
def rusanov_div_bc(u, q, dx, q_in_left, q_in_right):
    N=len(q)
    qL = np.empty(N+1); qR = np.empty(N+1)
    qL[1:] = q; qR[:-1] = q
    qL[0] = q_in_left; qR[0] = q[0]
    qL[-1] = q[-1];     qR[-1] = q_in_right
    F = 0.5*(u*(qL+qR)) - 0.5*np.abs(u)*(qR - qL)
    return (F[1:] - F[:-1])/(dx + 1e-30)

# ============================================================
# TEXTURE MODEL
# ============================================================
w_texture = 35e-6       # [m] 
g_val     = 1e-9        # [m]
x_start   = 0.0
X_in, X_out = -4.5, 3.0

D_TEXTURE = {"5%": 700e-6, "8%": 437.5e-6, "10%": 350e-6}
A_TEXTURE_CONST = 5e-6     
TEXTURE_ZONE_MASK = np.ones_like(TH_DEG, dtype=bool)

def integrate_shift(Vs, w):
    dtheta = np.gradient(th)
    integrand = Vs/(w + 1e-30)
    shift = np.zeros_like(integrand)
    shift[1:] = np.cumsum(0.5*(integrand[1:] + integrand[:-1])*dtheta[1:])
    return shift

def htex_profile(x, a_theta, atex_theta, shift_theta, d_texture):
    if atex_theta <= 0.0 or a_theta <= 0.0: return np.zeros_like(x)
    u = ((x - x_start - shift_theta + d_texture/2.0) % d_texture) - d_texture/2.0
    expo = (np.log(g_val/atex_theta) * (u**2)) / (w_texture**2 + 1e-30)
    h = atex_theta*np.exp(expo)
    return np.where((x>=-a_theta)&(x<=a_theta), h, 0.0)

# ============================================================
# Flow-factor placeholders (Patir–Cheng); set to 1/0 for now
# ============================================================
def phi_x_func(h, sigma=sigma_combined):
    return np.ones_like(h)
def phi_s_func(h, sigma=sigma_combined):
    return np.zeros_like(h)

# ============================================================
# Helpers for textured-only flash model (mask, coverage, kernel)
# ============================================================
def _texture_mask_and_coverage(x, a_theta, atex_theta, shift_theta, d_texture, htex, mask_thr_mult=MASK_THR_MULT):
    if atex_theta <= 0.0 or a_theta <= 0.0:
        return np.zeros_like(x, dtype=bool), 0.0
    inside = (x >= -a_theta) & (x <= a_theta)
    mask_tex = (htex > (mask_thr_mult * g_val)) & inside
    denom = max(np.count_nonzero(inside), 1)
    f_cov = float(np.count_nonzero(mask_tex)) / float(denom)
    return mask_tex, f_cov

def _flash_line_kernel(qpp, a):
    return qpp * np.maximum(a, 1e-12)

# ============================================================
# CORE SOLVER (per cam angle):  Reynolds equation solver 
# ============================================================
def solve_theta(R, Ve, Vs, W, dt, angle_deg, rpm,
                atex_theta, shift_theta, d_texture,
                Nx=171, iters=80, substep_cap=6, relax_p=0.75, relax_h=0.55,
                M_core=451, observe=True):

    # Geometry
    R = float(max(R, 1e-12))
    W = float(max(W, 1e-6))   # numerical floor only; no artificial 1 N bias

    a  = max(a_hertz(W, R), 1e-6)
    ph = max(ph_hertz(W, a), 1e3)

    h_floor = 1.0e-9

    # Extended film grid (pressure will be embedded from core)
    xL, xR = X_in*a, X_out*a
    x  = np.linspace(xL, xR, Nx)
    dx = x[1] - x[0]
    # Refine x-grid only when texture is on (to resolve microfeatures in D/RHS)
    if atex_theta > 0.0 and Nx < 401:
        Nx_ref = 401
        x  = np.linspace(xL, xR, Nx_ref)
        dx = x[1] - x[0]

    # Core ND grid
    S_WIN = 1.2
    s  = np.linspace(-S_WIN, S_WIN, int(M_core))
    xs = a * s
    dS = s[1] - s[0]

    # Base seed for central film (then texture + elastic) and initial nominal shape
    h0 = central_film_thickness(R, W, Ve)

    # Texture contribution
    htex = htex_profile(x, a, atex_theta, shift_theta, d_texture)

    # Initial film guess (nominal parabolic + texture)
    h_shift = 0.0
    h  = np.maximum(h0 + h_shift + x**2/(2*R) + htex, h_floor)

    # Placeholders for previous nominal film to approximate squeeze
    h_nom_prev = h.copy()

    # Initial ND pressure core (Hertz-like seed)
    P_core = np.sqrt(np.maximum(1.0 - s**2, 0.0))

    # Helper to embed dimensional p(x) from core ND P(s)
    def embed_p(P_core_vec):
        p_full = np.zeros_like(x)
        inside = (x >= -S_WIN*a) & (x <= S_WIN*a)
        if inside.any():
            P_vals = np.interp(x[inside], xs, np.maximum(P_core_vec, 0.0))
            p_full[inside] = P_vals * ph
        return p_full

    # Smoother weights
    K0, K1 = 0.92, 0.025

    # Substepping for modest squeeze approximation & stability
    u1_local = np.abs(Ve)
    cfl  = np.abs(u1_local)*dt/(dx + 1e-30)
    substeps = int(min(max(2, np.ceil(cfl/0.35)), substep_cap))
    dts  = dt / max(substeps, 1)

    # previous dimensional pressure for dp/dt in compressible squeeze
    p_prev = embed_p(P_core).copy()

    for _sub in range(substeps):
        # Interpolate fields to core to get the current dimensional pressure
        p_embed = embed_p(P_core)

        # Include elastic deflection in the film used for the squeeze derivative
        defl_sub = elastic_deflection(x, p_embed)

        # Construct film for squeeze FD-in-time USING elastic deflection
        h_nom = np.maximum(h0 + x**2/(2*R) + defl_sub + htex, 5e-9)
        dhdt  = (h_nom - h_nom_prev)/max(dts, 1e-12)
        h_nom_prev = h_nom.copy()

        # --- constitutive fields ---
        eta_dim, dT_field = eta_houpert(p_embed, TEMP_C, Ve, h_nom, a)
        rho_dim = rho_dowson_higginson(p_embed, dT_field)
        drdp    = drho_dp_numeric(p_embed, dT_field, Ve, h_nom, a)
        phi_x = phi_x_func(h_nom)

        # --- mobility D(s) 
        dpdx     = np.gradient(p_embed, x)
        gdot_p   = np.abs(0.5 * np.maximum(h_nom,1e-12) * np.abs(dpdx) / (eta_dim + 1e-30))
        gdot_eff = np.sqrt( (np.maximum(np.abs(Vs),1e-6)/np.maximum(h_nom,1e-12))**2 + gdot_p**2 )
        eta_eff_Re = eta_carreau(eta_dim, h_nom, gdot_eff)
        D_full = (phi_x * (h_nom**3) * rho_dim*ph ) / (12.0 * eta_eff_Re*(a**2)  + 1e-30)

        # --- RHS in s-form: 
        q = rho_dim * np.maximum(h_nom, 1e-12)
        u = Ve

# Build nominal seed on both ends for sign-aware inflow
        h_nom_seed = np.maximum(h0 + x**2/(2*R) + htex, 5e-9)
        h_left, h_right = h_nom_seed[0], h_nom_seed[-1]

        if u >= 0.0:
    # Inflow from left, outflow to right
           q_in_left  = PHI_IN * rho0 * h_left
           q_in_right = q[-1]  # outflow extrapolation
        else:
    # Inflow from right, outflow to left
           q_in_left  = q[0]   # outflow extrapolation
           q_in_right = PHI_IN * rho0 * h_right

        div_adv = rusanov_div_bc(u, q, dx, q_in_left, q_in_right)
             
        term_adv   = div_adv                                          

        dpdt_embed   = (p_embed - p_prev) / max(dts, 1e-12)
        term_squeeze = (rho_dim * dhdt + h_nom * drdp * dpdt_embed)    
        RHS_full = term_adv + term_squeeze

        # Map to core grid
        D_core   = np.interp(xs, x, D_full)
        RHS_core = np.interp(xs, x, RHS_full)

        # Assemble tridiagonal for ND P on s-grid with cavitation handling
        M = len(xs)
        A = np.zeros(M); B = np.zeros(M); C = np.zeros(M); RHS = np.zeros(M)
        invdS2 = 1.0/(dS*dS + 1e-30)

        # Boundary: p=0 at ends
        B[0]=1.0; RHS[0]=0.0
        for j in range(1, M-1):
            Dw = 0.5*(D_core[j] + D_core[j-1])
            De = 0.5*(D_core[j] + D_core[j+1])
            A[j] = -Dw*invdS2
            C[j] = -De*invdS2
            B[j] = -(A[j] + C[j]) + 1e-12
            RHS[j] = RHS_core[j]
        B[M-1]=1.0; RHS[M-1]=0.0

        # Thomas solve
        for j in range(1, M):
            wfac = A[j]/(B[j-1] + 1e-30)
            B[j]   -= wfac*C[j-1]
            RHS[j] -= wfac*RHS[j-1]
        P_new = np.zeros(M)
        P_new[-1] = RHS[-1]/(B[-1] + 1e-30)
        for j in range(M-2, -1, -1):
            P_new[j] = (RHS[j] - C[j]*P_new[j+1])/(B[j] + 1e-30)

        # Enforce cavitation
        P_new = np.maximum(P_new, 0.0)

        # --- gentle load relaxation each substep (preserves local shape) ---
        p_tmp  = embed_p(P_new)
        Wa_sub = np.trapezoid(asperity_pressure_greenwood_tripp(np.maximum(h_nom,h_floor)), x) * L
        Wh_sub = np.trapezoid(p_tmp, x) * L
        total_load = Wa_sub + Wh_sub
        if total_load > 1e-18:
            if total_load > W:
                Wh_target = max(W - Wa_sub, 0.0)
                if Wh_sub > 1e-18:
                    s_relax = np.clip(Wh_target/(Wh_sub + 1e-30), 0.0, 1.0)
                    P_new *= s_relax
                    Wh_sub *= s_relax
                total_load = Wa_sub + Wh_sub
            else:
                load_ratio = W/(total_load + 1e-30)
                if load_ratio < 1.0:
                    s_relax = np.clip(load_ratio, 0.10, 1.0)
                    P_new *= s_relax
                    Wh_sub *= s_relax
                    total_load = Wa_sub + Wh_sub
        else:
            total_load = 1e-18

        gap_baseline = max(np.median(h_nom), h_floor)
        load_error = W - total_load
        load_norm = np.clip(load_error/(abs(W) + 1e-30), -1.0, 1.0)
        gap_relax = 0.45
        angle_weight = np.exp(-((angle_deg)/18.0)**2)
        gap_relax_eff = gap_relax * (0.35 + 0.65*angle_weight)
        h_shift -= gap_relax_eff * load_norm * gap_baseline
        h_shift = np.clip(h_shift, h_floor - h0, 1.25*h0)
        if Ve >= 0.0:
            h_shift = max(h_shift, -0.25*h0)

        # Relax + light smoothing
        P_core = (1 - relax_p) * P_core + relax_p * P_new
        Ptmp = P_core.copy()
        P_core[1:-1] = K1*Ptmp[:-2] + K0*Ptmp[1:-1] + K1*Ptmp[2:]
        P_core[0]  = 0.0
        P_core[-1] = 0.0

        p_prev = embed_p(P_core).copy()

        # Update film (elastic + texture)
        defl  = elastic_deflection(x, p_prev)
        h_candidate = np.maximum(h0 + h_shift + x**2/(2*R) + defl + htex, h_floor)
        h = np.maximum(relax_h*h + (1.0-relax_h)*h_candidate, h_floor)

    # Final pass & dimensional fields
    p = embed_p(P_core)
    # Consistency update: compute final deflection once (no ex-post scaling)
    defl_final = elastic_deflection(x, p)
    h = np.maximum(h0 + h_shift + x**2/(2*R) + defl_final + htex, h_floor)

# Mixed loads
    p_asp_final = asperity_pressure_greenwood_tripp(h)
    Wa_raw = np.trapezoid(p_asp_final, x) * L
    Wh_now = np.trapezoid(p, x) * L
    load_deficit = W - Wh_now
    if load_deficit > 1e-12 and Wa_raw > 1e-12:
        scale_asp = np.clip(load_deficit/(Wa_raw + 1e-30), 0.0, 5.0)
        p_asp_final = p_asp_final * scale_asp
        Wa_final = np.trapezoid(p_asp_final, x) * L
    elif load_deficit > 1e-12 and Wa_raw <= 1e-12:
        Wa_final = load_deficit
    else:
        Wa_final = np.maximum(Wa_raw + min(load_deficit, 0.0), 0.0)

    # === Friction (hydrodynamic + boundary) ===
    eta_w, _dT_f = eta_houpert(p, TEMP_C, Ve, h, a)
    dpdx   = np.gradient(p, x)
    gdot_wall = np.maximum(np.abs(Vs)/np.maximum(h,1e-12), 1e-6)
    eta_w_sh  = eta_carreau(eta_w, h, gdot_wall)

    tau_c  = np.where(h>1e-12, eta_w_sh * np.maximum(Vs,1e-6)/h, 0.0)
    tau_p  = 0.5 * np.maximum(h,1e-12) * np.abs(dpdx)
    tau_tot= tau_c + tau_p

    tau_lim = gamma_lim * np.maximum(p, 0.0)
    tau_eff = np.minimum(tau_tot, tau_lim)

    # ------------------ TEXTURED-ONLY FLASH TEMPERATURE & TRACTION UPDATE ------------------
    if atex_theta > 0.0:
        mask_tex, f_cov = _texture_mask_and_coverage(x, a, atex_theta, shift_theta, d_texture, htex, MASK_THR_MULT)
        if f_cov >= F0_COVERAGE and np.any(mask_tex):
            SRR = np.abs(Vs) / (np.abs(Ve) + 1e-30)
            qpp = tau_eff * np.abs(Vs)
            dTf_local = _flash_line_kernel(qpp, a) * (CHI_TEX * BETA_EDGE / (K_EFF + 1e-30))
            dTf_local *= (f_cov**NFCOV) * (1.0 + KAPPA_SRR * SRR)

            eta_w_tex = eta_w_sh.copy()
            eta_w_tex[mask_tex] = eta_w_sh[mask_tex] * np.exp(-BETA_ETA_F * np.maximum(dTf_local[mask_tex], 0.0))

            tau_c_tex = tau_c.copy()
            tau_c_tex[mask_tex] = np.where(h[mask_tex]>1e-12,
                                           eta_w_tex[mask_tex] * np.maximum(np.abs(Vs),1e-6)/h[mask_tex],
                                           0.0)

            tau_lim_tex = tau_lim.copy()
            tau_lim_tex[mask_tex] = C_LSS_TEX * (np.maximum(p[mask_tex], 0.0)**M_LSS_TEX)

            tau_tot_tex = tau_c_tex + tau_p
            tau_eff[mask_tex] = np.minimum(tau_tot_tex[mask_tex], tau_lim_tex[mask_tex])
    # ---------------------------------------------------------------------------------------

    Fh = np.trapezoid(tau_eff, x) * L
    Fb = L * np.trapezoid( mu_b * p_asp_final, x)

    return {"x": x, "p": p, "h": h, "Fh": float(Fh), "Fb": float(Fb),
            "Wa": float(Wa_final), "a": float(a), "pmax": float(np.max(p)),
            "h_shift": float(h_shift)}

# ============================================================
# PLOT CONTROLLER & UTILITIES 
# ============================================================
def _as_list(v):
    return list(v) if isinstance(v, (list, tuple, np.ndarray)) else [v]

PLOT_OPTS = {
    "PROFILES": {
        "PRESSURE": {
            "ENABLE": True,
            "angles_deg": [10],
            "rpms": [300],
            "surface_state": 0,         # 0 = UNTEXTURED, 1 = TEXTURED
            "texture_densities": [8],
        },
        "FILM": {
            "ENABLE": True,
            "angles_deg": [10],
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
    "SWEEPS": {
        "Fh": {"ENABLE": True, "angles_deg": None, "rpms": [300], "surface_state": 0, "texture_densities": [8],},
        "Fb": {"ENABLE": True, "angles_deg": None, "rpms": [300], "surface_state": 0, "texture_densities": [8],},
        "Torque": {"ENABLE": False, "angles_deg": None, "rpms": [300,500], "surface_state": 0, "texture_densities": [8],},
        "Wa": {"ENABLE": False, "angles_deg": None, "rpms": [300], "surface_state": 0, "texture_densities": [8],},
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
    "AVG_TORQUE": {"ENABLE": False, "rpms": [300, 500, 700, 900], "surface_state": 0, "texture_densities": [8],},
    "AVG_TORQUE_REDUCTION": {"ENABLE": False, "rpms": [300, 500], "densities_vs_UN": [5],},
    "HTEX_300RPM": {"ENABLE": False, "texture_densities": [5, 8, 10], "style": {"lw": 2.0, "grid_alpha": 0.35},},
    # ---------------- NEW: Single-variable vs angle (Ve, Vs, W, R, a_hertz, ph, hc) ----------------
    "VARIABLE_BY_ANGLE": {
        "ENABLE": False,                 # set True to plot
        "variable": "hc",                # one of: "Ve","Vs","W","R","a_hertz","ph","hc"
        "rpms": [300],              # single RPM or list
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
}

def _dens_keys(nums):
    mapnum = {5: '5%', 8: '8%', 10: '10%'}
    if nums is None:
        return []
    out = [mapnum[n] for n in _as_list(nums) if n in mapnum]
    if len(out) == 0 and nums not in (None, []):
        raise ValueError("No valid texture densities given. Use any of 5, 8, 10.")
    return out

def _nearest_angle_index(angle_deg):
    return int(np.argmin(np.abs(TH_DEG - angle_deg)))

def _arm_at(angle_deg):
    j = _nearest_angle_index(angle_deg)
    return rb + lift_s[j]

def _torque(Fh, Fb, angle_deg):
    return (Fh + Fb) * _arm_at(angle_deg)

def _inputs_at(angle_deg, rpm, R, Ve, Vs, W):
    w = 2*np.pi*rpm/60.0
    j = _nearest_angle_index(angle_deg)
    dtheta = float(np.mean(np.diff(th)))
    dt = dtheta / (w + 1e-30)
    return dt, float(R[j]), float(Ve[j]), float(Vs[j]), float(W[j]), j

def _sweep_series_general(rpm, angle_list_deg, textured=False, density_key=None):
    angles = np.asarray(angle_list_deg, float)
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    Fh_list, Fb_list, Tq_list, Wa_list = [], [], [], []
    for ang in angles:
        dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
        if textured:
            atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
            dtex   = D_TEXTURE[density_key]
            sh_j   = float(shift[j])
        else:
            atex_j = 0.0
            dtex   = D_TEXTURE['5%']  # unused in UN but kept for call-compat
            sh_j   = 0.0

        obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                          atex_theta=atex_j, shift_theta=sh_j,
                          d_texture=dtex,
                          Nx=171, iters=80, substep_cap=6,
                          relax_p=0.85, relax_h=0.55,
                          M_core=451, observe=True)
        Fh, Fb, Wa = float(obs["Fh"]), float(obs["Fb"]), float(obs["Wa"])
        Tq = _torque(Fh, Fb, ang)
        Fh_list.append(Fh); Fb_list.append(Fb); Tq_list.append(Tq); Wa_list.append(Wa)
    return angles, np.asarray(Fh_list), np.asarray(Fb_list), np.asarray(Tq_list), np.asarray(Wa_list)

# ============================================================
# A) Profiles — pressure & film
# ============================================================
def plot_profile_pressure():
    cfg = PLOT_OPTS["PROFILES"]["PRESSURE"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms   = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
            if textured:
                for dk in dens_keys:
                    atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                      atex_theta=atex_j, shift_theta=float(shift[j]),
                                      d_texture=D_TEXTURE[dk],
                                      Nx=171, iters=80, substep_cap=6,
                                      relax_p=0.85, relax_h=0.55,
                                      M_core=451, observe=True)
                    x, p, a = obs["x"], obs["p"], float(obs["a"])
                    X = x/max(a,1e-12)
                    # Plot dimensional pressure to actually see texture spikes
                    plt.figure(dpi=dpi)
                    plt.plot(X, p, linewidth=lw,
                             label=f"{dk} | θ={ang:.1f}°, {rpm} RPM")
                    plt.xlabel("X = x/a"); plt.ylabel("p (Pa)")
                    plt.title("Reynolds pressure vs X")
                    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()
            else:
                obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                  atex_theta=0.0, shift_theta=0.0, d_texture=D_TEXTURE['5%'],
                                  Nx=171, iters=80, substep_cap=6,
                                  relax_p=0.85, relax_h=0.55,
                                  M_core=451, observe=True)
                x, p, a = obs["x"], obs["p"], float(obs["a"])
                X = x/max(a,1e-12)
                plt.figure(dpi=dpi)
                plt.plot(X, p, linewidth=lw,
                         label=f"UN | θ={ang:.1f}°, {rpm} RPM")
                plt.xlabel("X = x/a"); plt.ylabel("p (Pa)")
                plt.title("Reynolds pressure vs X")
                plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_profile_film():
    cfg = PLOT_OPTS["PROFILES"]["FILM"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms   = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
            if textured:
                for dk in dens_keys:
                    atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                      atex_theta=atex_j, shift_theta=float(shift[j]),
                                      d_texture=D_TEXTURE[dk],
                                      Nx=171, iters=80, substep_cap=6,
                                      relax_p=0.85, relax_h=0.55,
                                      M_core=451, observe=True)
                    x, h = obs["x"], obs["h"]
                    plt.figure(dpi=dpi)
                    plt.plot(x*1e3, h*1e9, linewidth=lw,
                             label=f"{dk} | h(x) | θ={ang:.1f}°, {rpm} RPM")
                    plt.xlabel("x (mm)"); plt.ylabel("h (nm)")
                    plt.title("Film thickness vs x")
                    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()
            else:
                obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                  atex_theta=0.0, shift_theta=0.0, d_texture=D_TEXTURE['5%'],
                                  Nx=171, iters=80, substep_cap=6,
                                  relax_p=0.85, relax_h=0.55,
                                  M_core=451, observe=True)
                x, h = obs["x"], obs["h"]
                plt.figure(dpi=dpi)
                plt.plot(x*1e3, h*1e9, linewidth=lw,
                         label=f"UN | h(x) | θ={ang:.1f}°, {rpm} RPM")
                plt.xlabel("x (mm)"); plt.ylabel("h (nm)")
                plt.title("Film thickness vs x")
                plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

# ============================================================
# B–E) Angle sweeps — preserved
# ============================================================
def _angles_for(cfg_angles):
    if cfg_angles is None:
        return TH_DEG.tolist()
    return _as_list(cfg_angles)

def plot_sweep_Fh():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Fh"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"]); rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Fh, linewidth=lw, label=f"Fh | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Fh, linewidth=lw, label=f"Fh | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Hydrodynamic friction Fh (N)")
    plt.title("Hydrodynamic friction vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Fb():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Fb"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"]); rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Fb, linewidth=lw, label=f"Fb | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Fb, linewidth=lw, label=f"Fb | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Asperity friction Fb (N)")
    plt.title("Asperity friction vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Torque():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Torque"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"]); rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Tq, linewidth=lw, label=f"T | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Tq, linewidth=lw, label=f"T | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Friction torque T (N·m)")
    plt.title("Friction torque vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Wa():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Wa"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"]); rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Wa, linewidth=lw, label=f"Wa | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Wa, linewidth=lw, label=f"Wa | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Asperity load Wa (N)")
    plt.title("Asperity load vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

# ============================================================
# F) Cycle-averaged torque & reductions — preserved
# ============================================================
def average_cycle_torque(rpm, angles_deg, textured=False, density_key=None):
    angles = np.asarray(angles_deg, float)
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    Tq = []
    for ang in angles:
        dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
        if textured:
            atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
            dtex   = D_TEXTURE[density_key]; sh_j = float(shift[j])
        else:
            atex_j = 0.0; dtex = D_TEXTURE['5%']; sh_j = 0.0
        obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                          atex_theta=atex_j, shift_theta=sh_j,
                          d_texture=dtex,
                          Nx=171, iters=80, substep_cap=6,
                          relax_p=0.85, relax_h=0.55,
                          M_core=451, observe=True)
        Tq.append(_torque(float(obs["Fh"]), float(obs["Fb"]), ang))
    return float(np.mean(Tq))

def section_avg_torque():
    cfg = PLOT_OPTS["AVG_TORQUE"]
    if not cfg["ENABLE"]:
        return
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    angles_deg = TH_DEG.tolist()

    print("\n=== Average friction torque over CAM cycle ===")
    for rpm in rpms:
        if not textured:
            T_un = average_cycle_torque(rpm, angles_deg, textured=False)
            print(f"RPM {rpm:>4}: UN   <T> = {T_un:.6f} N·m")
        else:
            for dk in dens_keys:
                T_tex = average_cycle_torque(rpm, angles_deg, textured=True, density_key=dk)
                print(f"RPM {rpm:>4}: {dk:>3} <T> = {T_tex:.6f} N·m")

def section_avg_torque_reduction():
    cfg = PLOT_OPTS["AVG_TORQUE_REDUCTION"]
    if not cfg["ENABLE"]:
        return
    rpms = _as_list(cfg["rpms"])
    dens_keys = _dens_keys(cfg.get("densities_vs_UN", []))
    angles_deg = TH_DEG.tolist()

    print("\n=== Average friction torque reduction vs UN (independent) ===")
    for rpm in rpms:
        T_un = average_cycle_torque(rpm, angles_deg, textured=False)
        print(f"\nRPM {rpm:>4}: UN   <T> = {T_un:.6f} N·m")
        for dk in dens_keys:
            T_tex = average_cycle_torque(rpm, angles_deg, textured=True, density_key=dk)
            red = 100.0*(T_un - T_tex)/abs(T_un) if abs(T_un) > 1e-12 else 0.0
            print(f"          {dk:>3} <T> = {T_tex:.6f} N·m   (Δ% = {red:+.2f}%)")

# ============================================================
# G) Optional: htex vs angle at 300 RPM — preserved
# ============================================================
def plot_htex_vs_angle_300rpm():
    cfg = PLOT_OPTS["HTEX_300RPM"]
    if not cfg["ENABLE"]:
        return
    dens_keys = _dens_keys(cfg.get("texture_densities", []))
    if len(dens_keys) == 0:
        return
    style = cfg["style"]; lw, gA = style["lw"], style["grid_alpha"]
    rpm = 300
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    fig, axs = plt.subplots(len(dens_keys), 1, figsize=(7, 2.6*len(dens_keys)), sharex=True)
    axs = np.atleast_1d(axs)
    for ax, dk in zip(axs, dens_keys):
        dtex = D_TEXTURE[dk]
        h0list = []
        for i in range(len(TH_DEG)):
            a = a_hertz(W[i], R[i])
            atex_i = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[i] else 0.0
            h0list.append(htex_profile(np.array([0.0]), a, atex_i, shift[i], dtex)[0])
        ax.plot(TH_DEG, np.array(h0list), linewidth=lw)
        ax.set_ylabel(f"htex (m)\n{dk}"); ax.grid(True, alpha=gA)
    axs[-1].set_xlabel("Cam angle (deg)")
    fig.suptitle("htex at contact center vs cam angle (300 RPM)")
    plt.tight_layout(rect=[0, 0, 1, 0.95])

# ============================================================
# H) NEW: Single-variable vs cam angle (Ve, Vs, W, R, a_hertz, ph, hc)
# ============================================================
def _variable_series(rpm, varname):
    varname = str(varname)
    valid = {"Ve","Vs","W","R","a_hertz","ph","hc"}
    if varname not in valid:
        raise ValueError(f"VARIABLE_BY_ANGLE.variable must be one of {sorted(valid)}")

    R_arr, Ve_arr, Vs_arr, W_arr, w = kin_arrays(rpm)
    a_arr  = np.sqrt(np.maximum(4.0*np.maximum(W_arr,0.0)*np.maximum(R_arr,1e-12),0.0)/(np.pi*E_star*L + 1e-30))
    ph_arr = 2.0*np.maximum(W_arr,0.0)/(np.pi*np.maximum(a_arr,1e-12)*L + 1e-30)
    # Hamrock–Dowson seed (used as 'hc'):
    hc_arr = np.array([central_film_thickness(R_arr[i], W_arr[i], Ve_arr[i]) for i in range(len(R_arr))], dtype=float)

    mapping = {
        "Ve": Ve_arr,
        "Vs": Vs_arr,
        "W":  W_arr,
        "R":  R_arr,
        "a_hertz": a_arr,
        "ph": ph_arr,
        "hc": hc_arr,
    }
    return TH_DEG, np.asarray(mapping[varname], dtype=float)

def plot_variable_by_angle():
    cfg = PLOT_OPTS["VARIABLE_BY_ANGLE"]
    if not cfg["ENABLE"]:
        return
    varname = cfg.get("variable", "Ve")
    style = cfg.get("style", {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120})
    lw, dpi, gA = style.get("lw", 2.0), style.get("dpi", 120), style.get("grid_alpha", 0.35)
    rpms = _as_list(cfg.get("rpms", [300]))

    ylabels = {
        "Ve": "Ve (m/s)",
        "Vs": "Vs (m/s)",
        "W":  "W (N)",
        "R":  "R (m)",
        "a_hertz": "a (m)",
        "ph": "p_h (Pa)",
        "hc": "h_c, seed (m)",
    }
    plt.figure(dpi=dpi)
    for rpm in rpms:
        ang, y = _variable_series(rpm, varname)
        plt.plot(ang, y, linewidth=lw, label=f"{varname} | {rpm} RPM")
    plt.xlabel("Cam angle (deg)")
    plt.ylabel(ylabels.get(varname, varname))
    plt.title(f"{varname} vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()
# ============================================================
# Master runner
# ============================================================
def run_all():
    plot_profile_pressure()
    plot_profile_film()
    plot_htex_vs_angle_300rpm()
    plot_sweep_Fh()
    plot_sweep_Fb()
    plot_sweep_Torque()
    plot_sweep_Wa()
    plot_variable_by_angle()  
    section_avg_torque()
    section_avg_torque_reduction()
    plt.show()

# ----- Execute -----
if __name__ == "__main__":
    run_all()
