from __future__ import annotations

import math
import pathlib
from dataclasses import dataclass
from typing import Dict

import numpy as np
import scipy.fft as fft
# ============================================================
# Small utility
# ============================================================

def trapz(y: np.ndarray, x: np.ndarray) -> float:
    # Compatible across NumPy versions
    return float(np.trapz(y, x))


def solve_tridiagonal(
    lower: np.ndarray,
    diag: np.ndarray,
    upper: np.ndarray,
    rhs: np.ndarray,
) -> np.ndarray:
    """Thomas algorithm for tri-diagonal systems."""
    n = diag.size
    a = lower.copy()
    b = diag.copy()
    c = upper.copy()
    d = rhs.copy()

    for i in range(1, n):
        w = a[i - 1] / b[i - 1]
        b[i] -= w * c[i - 1]
        d[i] -= w * d[i - 1]

    x = np.zeros(n)
    x[-1] = d[-1] / b[-1]

    for i in range(n - 2, -1, -1):
        x[i] = (d[i] - c[i] * x[i + 1]) / b[i]

    return x


# ============================================================
# Lubricant model: Roelands + Dowson–Higginson
# ============================================================

@dataclass
class Lubricant:
    mu0: float        # reference viscosity [Pa·s]
    alpha: float      # pressure-viscosity coefficient [1/Pa]
    rho0: float       # reference density [kg/m^3]
    p_ref: float = 0.0

    mu_min_ratio: float = 1e-5
    mu_max_ratio: float = 1e3

    # Typical Dowson–Higginson
    dh_a: float = 0.59e-9
    dh_b: float = 1.34e-9

    def viscosity(self, p: np.ndarray) -> np.ndarray:
        p_eff = np.asarray(p, float) - self.p_ref
        z = self.alpha * p_eff
        mu = self.mu0 * np.exp(z / (1.0 + 0.5 * z))
        return np.clip(
            mu,
            self.mu0 * self.mu_min_ratio,
            self.mu0 * self.mu_max_ratio,
        )

    def density(self, p: np.ndarray) -> np.ndarray:
        p_eff = np.asarray(p, float) - self.p_ref
        return self.rho0 * (1.0 + self.dh_a * p_eff) / (1.0 + self.dh_b * p_eff)


# ============================================================
# Roughness: Greenwood–Tripp asperity model (Arcoumanis F5/2)
# ============================================================

@dataclass
class Roughness:
    rms: float
    asperity_density: float
    asperity_radius: float

    def F52(self, lam: np.ndarray) -> np.ndarray:
        """Arcoumanis polynomial fit of Greenwood–Tripp F_{5/2}(λ)."""
        lam = np.asarray(lam, float)
        lam_c = 2.224
        lc = np.clip(lam, 0.0, lam_c)

        F = (
            0.0046 * lc**5
            + 0.0574 * lc**4
            - 0.2958 * lc**3
            + 0.7844 * lc**2
            - 1.0776 * lc
            + 0.6167
        )
        F = np.where(lc >= lam_c, 0.0, F)
        return np.clip(F, 0.0, None)

    def asperity_pressure(self, h: np.ndarray, E_red: float) -> np.ndarray:
        """Greenwood–Tripp asperity pressure [Pa]."""
        pa = np.zeros_like(h)
        if self.rms <= 0 or self.asperity_density <= 0 or self.asperity_radius <= 0:
            return pa

        lam = np.maximum(h / self.rms, 0.0)
        F = self.F52(lam)

        pref = (
            (16.0 * math.sqrt(2.0) / 15.0)
            * E_red
            * (self.asperity_density * self.asperity_radius * self.rms) ** 2
            * math.sqrt(self.rms / self.asperity_radius)
        )
        pa[:] = pref * F
        return pa


# ============================================================
# Solid, grid, kinematics, controls
# ============================================================

@dataclass
class SolidMaterial:
    youngs_modulus: float
    poisson_ratio: float

    @property
    def reduced_modulus(self) -> float:
        return self.youngs_modulus / (1.0 - self.poisson_ratio ** 2)


@dataclass
class SimulationGrid:
    length: float
    nodes: int

    @property
    def dx(self) -> float:
        return self.length / (self.nodes - 1)

    @property
    def x(self) -> np.ndarray:
        return np.linspace(-0.5 * self.length, 0.5 * self.length, self.nodes)


@dataclass
class Kinematics:
    entrainment_speed: float   # Ue
    relative_speed: float      # Urel (kept for completeness)


@dataclass
class SolverControls:
    max_ehl_iterations: int = 50
    max_reynolds_iterations: int = 200   # (not used in transient; kept for compat)
    reynolds_tol: float = 1e-5
    load_tol: float = 5e-2               # relative
    relaxation_p: float = 0.6
    relaxation_hc: float = 0.4
    transient_dt: float = 1e-4           # pseudo-time step for Reynolds
    max_time_steps: int = 4000           # max pseudo-time steps per EHL iter


@dataclass
class EHLParameters:
    lubricant: Lubricant
    roughness: Roughness
    solid: SolidMaterial
    grid: SimulationGrid
    kin: Kinematics
    radius: float
    load_per_unit_length: float
    controls: SolverControls
    p_ambient: float = 0.0
    p_cav: float = 0.0


# ============================================================
# Hertz line contact geometry
# ============================================================

def hertz_half_width(R: float, W: float, mat: SolidMaterial) -> float:
    Ered = mat.reduced_modulus
    return math.sqrt(4.0 * W * R / (math.pi * Ered))


def hertz_max_pressure(R: float, W: float, mat: SolidMaterial) -> float:
    a = hertz_half_width(R, W, mat)
    return 2.0 * W / (math.pi * a)


def line_geometry(x: np.ndarray, R: float) -> np.ndarray:
    return x**2 / (2.0 * R)


# ============================================================
# Elastic deformation via FFT (1D line contact)
# ============================================================

def make_fft_kernel(grid: SimulationGrid, mat: SolidMaterial) -> np.ndarray:
    """
    Influence kernel (Fourier domain) for elastic half-space under line load:
        u_hat(k) = -2 / (E' |k|) * p_hat(k)
    """
    dx = grid.dx
    n = grid.nodes
    k = 2.0 * math.pi * fft.rfftfreq(n, d=dx)
    K = np.zeros_like(k)
    K[1:] = -2.0 / (mat.reduced_modulus * np.abs(k[1:]))
    K[0] = 0.0
    return K


def elastic_deflection(p: np.ndarray, K_fft: np.ndarray, dx: float) -> np.ndarray:
    Pk = fft.rfft(p)
    uz = fft.irfft(Pk * K_fft, n=p.size)
    return uz * dx


# ============================================================
# Transient Reynolds equation (pseudo-time stepping)
# ============================================================

def solve_reynolds_transient(
    h: np.ndarray,
    params: EHLParameters,
    p_init: np.ndarray,
) -> np.ndarray:
    """
    Pseudo-transient solution of compressible Reynolds:
        ∂p/∂τ + R(p) = 0

    Backward Euler in pseudo-time:
        (p^{n+1} - p^n)/Δτ + R(p^{n+1}) = 0

    R(p) is the steady Reynolds residual with:
      - p = max(p_ambient, p_cav) at both ends,
      - cavitation floor p >= p_cav,
      - no artificial symmetry/dome.
    """
    g = params.grid
    lub = params.lubricant
    c = params.controls

    n = g.nodes
    dx = g.dx
    Ue = params.kin.entrainment_speed
    pc = params.p_cav
    p_bc = max(params.p_ambient, pc)

    dt = c.transient_dt
    inv_dt = 1.0 / dt

    p = np.clip(p_init, pc, None)

    for _ in range(c.max_time_steps):
        rho = lub.density(p)
        mu = lub.viscosity(p)
        h_eff = np.maximum(h, 1e-12)
        M = rho * h_eff**3 / (12.0 * mu)

        # Face-centered properties
        M_face = np.zeros(n - 1)
        RhU_face = np.zeros(n - 1)
        for j in range(n - 1):
            Mw = max(M[j], 1e-20)
            Me = max(M[j + 1], 1e-20)
            M_face[j] = 2.0 / (1.0 / Mw + 1.0 / Me)
            # Advective term: (ρ h Ue) at faces
            RhU_face[j] = 0.5 * (rho[j] * h_eff[j] + rho[j + 1] * h_eff[j + 1]) * Ue

        # Build steady Reynolds operator A_ss p = b_ss
        A_diag = np.zeros(n)
        A_lower = np.zeros(n - 1)
        A_upper = np.zeros(n - 1)
        b = np.zeros(n)

        # Inlet BC
        A_diag[0] = 1.0
        b[0] = p_bc

        # Interior nodes
        for j in range(1, n - 1):
            Mw = M_face[j - 1]
            Me = M_face[j]
            Cw = RhU_face[j - 1]
            Ce = RhU_face[j]

            # Diffusion (pressure-driven flow)
            A_lower[j - 1] = -Mw / dx**2
            A_upper[j] = -Me / dx**2
            A_diag[j] = (Mw + Me) / dx**2

            # Advection source term
            b[j] = (Ce - Cw) / dx

        # Outlet BC
        A_diag[-1] = 1.0
        b[-1] = p_bc
        A_lower[-1] = 0.0
        A_upper[-1] = 0.0

        # Pseudo-transient term: (I/Δτ + A_ss) p^{n+1} = p^n/Δτ + b_ss
        for j in range(1, n - 1):
            A_diag[j] += inv_dt
            b[j] += inv_dt * p[j]

        p_new = solve_tridiagonal(A_lower, A_diag, A_upper, b)
        p_new = np.maximum(p_new, pc)

        if np.linalg.norm(p_new - p, np.inf) < c.reynolds_tol:
            p = p_new
            break

        p = p_new

    return np.maximum(p, pc)


# ============================================================
# Mixed-EHL solver: transient Reynolds + elasticity + asperities
# ============================================================

def simulate_ehl(params: EHLParameters) -> Dict[str, np.ndarray]:
    g = params.grid
    x = g.x
    dx = g.dx

    rough = params.roughness
    solid = params.solid
    c = params.controls

    # Hertz line contact
    a = hertz_half_width(params.radius, params.load_per_unit_length, solid)
    p_hertz = hertz_max_pressure(params.radius, params.load_per_unit_length, solid)

    # Geometry & elastic kernel
    geom = line_geometry(x, params.radius)
    K_fft = make_fft_kernel(g, solid)

    # Initial central film thickness
    h_c = 5.0 * rough.rms

    # Initial hydrodynamic pressure: Hertz dome in [-a,a]
    p = np.full(g.nodes, params.p_cav)
    active = np.abs(x) < a
    p[active] = p_hertz * np.sqrt(1.0 - (x[active] / a) ** 2)
    p = np.maximum(p, params.p_cav)

    p_asp = np.zeros_like(p)
    total_prev = p + p_asp

    for _ in range(c.max_ehl_iterations):
        # --- Film thickness from elastic deformation ---
        uz = elastic_deflection(total_prev, K_fft, dx)
        h = np.maximum(h_c + geom + uz, 0.005 * rough.rms)

        # --- Transient Reynolds step for hydrodynamic pressure ---
        p_new = solve_reynolds_transient(h, params, p_init=p)

        # --- Asperity pressure from Greenwood–Tripp (no hard clipping) ---
        p_asp_new = rough.asperity_pressure(h, solid.reduced_modulus)

        # --- Total pressure and load ---
        total_p = p_new + p_asp_new
        W_num = trapz(total_p, x)

        # Relax towards new fields
        p = (1.0 - c.relaxation_p) * p + c.relaxation_p * p_new
        p = np.maximum(p, params.p_cav)

        p_asp = (1.0 - c.relaxation_p) * p_asp + c.relaxation_p * p_asp_new

        # Load-controlled update of h_c
        W_tar = params.load_per_unit_length
        rel_err = (W_num - W_tar) / W_tar if W_tar > 0 else 0.0

        if abs(rel_err) < c.load_tol:
            break

        factor = 1.0 + c.relaxation_hc * rel_err
        factor = max(0.3, min(1.7, factor))
        h_c = max(0.02 * rough.rms, h_c * factor)

        total_prev = p + p_asp

    # Final fields
    uz = elastic_deflection(p + p_asp, K_fft, dx)
    h = np.maximum(h_c + geom + uz, 0.005 * rough.rms)
    p_asp = rough.asperity_pressure(h, solid.reduced_modulus)
    total_p = p + p_asp
    W_num = trapz(total_p, x)

    return {
        "x": x,
        "pressure": p,
        "thickness": h,
        "asperity_pressure": p_asp,
        "hertz_half_width": a,
        "hertz_pressure": p_hertz,
        "central_thickness": h_c,
        "load_numerical": W_num,
    }


# ============================================================
# Default parameters & plotting (inline)
# ============================================================

def default_parameters() -> EHLParameters:
    # User-specified case
    W_per_L = 10e3
    rms = 0.2e-6
    eta = 1.25e9
    Ra = 2.0e-4
    Ue = 1.2
    Urel = 0.8
    R = 0.007

    solid = SolidMaterial(youngs_modulus=210e9, poisson_ratio=0.3)
    a = hertz_half_width(R, W_per_L, solid)
    L = 8.0 * a           # numerical window [-4a, 4a]
    nodes = 801

    grid = SimulationGrid(length=L, nodes=nodes)
    lubricant = Lubricant(mu0=0.01381, alpha=15e-9, rho0=858.44)
    rough = Roughness(rms=rms, asperity_density=eta, asperity_radius=Ra)
    kin = Kinematics(entrainment_speed=Ue, relative_speed=Urel)
    controls = SolverControls(
        max_ehl_iterations=80,
        max_reynolds_iterations=200,
        reynolds_tol=1e-5,
        load_tol=2e-2,
        relaxation_p=0.6,
        relaxation_hc=0.6,
        transient_dt=1e-4,
        max_time_steps=4000,
    )

    return EHLParameters(
        lubricant=lubricant,
        roughness=rough,
        solid=solid,
        grid=grid,
        kin=kin,
        radius=R,
        load_per_unit_length=W_per_L,
        controls=controls,
        p_ambient=0.0,
        p_cav=0.0,
    )


def run_default_case() -> Dict[str, np.ndarray]:
    params = default_parameters()
    res = simulate_ehl(params)

    try:
        import matplotlib.pyplot as plt
    except ModuleNotFoundError:
        print("matplotlib not available; skipping plots")
        return res

    x = res["x"]
    p = res["pressure"]
    h = res["thickness"]
    p_asp = res["asperity_pressure"]
    a = res["hertz_half_width"]

    # Plot over [-4.5a, 3a] scaled by a
    mask = (x >= -4.5 * a) & (x <= 3.0 * a)
    xs = x[mask] / a

    fig, axes = plt.subplots(3, 1, figsize=(8, 9), sharex=True)

    axes[0].plot(xs, p[mask], label="Hydrodynamic pressure")
    axes[0].axvline(-1.0, linestyle="--", linewidth=0.7)
    axes[0].axvline(1.0, linestyle="--", linewidth=0.7)
    axes[0].set_ylabel("Pressure [Pa]")
    axes[0].legend()
    axes[0].set_title("Mixed EHL line contact (scaled by Hertz a)")

    axes[1].plot(xs, h[mask], label="Film thickness")
    axes[1].set_ylabel("Film thickness [m]")
    axes[1].legend()

    axes[2].plot(xs, p_asp[mask], label="Asperity pressure")
    axes[2].set_xlabel("x / a")
    axes[2].set_ylabel("Asperity pressure [Pa]")
    axes[2].legend()

    fig.tight_layout()
    out = pathlib.Path("ehl_profiles_scaled.png")
    fig.savefig(out, dpi=200)

    print(f"Target load W' = {params.load_per_unit_length:.3e} N/m")
    print(f"Numerical load  = {res['load_numerical']:.3e} N/m")
    print(f"Load ratio      = {res['load_numerical'] / params.load_per_unit_length:.3f}")
    print(f"Max pressure    = {np.max(p):.3e} Pa")
    print(f"Min film h_min  = {np.min(h):.3e} m")
    print(f"Central h_c     = {res['central_thickness']:.3e} m")

    return res


if __name__ == "__main__":
    run_default_case()
