# ============================================================
# CAM–SHIM (Bucket Tappet) — 1D Mixed Lubrication line contact
# ============================================================

DATA_DIR = "/content/cam"   # <--- put your folder path here
CAM_FILE = "updated_lift.txt"

import os, numpy as np, pandas as pd
import matplotlib.pyplot as plt
from math import pi, ceil
from scipy.signal import savgol_filter
plt.rcParams.update({"figure.dpi": 120})

# =======================
# USER: set test temperature (°C)
# =======================
TEMP_C = 90  # <-- set to 60, 90, or 110 before running

def _load_cam(data_dir, fname):
    path = os.path.join(data_dir, fname)
    _cam = pd.read_csv(
        path, sep=r"\s+", engine="python", comment="#", header=None,
        names=["angle_deg", "lift_m"], usecols=[0, 1]
    )
    _cam["angle_deg"] = pd.to_numeric(_cam["angle_deg"], errors="raise")
    _cam["lift_m"]    = pd.to_numeric(_cam["lift_m"],    errors="raise")
    return _cam.sort_values("angle_deg").reset_index(drop=True)

CAM = _load_cam(DATA_DIR, CAM_FILE)
th_deg = CAM["angle_deg"].to_numpy(dtype=float)
th     = np.deg2rad(th_deg)
lift   = CAM["lift_m"].to_numpy(dtype=float)
TH_DEG = th_deg.copy()
lift_s = lift.copy()
dlift_s  = np.gradient(lift, th)           # dL/dθ
d2lift_s = np.gradient(dlift_s, th)

# ============================================================
# Materials / geometry / fluid (Fixed)
# ============================================================
rb       = 18.5e-3      # base circle radius [m]
k_spring = 7130.0       # spring rate [N/m]
delta    = 1.77e-3      # preload [m]
Meq      = 0.05733      # equivalent mass [kg]
L        = 7.2e-3       # out-of-plane length [m]
E_star   = 217e9        # [Pa]

# ============================================================
# Temperature-dependent parameter tables
# ============================================================
ETA0_TABLE     = {60: 0.04496, 90: 0.01381, 110: 0.008155}    # Pa·s
ALPHA0_TABLE   = {60: 21e-9,   90: 16e-9,    110: 10e-9}      # Pa^-1
RHO0_TABLE     = {60: 887.0,   90: 858.44,   110: 840.0}      # kg/m^3
MU_B_TABLE     = {60: 0.12,    90: 0.11,     110: 0.10}
GAMMA_LIM_TABLE= {60: 0.07,    90: 0.06,     110: 0.06}       # 1/Pa
LAM_C_TABLE    = {60: 3.5e-6,  90: 3.0e-6,   110: 2.0e-6}
N_C_TABLE      = {60: 0.85,    90: 0.65,     110: 0.52}
PHI_IN_TABLE   = {60: 0.6,     90: 0.60,     110: 0.7}
ETA_INF_TABLE  = {60: 0.020,   90: 0.006,    110: 0.004}

BETA0_CONST    = 0.68
P0_HOUPERT     = 1.98e8
C_ROELANDS     = 5.1e-9
T_SHIFT        = 138.0

K_THERM_TABLE  = {60: 0.10, 90: 0.14, 110: 0.14}
GAMMA_TH_TABLE = {60: 3.5e-4, 90: 6.5e-4, 110: 6.5e-4}

if TEMP_C not in (60, 90, 110):
    raise ValueError("TEMP_C must be one of {60, 90, 110}.")

eta0      = ETA0_TABLE[TEMP_C]
alpha0    = ALPHA0_TABLE[TEMP_C]
rho0      = RHO0_TABLE[TEMP_C]
mu_b      = MU_B_TABLE[TEMP_C]
gamma_lim = GAMMA_LIM_TABLE[TEMP_C]
lam_c     = LAM_C_TABLE[TEMP_C]
n_c       = N_C_TABLE[TEMP_C]
PHI_IN    = PHI_IN_TABLE[TEMP_C]
eta_inf   = ETA_INF_TABLE[TEMP_C]
k_lub     = K_THERM_TABLE[TEMP_C]
gamma_th  = GAMMA_TH_TABLE[TEMP_C]

# ============================================================
# Greenwood–Tripp constants
# ============================================================
sigma_combined = 0.2e-6
beta_a         = sigma_combined/0.001
eta_R          = (0.05/(sigma_combined*beta_a))

# GT F_{3/2} lookup (pressure/load)
_gt_w = np.linspace(0.0, 8.0, 400)
_gt_w_pow = _gt_w**1.5
_gt_norm = np.sqrt(2.0*np.pi)
_lam_grid = np.linspace(0.0, 6.0, 360)
_kern = _gt_w_pow[None, :] * np.exp(-0.5 * (_lam_grid[:, None] + _gt_w) ** 2)
_F32_lookup = np.trapezoid(_kern, _gt_w, axis=1) / _gt_norm
_F32_lookup[-1] = 0.0

# ============================================================
# Houpert viscosity + DH density + ΔT (Karthikeyan-style) model
# ============================================================
def _houpert_params(eta0_local, T0_c, alpha0_local, beta0_local=BETA0_CONST):
    lneta0_plus = (np.log(max(eta0_local, 1e-16)) + 9.67)
    Z  = alpha0_local / (C_ROELANDS * lneta0_plus + 1e-30)
    S0 = beta0_local * (T0_c - T_SHIFT) / (lneta0_plus + 1e-30)
    return Z, S0, lneta0_plus

def _alpha_star(p, T_c, eta0_local, T0_c, Z, S0, lneta0_plus):
    p_eff = np.maximum(p, 0.0)
    temp_ratio = ((np.asarray(T_c, float) + 273.15) / (T0_c + 273.15 + 1e-30))
    return Z * np.exp(-S0 * (temp_ratio - 1.0)) / (1.0 + p_eff/P0_HOUPERT)

def deltaT_karthikeyan(Ve_local, h_local, p, a_local, eta_abs, k_lub_local, gamma_th_local, T0_c):
    # crude, stabilized flash-like estimate (kept for consistency; not used for traction)
    h_eff = np.maximum(h_local, 1e-12)
    Ve_eff= np.maximum(np.abs(Ve_local), 1e-9)
    tau_c = eta_abs * Ve_eff / h_eff
    qpp   = tau_c * Ve_eff
    dT    = (qpp * np.maximum(a_local,1e-12)) / (k_lub_local + 1e-30)
    dT    = np.clip(dT, -40.0, 180.0)
    return dT

def eta_houpert(p, T0_c, Ve_local, h_local, a_local):
    Z, S0, lneta0_plus = _houpert_params(eta0, T0_c, alpha0, BETA0_CONST)
    alpha_s = _alpha_star(p, T0_c, eta0, T0_c, Z, S0, lneta0_plus)
    eta_init = np.maximum(eta0 * np.exp(np.clip(alpha_s*np.maximum(p,0.0), -50.0, 50.0)), 1e-7)
    dT = deltaT_karthikeyan(Ve_local, h_local, p, a_local, eta_init, k_lub, gamma_th, T0_c)
    T_upd = T0_c + dT
    alpha_s2 = _alpha_star(p, T_upd, eta0, T0_c, Z, S0, lneta0_plus)
    eta_new = np.maximum(eta0 * np.exp(np.clip(alpha_s2*np.maximum(p,0.0), -50.0, 50.0)), 1e-7)
    return eta_new, dT

def rho_dowson_higginson(p, dT):
    p_eff = np.maximum(p, 0.0)
    frac = (1.0 + 0.6e-9 * p_eff) / (1.0 + 1.7e-9 * p_eff)
    therm = (1.0 - gamma_th * dT)
    return np.maximum(rho0 * frac * therm, 1.0)

def drho_dp_DH(p, dT):
    """
    Analytic ∂ρ/∂p for Dowson–Higginson with thermal factor held at current dT.
    ρ(p,dT) = ρ0 * [(1 + a p)/(1 + b p)] * (1 - γ_th dT)
    dρ/dp = ρ0 * ( (a(1+b p) - (1+a p)b) / (1+b p)^2 ) * (1 - γ_th dT)
    where a=0.6e-9, b=1.7e-9 [Pa^-1].
    """
    a = 0.6e-9
    b = 1.7e-9
    p_eff = np.maximum(p, 0.0)
    denom = (1.0 + b*p_eff)
    num   = a*denom - (1.0 + a*p_eff)*b
    dfrac = num / (denom*denom + 1e-30)
    return rho0 * dfrac * (1.0 - gamma_th * dT)

# ============================================================
# Shear-thinning (Carreau)
# ============================================================
def eta_carreau(etaN,h,gdot):
    h_eff = np.maximum(h,1e-12)
    gdot_eff = np.maximum(gdot, 1e-6)
    return np.maximum(eta_inf + (etaN-eta_inf)*(1.0 + (lam_c*gdot_eff)**2.0)**((n_c-1.0)/2.0), 1e-7)

# ============================================================
# Asperity pressure (Greenwood–Tripp)
# ============================================================
def asperity_pressure_greenwood_tripp(h):
    lam = np.maximum(np.asarray(h, float)/(sigma_combined + 1e-18), 0.0)
    lam_clipped = np.clip(lam, _lam_grid[0], _lam_grid[-1])
    F32 = np.interp(lam_clipped, _lam_grid, _F32_lookup)
    pref = (4.739075) * E_star * np.sqrt(sigma_combined/beta_a) * (beta_a *eta_R * sigma_combined)**2
    return (pref * F32).reshape(lam.shape)

# ============================================================
# Film seed (Hamrock–Dowson, line-contact)
# ============================================================
def central_film_thickness(R, W, Ve):
    R = float(np.clip(R, 1e-7, None))
    W = float(np.clip(W, 0.0, None))
    U = (eta0 * np.maximum(np.abs(Ve), 1e-9)) / (E_star * R + 1e-30)
    G = alpha0 * E_star
    Wn= W / (E_star * R * L + 1e-30)
    hc = 2.69 * (U**0.69) * (G**0.56) * (Wn**-0.10) * R
    return float(np.clip(hc, 5e-9, 600e-8))

# ============================================================
# Hertz (line contact, per unit length)
# ============================================================
def a_hertz(W, R):
    return np.sqrt(np.maximum(4.0*np.maximum(W,0.0)*np.maximum(R,1e-12),0.0)/(np.pi*E_star*L + 1e-30))
def ph_hertz(W, a):
    return 2.0*np.maximum(W,0.0)/(np.pi*np.maximum(a,1e-12)*L + 1e-30)

# ============================================================
# Elastic deflection (plane strain log-kernel)
# ============================================================
def elastic_deflection(x, p):
    N = len(x); dx = x[1]-x[0]
    eps = 0.9*dx
    u = np.zeros_like(x)
    for i in range(N):
        u[i] = np.sum(p * np.log(np.sqrt((x[i]-x)**2 + eps*eps))) * dx
    u = u * (2.0/(np.pi*E_star))
    u -= np.mean(u)
    return u

# ============================================================
# Rusanov advection (for ∂x(ρhU))
# ============================================================
def rusanov_div_bc(u, q, dx, q_in_left, q_in_right):
    N=len(q)
    qL = np.empty(N+1); qR = np.empty(N+1)
    qL[1:] = q; qR[:-1] = q
    qL[0] = q_in_left; qR[0] = q[0]
    qL[-1] = q[-1];     qR[-1] = q_in_right
    F = 0.5*(u*(qL + qR)) - 0.5*np.abs(u)*(qR - qL)
    return (F[1:] - F[:-1])/(dx + 1e-30)

# ============================================================
# TEXTURE MODEL (geometry only)
# ============================================================
w_texture = 35e-6       # [m]
g_val     = 1e-9        # [m]
x_start   = 0.0
X_in, X_out = -4.5, 3.0

D_TEXTURE = {"5%": 700e-6, "8%": 437.5e-6, "10%": 350e-6}
A_TEXTURE_CONST = 4e-6
TEXTURE_ZONE_MASK = np.ones_like(TH_DEG, dtype=bool)

def integrate_shift(Vs, w):
    dtheta = np.gradient(th)
    integrand = Vs/(w + 1e-30)
    shift = np.zeros_like(integrand)
    shift[1:] = np.cumsum(0.5*(integrand[1:] + integrand[:-1])*dtheta[1:])
    return shift

def htex_profile(x, a_theta, atex_theta, shift_theta, d_texture):
    if atex_theta <= 0.0 or a_theta <= 0.0: return np.zeros_like(x)
    u = ((x - x_start - shift_theta + d_texture/2.0) % d_texture) - d_texture/2.0
    expo = (np.log(g_val/atex_theta) * (u**2)) / (w_texture**2 + 1e-30)
    h = atex_theta*np.exp(expo)
    return np.where((x>=-a_theta)&(x<=a_theta), h, 0.0)

# ============================================================
# Flow-factor placeholders (Patir–Cheng); set to 1/0 for now
# ============================================================
def phi_x_func(h, sigma=sigma_combined):
    return np.ones_like(h)
def phi_s_func(h, sigma=sigma_combined):
    return np.zeros_like(h)

# ============================================================
# NEW: 1D Elrod–Adams Unsteady, Compressible, Mass-Conserving Reynolds with Cavitation
#        - Line contact
#        - Mixed lubrication (Greenwood–Tripp)
#        - Implicit Euler in time for transported mass g = theta * rho * h
#        - Central diffusion (implicit in p), upwind transport for g with Ve * ∂x g
# ============================================================
def _upwind_grad_q(q, dx, u, q_in_left, q_in_right):
    """First-order upwind gradient ∂x q with sign-aware one-sided boundary stencils."""
    dqdx = np.empty_like(q)
    if u >= 0.0:
        dqdx[0]  = (q[0] - q_in_left) / dx
        dqdx[1:] = (q[1:] - q[:-1]) / dx
    else:
        dqdx[:-1] = (q[1:] - q[:-1]) / dx
        dqdx[-1]  = (q_in_right - q[-1]) / dx
    return dqdx

def _solve_tridiag(a_sub, a_diag, a_sup, rhs):
    """Thomas algorithm for tridiagonal systems (arrays length N; sub[0] & sup[-1] unused)."""
    n = len(a_diag)
    c = a_sup.copy()
    d = a_diag.copy()
    b = a_sub.copy()
    y = rhs.copy()

    # forward elimination
    for i in range(1, n):
        m = b[i] / (d[i-1] + 1e-30)
        d[i]   -= m * c[i-1]
        y[i]   -= m * y[i-1]
    # back substitution
    x = np.zeros_like(y)
    x[-1] = y[-1] / (d[-1] + 1e-30)
    for i in range(n-2, -1, -1):
        x[i] = (y[i] - c[i]*x[i+1]) / (d[i] + 1e-30)
    return x

def _assemble_diffusion_p_tridiag(x, h, rho, eta_eff):
    """
    Assemble variable-coefficient diffusion operator for:
        ∂x [ (rho h^3 / (12 eta_eff)) ∂x p ] = RHS
    Dirichlet p=0 at both ends (enforced in matrix).
    Returns (a_sub, a_diag, a_sup) sized N for tridiagonal solve on p.
    """
    N  = len(x)
    dx = x[1]-x[0]
    h3 = np.maximum(h, 1e-12)**3
    M  = (rho * h3) / (12.0*np.maximum(eta_eff, 1e-7))  # mobility at cell centers
    # face averages
    Mw = np.empty(N); Me = np.empty(N)
    Mw[1:] = 0.5*(M[1:] + M[:-1]); Mw[0]  = M[0]
    Me[:-1]= 0.5*(M[:-1]+ M[1:]);  Me[-1] = M[-1]

    invdx2 = 1.0/(dx*dx + 1e-30)
    a_sub  = -Mw * invdx2     # below-diagonal (west)
    a_sup  = -Me * invdx2     # above-diagonal (east)
    a_diag = -(a_sub + a_sup) # center

    # Dirichlet p=0 at ends: set diagonal to 1 and off-diagonals to 0
    a_diag[0]  = 1.0; a_sup[0]  = 0.0
    a_diag[-1] = 1.0; a_sub[-1] = 0.0
    return a_sub, a_diag, a_sup

def _transport_g_implicit(x, dt, Ve, g_prev, g_cap, PHI_IN, rho0, h_seed):
    """
    Solve implicit Euler for transported mass g:
        (g^{n+1} - g^n)/dt + Ve * ∂x g^{n+1} = 0
    with one-sided upwind at boundaries using inflow seeds.
    Then enforce 0 <= g^{n+1} <= g_cap (g_cap = rho*h).
    """
    N  = len(x)
    dx = x[1]-x[0]
    u  = Ve

    # Build tridiagonal system for g^{n+1}
    a_sub = np.zeros(N)
    a_sup = np.zeros(N)
    a_diag= np.ones(N)/max(dt,1e-12)

    if u >= 0.0:
        # upwind: backward difference for interior, left boundary uses inflow
        a_diag[1:] +=  u/dx
        a_sub[1:]   = -u/dx
        # boundary at i=0 : (g0 - g_in)/dx term -> move g_in to RHS
        g_in_left = PHI_IN * rho0 * h_seed[0]
        rhs = g_prev/dt + np.concatenate(([u*g_in_left/dx], np.zeros(N-1)))
    else:
        # upwind: forward difference for interior, right boundary uses inflow
        a_diag[:-1] += -u/dx
        a_sup[:-1]   =  u/dx
        g_in_right = PHI_IN * rho0 * h_seed[-1]
        rhs = g_prev/dt + np.concatenate((np.zeros(N-1), [-u*g_in_right/dx]))

    g_new = _solve_tridiag(a_sub, a_diag, a_sup, rhs)
    # Cavitation bounds: 0 <= g <= rho*h
    return np.minimum(np.maximum(g_new, 0.0), g_cap)

def solve_theta(R, Ve, Vs, W, dt, angle_deg, rpm,
                atex_theta, shift_theta, d_texture,
                Nx=401, iters=30, newton_tol=1e-5,
                relax_p=0.85, relax_h=0.55, S_win=1.6, **_compat):
    """
    Robust 1D Elrod–Adams mixed lubrication Reynolds solver (unsteady, compressible, cavitating).
    - Keeps your variable names and outputs.
    - Time step dt provided by the caller .
    """

    # ---------- 1) Geometry, grid, seeds ----------
    R = float(max(R, 1e-12))
    W = float(max(W, 1e-9))
    a  = max(a_hertz(W, R), 1e-6)
    ph = max(ph_hertz(W, a), 1e3)

    # grid on physical x
    xL, xR = -S_win*a, S_win*a
    x  = np.linspace(xL, xR, int(Nx))
    dx = x[1] - x[0]

    # hamrock–dowson central seed + texture + initial elastic deflection
    h0   = central_film_thickness(R, W, Ve)
    htex = htex_profile(x, a, atex_theta, shift_theta, d_texture)
    # initial guess: flat deflection
    h_nom = np.maximum(h0 + x**2/(2*R) + htex, 1e-9)

    # initial saturation g^n (use full-film in the contact as a safe start)
    #   g = theta * rho * h ; in full film, theta=1 -> g = rho*h
    eta_tmp, dT_tmp = eta_houpert(np.zeros_like(x), TEMP_C, Ve, h_nom, a)
    rho_tmp         = rho_dowson_higginson(np.zeros_like(x), dT_tmp)
    g_prev          = rho_tmp * h_nom

    # ---------- 2) Newton outer loop ----------
    p = np.zeros_like(x)
    for it in range(max(2, iters)):
        # (a) elastic deflection from current p
        u_el  = elastic_deflection(x, p)
        h     = np.maximum(h0 + x**2/(2*R) + htex + u_el, 1e-9)

        # (b) material fields at current state
        eta_H, dT = eta_houpert(p, TEMP_C, Ve, h, a)
        rho       = rho_dowson_higginson(p, dT)
        # wall-shear rate for Carreau
        gdot_w    = np.maximum(np.abs(Vs)/np.maximum(h,1e-12), 1e-6)
        eta_eff   = eta_carreau(eta_H, h, gdot_w)

        # (c) implicit transport for g = theta * rho * h at n+1
        #     capacity cap: g_cap = rho*h (full-film upper bound)
        h_seed = np.maximum(h0 + x**2/(2*R) + htex, 5e-9)
        g_cap  = rho * h
        g_new  = _transport_g_implicit(x, dt, Ve, g_prev, g_cap, PHI_IN, rho0, h_seed)

        # (d) assemble diffusion operator for p^{n+1}
        a_sub, a_diag, a_sup = _assemble_diffusion_p_tridiag(x, h, rho, eta_eff)

        # RHS = ∂t g + Ve * ∂x g  evaluated at n+1 (we just solved g^{n+1})
        dgdt      = (g_new - g_prev) / max(dt, 1e-12)
        # upwind gradient for g^{n+1} with same inflow states used in transport
        if Ve >= 0.0:
            q_in_left  = PHI_IN * rho0 * h_seed[0]
            q_in_right = g_new[-1]  # outflow
        else:
            q_in_left  = g_new[0]
            q_in_right = PHI_IN * rho0 * h_seed[-1]
        dgdx = _upwind_grad_q(g_new, dx, Ve, q_in_left, q_in_right)
        RHS  = dgdt + Ve * dgdx

        # (e) solve for p^{n+1}
        # enforce Dirichlet at ends in RHS
        RHS[0]  = 0.0
        RHS[-1] = 0.0
        p_new = _solve_tridiag(a_sub, a_diag, a_sup, RHS)

        # (f) relaxation to damp Newton
        p = relax_p * p_new + (1.0 - relax_p) * p

        # (g) check convergence on pressure increment (L2 relative)
        num = np.linalg.norm(p_new - p, 2)
        den = np.linalg.norm(p_new, 2) + 1e-30
        if num/den < newton_tol:
            break
        g_prev = g_new

    # ---------- 3) Mixed lubrication load share ----------
    p = np.maximum(p, 0.0)  # cavitation floor by construction
    h = np.maximum(h, 1e-9)
    p_asp_raw = np.maximum(asperity_pressure_greenwood_tripp(h), 0.0)
    Wa_raw    = np.trapezoid(p_asp_raw, x) * L
    Wh        = np.trapezoid(p, x) * L
    deficit   = W - Wh
    if deficit > 1e-12 and Wa_raw > 1e-12:
        scale = np.clip(deficit/(Wa_raw + 1e-30), 0.0, 5.0)
        p_asp = p_asp_raw * scale
        Wa    = np.trapezoid(p_asp, x) * L
    elif deficit > 1e-12:
        p_asp = p_asp_raw
        Wa    = deficit
    else:
        p_asp = p_asp_raw
        Wa    = max(Wa_raw + min(deficit, 0.0), 0.0)

    # ---------- 4) Friction (same wall model; no traction hacks) ----------
    eta_w, _ = eta_houpert(p, TEMP_C, Ve, h, a)
    dpdx   = np.gradient(p, x)
    gdot_w = np.maximum(np.abs(Vs)/np.maximum(h,1e-12), 1e-6)
    eta_sh = eta_carreau(eta_w, h, gdot_w)
    tau_c  = eta_sh * np.maximum(np.abs(Vs),1e-9) / np.maximum(h,1e-12)
    tau_p  = 0.5 * np.maximum(h,1e-12) * np.abs(dpdx)
    tau_tot= tau_c + tau_p
    tau_lim= gamma_lim * p
    tau_eff= np.minimum(tau_tot, tau_lim)

    Fh = np.trapezoid(tau_eff, x) * L
    Fb = L * np.trapezoid(mu_b * p_asp, x)

    return {
        "x": x, "p": p, "h": h,
        "Fh": float(Fh), "Fb": float(Fb),
        "Wa": float(Wa), "a": float(a), "pmax": float(np.max(p)),
        "p_asp_x": p_asp
    }


# ============================================================
# KINEMATICS 
# ============================================================
def kin_arrays(rpm):
    R = np.maximum(rb + lift + d2lift_s, 1e-7)
    w = 2.0*np.pi*float(rpm)/60.0
    Vf = d2lift_s  * w
    Vc = (rb + lift + d2lift_s ) * w
    Ve = 0.5 * (Vc + Vf)
    Vs = Vc - Vf
    W = k_spring * (lift + delta) + Meq * (w**2) * d2lift_s
    return R, Ve, Vs, W, w

# ============================================================
# Plot controls
# ============================================================
def _as_list(v):
    return v if isinstance(v, (list, tuple, np.ndarray)) else [v]

PLOT_OPTS = {
    "PROFILES": {
        "PRESSURE": {
            "ENABLE": True,
            "angles_deg": [10],
            "rpms": [300],
            "surface_state": 0,         # 0 = UNTEXTURED, 1 = TEXTURED
            "texture_densities": [8],
        },
        "FILM": {
            "ENABLE": True,
            "angles_deg": [10],
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
    "SWEEPS": {
        "Fh": {"ENABLE": True, "angles_deg": None, "rpms": [300], "surface_state": 0, "texture_densities": [8],},
        "Fb": {"ENABLE": True, "angles_deg": None, "rpms": [300], "surface_state": 0, "texture_densities": [8],},
        "Torque": {"ENABLE": False, "angles_deg": None, "rpms": [300,500], "surface_state": 0, "texture_densities": [8],},
        "Wa": {"ENABLE": False, "angles_deg": None, "rpms": [300], "surface_state": 0, "texture_densities": [8],},
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
    "AVG_TORQUE": {"ENABLE": False, "rpms": [300, 500, 700, 900], "surface_state": 0, "texture_densities": [8],},
    "AVG_TORQUE_REDUCTION": {"ENABLE": False, "rpms": [300, 500,700,900], "densities_vs_UN": [5,8],},
    "HTEX_300RPM": {"ENABLE": False, "texture_densities": [5, 8, 10], "style": {"lw": 2.0, "grid_alpha": 0.35},},
    # ---------------- NEW: Single-variable vs angle (Ve, Vs, W, R, a_hertz, ph, hc, p_asp) ----------------
    "VARIABLE_BY_ANGLE": {
        "ENABLE": True,                 # set True to plot
        "variable": "p_asp",                # one of: "Ve","Vs","W","R","a_hertz","ph","hc","p_asp"
        "rpms": [300],                   # single RPM or list
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
}

def _dens_keys(nums):
    mapnum = {5: '5%', 8: '8%', 10: '10%'}
    if nums is None:
        return []
    out = [mapnum[n] for n in _as_list(nums) if n in mapnum]
    if len(out) == 0 and nums not in (None, []):
        raise ValueError("No valid texture densities given. Use any of 5, 8, 10.")
    return out

def _nearest_angle_index(angle_deg):
    return int(np.argmin(np.abs(TH_DEG - angle_deg)))

def _arm_at(angle_deg):
    j = _nearest_angle_index(angle_deg)
    return rb + lift_s[j]

def _torque(Fh, Fb, angle_deg):
    return (Fh + Fb) * _arm_at(angle_deg)

def _inputs_at(angle_deg, rpm, R, Ve, Vs, W):
    w = 2*np.pi*rpm/60.0
    j = _nearest_angle_index(angle_deg)
    dtheta = float(np.mean(np.diff(th)))
    dt = dtheta / (w + 1e-30)
    return dt, float(R[j]), float(Ve[j]), float(Vs[j]), float(W[j]), j

def _sweep_series_general(rpm, angle_list_deg, textured=False, density_key=None):
    angles = np.asarray(angle_list_deg, float)
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    Fh_list, Fb_list, Tq_list, Wa_list = [], [], [], []
    for ang in angles:
        dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
        if textured:
            atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
            dtex   = D_TEXTURE[density_key]
            sh_j   = float(shift[j])
        else:
            atex_j = 0.0
            dtex   = D_TEXTURE['5%']
            sh_j   = 0.0

        obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                          atex_theta=atex_j, shift_theta=sh_j,
                          d_texture=dtex,
                          Nx=171, iters=80, substep_cap=6,
                          relax_p=0.85, relax_h=0.55,
                          M_core=451, observe=True)
        Fh, Fb, Wa = float(obs["Fh"]), float(obs["Fb"]), float(obs["Wa"])
        Tq = _torque(Fh, Fb, ang)
        Fh_list.append(Fh); Fb_list.append(Fb); Tq_list.append(Tq); Wa_list.append(Wa)
    return angles, np.asarray(Fh_list), np.asarray(Fb_list), np.asarray(Tq_list), np.asarray(Wa_list)

# ============================================================
# A) Profiles — pressure & film
# ============================================================
def plot_profile_pressure():
    cfg = PLOT_OPTS["PROFILES"]["PRESSURE"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms   = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
            if textured:
                for dk in dens_keys:
                    atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                      atex_theta=atex_j, shift_theta=float(shift[j]),
                                      d_texture=D_TEXTURE[dk],
                                      Nx=171, iters=80, substep_cap=6,
                                      relax_p=0.85, relax_h=0.55,
                                      M_core=451, observe=True)
                    x, p, a = obs["x"], obs["p"], float(obs["a"])
                    X = x/max(a,1e-12)
                    plt.figure(dpi=dpi)
                    plt.plot(X, p, linewidth=lw,
                             label=f"{dk} | θ={ang:.1f}°, {rpm} RPM")
                    plt.xlabel("X = x/a"); plt.ylabel("p (Pa)")
                    plt.title("Reynolds pressure vs X")
                    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()
            else:
                obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                  atex_theta=0.0, shift_theta=0.0, d_texture=D_TEXTURE['5%'],
                                  Nx=171, iters=80, substep_cap=6,
                                  relax_p=0.85, relax_h=0.55,
                                  M_core=451, observe=True)
                x, p, a = obs["x"], obs["p"], float(obs["a"])
                X = x/max(a,1e-12)
                plt.figure(dpi=dpi)
                plt.plot(X, p, linewidth=lw,
                         label=f"UN | θ={ang:.1f}°, {rpm} RPM")
                plt.xlabel("X = x/a"); plt.ylabel("p (Pa)")
                plt.title("Reynolds pressure vs X")
                plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_profile_film():
    cfg = PLOT_OPTS["PROFILES"]["FILM"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms   = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
            if textured:
                for dk in dens_keys:
                    atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                      atex_theta=atex_j, shift_theta=float(shift[j]),
                                      d_texture=D_TEXTURE[dk],
                                      Nx=171, iters=80, substep_cap=6,
                                      relax_p=0.85, relax_h=0.55,
                                      M_core=451, observe=True)
                    x, h = obs["x"], obs["h"]
                    plt.figure(dpi=dpi)
                    plt.plot(x*1e3, h*1e9, linewidth=lw,
                             label=f"{dk} | h(x) | θ={ang:.1f}°, {rpm} RPM")
                    plt.xlabel("x (mm)"); plt.ylabel("h (nm)")
                    plt.title("Film thickness vs x")
                    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()
            else:
                obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                  atex_theta=0.0, shift_theta=0.0, d_texture=D_TEXTURE['5%'],
                                  Nx=171, iters=80, substep_cap=6,
                                  relax_p=0.85, relax_h=0.55,
                                  M_core=451, observe=True)
                x, h = obs["x"], obs["h"]
                plt.figure(dpi=dpi)
                plt.plot(x*1e3, h*1e9, linewidth=lw,
                         label=f"UN | h(x) | θ={ang:.1f}°, {rpm} RPM")
                plt.xlabel("x (mm)"); plt.ylabel("h (nm)")
                plt.title("Film thickness vs x")
                plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

# ============================================================
# B–E) Angle sweeps — preserved
# ============================================================
def _angles_for(cfg_angles):
    if cfg_angles is None:
        return TH_DEG.tolist()
    return _as_list(cfg_angles)

def plot_sweep_Fh():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Fh"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"]); rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Fh, linewidth=lw, label=f"Fh | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Fh, linewidth=lw, label=f"Fh | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Hydrodynamic friction Fh (N)")
    plt.title("Hydrodynamic friction vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Fb():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Fb"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"]); rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Fb, linewidth=lw, label=f"Fb | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Fb, linewidth=lw, label=f"Fb | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Asperity friction Fb (N)")
    plt.title("Asperity friction vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Torque():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Torque"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"]); rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Tq, linewidth=lw, label=f"T | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Tq, linewidth=lw, label=f"T | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Friction torque T (N·m)")
    plt.title("Friction torque vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Wa():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Wa"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"]); rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Wa, linewidth=lw, label=f"Wa | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Wa, linewidth=lw, label=f"Wa | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Asperity load Wa (N)")
    plt.title("Asperity load vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

# ============================================================
# F) Cycle-averaged torque & reductions — preserved
# ============================================================
def average_cycle_torque(rpm, angles_deg, textured=False, density_key=None):
    angles = np.asarray(angles_deg, float)
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    Tq = []
    for ang in angles:
        dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
        if textured:
            atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
            dtex   = D_TEXTURE[density_key]; sh_j = float(shift[j])
        else:
            atex_j = 0.0; dtex = D_TEXTURE['5%']; sh_j = 0.0
        obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                          atex_theta=atex_j, shift_theta=sh_j,
                          d_texture=dtex,
                          Nx=171, iters=80, substep_cap=6,
                          relax_p=0.85, relax_h=0.55,
                          M_core=451, observe=True)
        Tq.append(_torque(float(obs["Fh"]), float(obs["Fb"]), ang))
    return float(np.mean(Tq))

def section_avg_torque():
    cfg = PLOT_OPTS["AVG_TORQUE"]
    if not cfg["ENABLE"]:
        return
    rpms = _as_list(cfg["rpms"]); textured = bool(cfg.get("surface_state",0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                avgT = average_cycle_torque(rpm, TH_DEG, textured=True, density_key=dk)
                print(f"Avg torque at {rpm} RPM | {dk}: {avgT:.4f} N·m")
        else:
            avgT = average_cycle_torque(rpm, TH_DEG, textured=False)
            print(f"Avg torque at {rpm} RPM | UN: {avgT:.4f} N·m")

def section_avg_torque_reduction():
    cfg = PLOT_OPTS["AVG_TORQUE_REDUCTION"]
    if not cfg["ENABLE"]:
        return
    rpms = _as_list(cfg["rpms"]); dens_pair = cfg.get("densities_vs_UN",[5,8])
    for rpm in rpms:
        Tun = average_cycle_torque(rpm, TH_DEG, textured=False)
        for d in dens_pair:
            dk = {5:'5%',8:'8%',10:'10%'}[d]
            Tt = average_cycle_torque(rpm, TH_DEG, textured=True, density_key=dk)
            red = 100.0*(Tun - Tt)/(abs(Tun)+1e-12)
            print(f"{rpm} RPM: Torque reduction vs UN for {dk}: {red:.2f}%")

# ============================================================
# H) Single-variable vs cam angle (Ve, Vs, W, R, a_hertz, ph, hc, p_asp)
# ============================================================
def _variable_series(rpm, varname):
    varname = str(varname)
    valid = {"Ve","Vs","W","R","a_hertz","ph","hc","p_asp"}
    if varname not in valid:
        raise ValueError(f"VARIABLE_BY_ANGLE.variable must be one of {sorted(valid)}")

    R_arr, Ve_arr, Vs_arr, W_arr, w = kin_arrays(rpm)
    a_arr  = np.sqrt(np.maximum(4.0*np.maximum(W_arr,0.0)*np.maximum(R_arr,1e-12),0.0)/(np.pi*E_star*L + 1e-30))
    ph_arr = 2.0*np.maximum(W_arr,0.0)/(np.pi*np.maximum(a_arr,1e-12)*L + 1e-30)
    # Hamrock–Dowson seed (hc) and GT asperity pressure at center using hc:
    hc_arr = np.array([central_film_thickness(R_arr[i], W_arr[i], Ve_arr[i]) for i in range(len(R_arr))], dtype=float)
    p_asp_center = asperity_pressure_greenwood_tripp(hc_arr)  # scalar per angle (center film)

    mapping = {
        "Ve": Ve_arr,
        "Vs": Vs_arr,
        "W":  W_arr,
        "R":  R_arr,
        "a_hertz": a_arr,
        "ph": ph_arr,
        "hc": hc_arr,
        "p_asp": p_asp_center,
    }
    return TH_DEG, np.asarray(mapping[varname], dtype=float)

def plot_variable_by_angle():
    cfg = PLOT_OPTS["VARIABLE_BY_ANGLE"]
    if not cfg["ENABLE"]:
        return
    varname = cfg.get("variable", "Ve")
    style = cfg.get("style", {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120})
    lw, dpi, gA = style.get("lw", 2.0), style.get("dpi", 120), style.get("grid_alpha", 0.35)
    rpms = _as_list(cfg.get("rpms", [300]))

    ylabels = {
        "Ve": "Ve (m/s)",
        "Vs": "Vs (m/s)",
        "W":  "W (N)",
        "R":  "R (m)",
        "a_hertz": "a (m)",
        "ph": "p_h (Pa)",
        "hc": "h_c, seed (m)",
        "p_asp": "p_asp at center (Pa)",
    }
    plt.figure(dpi=dpi)
    for rpm in rpms:
        ang, y = _variable_series(rpm, varname)
        plt.plot(ang, y, linewidth=lw, label=f"{varname} | {rpm} RPM")
    plt.xlabel("Cam angle (deg)")
    plt.ylabel(ylabels.get(varname, varname))
    plt.title(f"{varname} vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

# ============================================================
# Master runner
# ============================================================
def run_all():
    plot_profile_pressure()
    plot_profile_film()
    #plot_htex_vs_angle_300rpm() 
    plot_sweep_Fh()
    plot_sweep_Fb()
    plot_sweep_Torque()
    plot_sweep_Wa()
    plot_variable_by_angle()
    section_avg_torque()
    section_avg_torque_reduction()
    plt.show()

# ----- Execute -----
if __name__ == "__main__":
    run_all()
