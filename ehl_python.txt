# ============================================================
# CAM–SHIM (Bucket Tappet) — 1D Mixed Lubrication line contact)
# ============================================================

import argparse
import os
from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from math import pi, ceil
from scipy.signal import savgol_filter, fftconvolve
plt.rcParams.update({"figure.dpi": 120})

HERE = Path(__file__).resolve().parent if "__file__" in globals() else Path.cwd()
DATA_DIR = "/content/cam"   
CAM_FILE = "updated_lift.txt"

# =======================
# USER: default test temperature (°C)
# =======================
DEFAULT_TEMP_C = 90  # valid options: 60, 90, 110
TEMP_C = DEFAULT_TEMP_C

def _load_cam(data_dir, fname):
    path = os.path.join(data_dir, fname)
    _cam = pd.read_csv(
        path, sep=r"\s+", engine="python", comment="#", header=None,
        names=["angle_deg", "lift_m"], usecols=[0, 1]
    )
    _cam["angle_deg"] = pd.to_numeric(_cam["angle_deg"], errors="raise")
    _cam["lift_m"]    = pd.to_numeric(_cam["lift_m"],    errors="raise")
    return _cam.sort_values("angle_deg").reset_index(drop=True)

CAM = _load_cam(DATA_DIR, CAM_FILE)
th_deg = CAM["angle_deg"].to_numpy(dtype=float)
th     = np.deg2rad(th_deg)
lift   = CAM["lift_m"].to_numpy(dtype=float)
TH_DEG = th_deg.copy()
lift_s = lift.copy()
dlift_s  = np.gradient(lift, th)           # dL/dθ
d2lift_s = np.gradient(dlift_s, th)

# ============================================================
# Materials / geometry / fluid (Fixed)
# ============================================================
rb       = 18.5e-3      # base circle radius [m]
k_spring = 7130.0       # spring rate [N/m]
delta    = 1.77e-3      # preload [m]
Meq      = 0.05733      # equivalent mass [kg]
L        = 7.2e-3       # out-of-plane length [m]
E_star   = 217e9        # [Pa]

# ============================================================
# Temperature-dependent parameter tables
# ============================================================
ETA0_TABLE     = {60: 0.04496, 90: 0.01381, 110: 0.008155}    # Pa·s
ALPHA0_TABLE   = {60: 21e-9,   90: 16e-9,    110: 10e-9}      # Pa^-1
RHO0_TABLE     = {60: 887.0,   90: 858.44,   110: 840.0}      # kg/m^3
MU_B_TABLE     = {60: 0.12,    90: 0.11,     110: 0.10}
GAMMA_LIM_TABLE= {60: 0.07,    90: 0.06,     110: 0.06}       # 1/Pa
LAM_C_TABLE    = {60: 3.5e-6,  90: 3.0e-6,   110: 2.0e-6}
N_C_TABLE      = {60: 0.85,    90: 0.65,     110: 0.52}
PHI_IN_TABLE   = {60: 0.6,     90: 0.60,     110: 0.7}
ETA_INF_TABLE  = {60: 0.020,   90: 0.006,    110: 0.004}

BETA0_CONST    = 0.68
P0_HOUPERT     = 1.98e8
C_ROELANDS     = 5.1e-9
T_SHIFT        = 138.0

K_THERM_TABLE  = {60: 0.10, 90: 0.14, 110: 0.14}
GAMMA_TH_TABLE = {60: 3.5e-4, 90: 6.5e-4, 110: 6.5e-4}

if TEMP_C not in (60, 90, 110):
    raise ValueError("TEMP_C must be one of {60, 90, 110}.")

eta0      = ETA0_TABLE[TEMP_C]
alpha0    = ALPHA0_TABLE[TEMP_C]
rho0      = RHO0_TABLE[TEMP_C]
mu_b      = MU_B_TABLE[TEMP_C]
gamma_lim = GAMMA_LIM_TABLE[TEMP_C]
lam_c     = LAM_C_TABLE[TEMP_C]
n_c       = N_C_TABLE[TEMP_C]
PHI_IN    = PHI_IN_TABLE[TEMP_C]
eta_inf   = ETA_INF_TABLE[TEMP_C]
k_lub     = K_THERM_TABLE[TEMP_C]
gamma_th  = GAMMA_TH_TABLE[TEMP_C]

# ============================================================
# Greenwood–Tripp constants 
# ============================================================
sigma_combined = 0.2e-6
beta_a         = sigma_combined/0.001
eta_R          = (0.05/(sigma_combined*beta_a))

# GT F_{3/2} lookup (pressure/load)
_gt_w = np.linspace(0.0, 8.0, 400)
_gt_w_pow = _gt_w**1.5
_gt_norm = np.sqrt(2.0*np.pi)
_lam_grid = np.linspace(0.0, 6.0, 360)
_kern = _gt_w_pow[None, :] * np.exp(-0.5 * (_lam_grid[:, None] + _gt_w) ** 2)
_F32_lookup = np.trapezoid(_kern, _gt_w, axis=1) / _gt_norm
_F32_lookup[-1] = 0.0

# ============================================================
# Houpert viscosity + DH density + ΔT model
# ============================================================
def _houpert_params(eta0_local, T0_c, alpha0_local, beta0_local=BETA0_CONST):
    lneta0_plus = (np.log(max(eta0_local, 1e-16)) + 9.67)
    Z  = alpha0_local / (C_ROELANDS * lneta0_plus + 1e-30)
    S0 = beta0_local * (T0_c - T_SHIFT) / (lneta0_plus + 1e-30)
    return Z, S0, lneta0_plus

def _alpha_star(p, T_c, eta0_local, T0_c, Z, S0, lneta0_plus):
    p_eff = np.maximum(p, 0.0)
    temp_ratio = ((np.asarray(T_c, float) - T_SHIFT) /
                  (T0_c - T_SHIFT + 1e-30))
    temp_factor = np.power(np.maximum(temp_ratio, 1e-12), -S0)
    press_factor = np.power(1.0 + p_eff / P0_HOUPERT, Z)
    numer = lneta0_plus * (temp_factor * press_factor - 1.0)
    return numer / (p_eff + 1e-30)

def deltaT_karthikeyan(u_av, h, p, a, eta_abs, k_l, gamma_c, T_c):
    h_eff = np.maximum(h, 1e-12)
    a_eff = np.maximum(a, 1e-12)
    u_abs = np.abs(u_av)
    num = u_abs * T_c * gamma_c * h_eff * np.maximum(p, 0.0) + 2.0 * a_eff * (np.maximum(eta_abs, 1e-7)**2) / h_eff
    den = a_eff * k_l / h_eff - u_abs * gamma_c * h_eff * np.maximum(p, 0.0)
    den = np.where(np.abs(den) < 1e-9, np.sign(den)*1e-9, den)
    dT = num / den
    return np.clip(dT, -40.0, 180.0)

def eta_houpert(p, T0_c, Ve_local, h_local, a_local):
    Z, S0, lneta0_plus = _houpert_params(eta0, T0_c, alpha0, BETA0_CONST)
    # First pass at T0_c
    alpha_s = _alpha_star(p, T0_c, eta0, T0_c, Z, S0, lneta0_plus)
    eta_init = np.maximum(eta0 * np.exp(np.clip(alpha_s*np.maximum(p,0.0), -50.0, 50.0)), 1e-7)
    # Use ABSOLUTE viscosity (Pa·s) in ΔT model
    dT = deltaT_karthikeyan(Ve_local, h_local, p, a_local, eta_init, k_lub, gamma_th, T0_c)
    T_upd = T0_c + dT
    # Second pass at updated temperature
    alpha_s2 = _alpha_star(p, T_upd, eta0, T0_c, Z, S0, lneta0_plus)
    eta_new = np.maximum(eta0 * np.exp(np.clip(alpha_s2*np.maximum(p,0.0), -50.0, 50.0)), 1e-7)
    return eta_new, dT

def rho_dowson_higginson(p, dT):
    p_eff = np.maximum(p, 0.0)
    frac = (1.0 + 0.6e-9 * p_eff) / (1.0 + 1.7e-9 * p_eff)
    therm = (1.0 - gamma_th * dT)
    return np.maximum(rho0 * frac * therm, 1.0)

def drho_dp_numeric(p, dT, Ve_local, h_local, a_local):
    dp = 1.0e3
    p_lo = np.maximum(p - dp, 0.0)
    p_hi = p + dp
    eta_lo, dT_lo = eta_houpert(p_lo, TEMP_C, Ve_local, h_local, a_local)
    eta_hi, dT_hi = eta_houpert(p_hi, TEMP_C, Ve_local, h_local, a_local)
    rho_lo = rho_dowson_higginson(p_lo, dT_lo)
    rho_hi = rho_dowson_higginson(p_hi, dT_hi)
    return (rho_hi - rho_lo) / (2.0*dp + 1e-30)

# ============================================================
# Shear-thinning (Carreau)
# ============================================================
def eta_carreau(etaN,h,gdot):
    h_eff = np.maximum(h,1e-12)
    gdot_eff = np.maximum(gdot, 1e-6)
    return np.maximum(eta_inf + (etaN-eta_inf)*(1.0 + (lam_c*gdot_eff)**2.0)**((n_c-1.0)/2.0), 1e-7)

# ============================================================
# Asperity pressure (Greenwood–Tripp)
# ============================================================
def asperity_pressure_greenwood_tripp(h):
    lam = np.maximum(np.asarray(h, float)/(sigma_combined + 1e-18), 0.0)
    lam_clipped = np.clip(lam, _lam_grid[0], _lam_grid[-1])
    F32 = np.interp(lam_clipped, _lam_grid, _F32_lookup)
    pref = (4.739075) * E_star * np.sqrt(sigma_combined/beta_a) * (beta_a *eta_R * sigma_combined)**2
    return (pref * F32).reshape(lam.shape)

# ============================================================
# Film seed (Hamrock–Dowson, line-contact 
# ============================================================
def central_film_thickness(R, W, Ve):
    R = float(np.clip(R, 1e-7, None))
    W = float(np.clip(W, 0.0, None))
    U = (eta0 * np.abs(Ve))/(E_star * R + 1e-30)
    G = alpha0 * E_star
    W_star = W / (E_star * L * R + 1e-30)
    hc = 3.06 * (U**0.69) * (G**0.56) * (W_star**-0.1) * R
    return float(np.clip(hc, 5e-9, 600e-8))

# ============================================================
# KINEMATICS (lift smoothing, curvature, speeds, load)
# ============================================================
def kin_arrays(rpm):
    R = np.maximum(rb + lift + d2lift_s, 1e-7)
    w = 2.0*np.pi*float(rpm)/60.0
    Vf = d2lift_s  * w
    Vc = (rb + lift + d2lift_s ) * w
    Ve = 0.5 * (Vc + Vf)
    Vs = Vc - Vf
    W = k_spring * (lift + delta) + Meq * (w**2) * d2lift_s 
    return R, Ve, Vs, W, w

# ============================================================
# Hertz line-contact — ***FIXED*** half-width formula
# ============================================================
def a_hertz(W,R):
    return np.sqrt( np.maximum(4.0*np.maximum(W,1e-9)*np.maximum(R,1e-12),0.0)/(np.pi*E_star*L + 1e-30) )

def ph_hertz(W,a):
    return 2.0*np.maximum(W,0.0)/(np.pi*np.maximum(a,1e-12)*L + 1e-30)

# ============================================================
# Elastic deflection (plane strain log-kernel) 
# ============================================================
def elastic_deflection(x, p):
    x = np.asarray(x, float)
    p = np.asarray(p, float)
    N = len(x)
    if N <= 1:
        return np.zeros_like(x)

    dx = x[1] - x[0]
    eps = 0.9 * dx
    grid = (np.arange(-N + 1, N, dtype=float)) * dx
    kernel = np.log(np.sqrt(grid * grid + eps * eps))
    conv = fftconvolve(p, kernel, mode="same") * dx
    u = conv * (2.0 / (np.pi * E_star))
    u -= np.mean(u)
    return u

# ============================================================
# Rusanov advection (for ∂x(ρhU))
# ============================================================
def rusanov_div_bc(u, q, dx, q_in_left, q_in_right):
    N=len(q)
    qL = np.empty(N+1); qR = np.empty(N+1)
    qL[1:] = q; qR[:-1] = q
    qL[0] = q_in_left; qR[0] = q[0]
    qL[-1] = q[-1];     qR[-1] = q_in_right

    # Rusanov flux for f(q) = u*q
    F = 0.5*(u*(qL + qR)) - 0.5*np.abs(u)*(qR - qL)
    return (F[1:] - F[:-1])/(dx + 1e-30)

def rusanov_dqdx_bc(q, dx, q_in_left, q_in_right, alpha=1.0):
    N = len(q)
    qL = np.empty(N+1); qR = np.empty(N+1)
    # interior reconstructions
    qL[1:] = q;       qR[:-1] = q
    # ghost boundaries
    qL[0]  = q_in_left;   qR[0]  = q[0]
    qL[-1] = q[-1];       qR[-1] = q_in_right
    # Rusanov flux for f(q)=q with wavespeed alpha

    # Rusanov flux for f(q) = u*q
    F = 0.5*(qL + qR) - 0.5*alpha*(qR - qL)
    return (F[1:] - F[:-1])/(dx + 1e-30)

# ============================================================
# TEXTURE MODEL
# ============================================================
w_texture = 35e-6       # [m] 
g_val     = 1e-9        # [m]
x_start   = 0.0
X_in, X_out = -4.5, 3.0

D_TEXTURE = {"5%": 700e-6, "8%": 437.5e-6, "10%": 350e-6}
A_TEXTURE_CONST = 4e-6     
TEXTURE_ZONE_MASK = np.ones_like(TH_DEG, dtype=bool)

def integrate_shift(Vs, w):
    dtheta = np.gradient(th)
    integrand = Vs/(w + 1e-30)
    shift = np.zeros_like(integrand)
    shift[1:] = np.cumsum(0.5*(integrand[1:] + integrand[:-1])*dtheta[1:])
    return shift

def htex_profile(x, a_theta, atex_theta, shift_theta, d_texture):
    if atex_theta <= 0.0 or a_theta <= 0.0:
        return np.zeros_like(x)

    # Periodic pocket centers with pitch d_texture
    u = ((x - x_start - shift_theta + d_texture / 2.0) % d_texture) - d_texture / 2.0
    expo = np.log(g_val / atex_theta) * (4.0 * u**2) / (w_texture**2 + 1e-30)
    h = atex_theta * np.exp(expo)

    return np.where((x >= -a_theta) & (x <= a_theta), h, 0.0)


# ============================================================
# Flow-factor placeholders (Patir–Cheng); set to 1/0 for now
# ============================================================
def phi_x_func(h, sigma=sigma_combined):
    return np.ones_like(h)

def phi_s_func(h, sigma=sigma_combined):
    return np.zeros_like(h)
# ============================================================
# CORE SOLVER (per cam angle): mass-conserving Reynolds solver
# ============================================================

def _clamp01(z):
    return np.minimum(1.0, np.maximum(0.0, z))

def solve_theta(R, Ve, Vs, W, dt, angle_deg, rpm,
                atex_theta, shift_theta, d_texture,
                Nx=171, iters=80, substep_cap=6, relax_p=0.75, relax_h=0.55,
                M_core=451, observe=True):

    CFL_TARGET = 0.4

    # ---------------- Geometry & scales ----------------
    R = float(max(R, 1e-12))
    W = float(max(W, 1e-6))
    a  = max(a_hertz(W, R), 1e-6)    # Hertz half-width
    ph = max(ph_hertz(W, a), 1e3)    # Hertz peak pressure scale

    h_floor = 1.0e-9                # min physical film to avoid division by 0
    gdot_max  = 1.0e8               # cap on shear rate [1/s]
    D_cap     = 1.0e14              # cap on mobility (dimensionless-ish)

    # ---------------- Extended window on x ----------------
    xL, xR = X_in * a, X_out * a
    x  = np.linspace(xL, xR, int(max(Nx, 171)))
    dx = x[1] - x[0]
    X  = x / a                       # non-dimensional coordinate on extended window

    # ---------------- Contact core grid (pressure unknown) ----------------
    # STRICT core: X ∈ [-1, +1]
    s  = np.linspace(-1.0, +1.0, int(M_core))   # "s" is X on the core
    xs = a * s                                  # dimensional positions of core nodes
    dS = s[1] - s[0]

    # ---------------- Base seeds ----------------
    h0   = central_film_thickness(R, W, Ve)     # Hamrock–Dowson central film
    htex = htex_profile(x, a, atex_theta, shift_theta, d_texture)

    # Zero-mean the texture within the loaded region |x| <= a, then cap positive peaks
    if atex_theta > 0.0:
        mask_loaded = (x >= -a) & (x <= a)
        mean_htex = np.mean(htex[mask_loaded]) if np.any(mask_loaded) else 0.0
        htex = htex - mean_htex
        htex = np.minimum(htex, 3.0 * h0)

    # Initial film guess (parabolic geometry + texture, no deflection yet)
    h = np.maximum(h0 + x**2 / (2.0 * R) + htex, h_floor)

    # Nominal film used for squeeze derivative in first substep
    h_nom_prev = h.copy()

    # Initial pressure on core: Hertz-type ND seed, scaled by ph
    P0 = np.sqrt(np.maximum(1.0 - s**2, 0.0))
    p_core = ph * P0  # dimensional pressure at core nodes

    # Helper: embed core pressure p_core(s) → p(x) on extended window (zero outside |X|<=1)
    def embed_p(p_core_vec):
        p_full = np.zeros_like(x)
        inside = (X >= -1.0) & (X <= +1.0)
        if inside.any():
            p_vals = np.interp(x[inside], xs, np.maximum(p_core_vec, 0.0))
            p_full[inside] = p_vals
        return p_full

    # Substep control (for advection CFL)
    u1_local = abs(Ve)
    cfl  = u1_local * dt / (dx + 1e-30)
    base_needed = int(max(2, np.ceil(cfl / CFL_TARGET)))
    if substep_cap is None:
        total_substeps = base_needed
    else:
        max_substeps = max(2, int(substep_cap))
        if base_needed <= max_substeps:
            total_substeps = base_needed
        else:
            batches = int(np.ceil(base_needed / max_substeps))
            total_substeps = batches * max_substeps
    total_substeps = max(total_substeps, 2)
    dts  = dt / float(total_substeps)

    # Previous pressure for dp/dt and film-fraction (Elrod–Adams)
    p_prev = embed_p(p_core).copy()
    theta  = np.ones_like(x)  # film fraction θ (1=full film, 0=cavitated)

    # ------------- Substep loop (inner Reynolds + cavitation) -------------
    for _sub in range(total_substeps):

        # Current embedded pressure & elastic deflection
        p_embed = embed_p(p_core)
        defl_sub = elastic_deflection(x, p_embed)

        # Nominal film for Reynolds / rheology (geometry + deflection + texture)
        # NOTE: no rigid approach here; this keeps the PDE well-posed.
        h_nom = np.maximum(h0 + x**2 / (2.0 * R) + defl_sub + htex, h_floor)
        dhdt  = (h_nom - h_nom_prev) / max(dts, 1e-12)
        h_nom_prev = h_nom.copy()

        # --- Rheology & density ---
        eta_dim, dT_field = eta_houpert(p_embed, TEMP_C, Ve, h_nom, a)
        rho_dim = rho_dowson_higginson(p_embed, dT_field)
        drdp    = drho_dp_numeric(p_embed, dT_field, Ve, h_nom, a)
        phi_x   = phi_x_func(h_nom)

        # --- Effective viscosity for mobility (Carreau) ---
        dpdx     = np.gradient(p_embed, x)
        gdot_p   = np.abs(0.5 * np.maximum(h_nom, 1e-12) * np.abs(dpdx) / (eta_dim + 1e-30))
        gdot_eff = np.sqrt(
            (np.maximum(np.abs(Vs), 1e-6) / np.maximum(h_nom, 1e-12))**2
            + gdot_p**2
        )
        gdot_eff = np.minimum(gdot_eff, gdot_max)  # clamp shear rate
        eta_eff_Re = eta_carreau(eta_dim, h_nom, gdot_eff)

        # --- Mass-conserving cavitation (Elrod–Adams) ---
        theta = _clamp01(theta)

        # Mobility D for ND operator (in terms of X = x/a, P = p/ph)
        # We keep exactly your original scaling to preserve magnitudes:
        # ∂X(D_full ∂X P) ≈ RHS_full, with P = p/ph.
        D_full = (
            phi_x * (h_nom**3) * rho_dim * ph * theta
            / (12.0 * eta_eff_Re * (a**2) + 1e-30)
        )
        D_full = np.clip(D_full, 0.0, D_cap)

        # Advected mass is ρ h θ
        q = rho_dim * np.maximum(h_nom, 1e-12) * theta
        u = Ve

        # Inflow states (full film at bulk density) for Rusanov
        h_nom_seed = np.maximum(h0 + x**2 / (2.0 * R) + htex, h_floor)
        h_left, h_right = h_nom_seed[0], h_nom_seed[-1]
        if u >= 0.0:
            q_in_left  = PHI_IN * rho0 * h_left * 1.0  # θ=1 at inlet
            q_in_right = q[-1]
        else:
            q_in_left  = q[0]
            q_in_right = PHI_IN * rho0 * h_right * 1.0

        # Conservative advection of mass ρ h θ (Rusanov divergence)
        term_adv = rusanov_div_bc(u, q, dx, q_in_left, q_in_right)

        # Compressible squeeze with θ:
        # ∂t(ρ h θ) = ρ θ ∂t h + h θ ∂ρ/∂p ∂t p
        dpdt_embed   = (p_embed - p_prev) / max(dts, 1e-12)
        term_squeeze = (rho_dim * theta * dhdt + h_nom * theta * drdp * dpdt_embed)

        # ⚠ SIGN: we keep your original convention here, because rusanov_div_bc
        # already encodes the divergence direction. Changing sign there gave
        # you massive pressure spikes.
        RHS_full = term_adv + term_squeeze

        # Map to core (|X|<=1) and assemble diffusion operator on s-grid
        D_core   = np.interp(xs, x, D_full)
        RHS_core = np.interp(xs, x, RHS_full)

        M = len(xs)
        A = np.zeros(M); B = np.zeros(M); C = np.zeros(M); RHS = np.zeros(M)
        invdS2 = 1.0 / (dS * dS + 1e-30)

        # Boundary: P = 0 at X = ±1 (i.e. p = 0 there)
        B[0] = 1.0; RHS[0] = 0.0
        for j in range(1, M - 1):
            Dw = 0.5 * (D_core[j] + D_core[j - 1])
            De = 0.5 * (D_core[j] + D_core[j + 1])
            A[j] = -Dw * invdS2
            C[j] = -De * invdS2
            B[j] = -(A[j] + C[j]) + 1e-12
            RHS[j] = RHS_core[j]
        B[M - 1] = 1.0; RHS[M - 1] = 0.0

        # Thomas solve on core for P_new (non-dimensional)
        # We solve A * (P_new) = RHS in ND form, then convert to dimensional p_core.
        for j in range(1, M):
            wfac = A[j] / (B[j - 1] + 1e-30)
            B[j]   -= wfac * C[j - 1]
            RHS[j] -= wfac * RHS[j - 1]
        P_new = np.zeros(M)
        P_new[-1] = RHS[-1] / (B[-1] + 1e-30)
        for j in range(M - 2, -1, -1):
            P_new[j] = (RHS[j] - C[j] * P_new[j + 1]) / (B[j] + 1e-30)

        # Non-negative pressure (Elrod–Adams)
        P_new = np.maximum(P_new, 0.0)
        p_tmp = embed_p(P_new * ph)  # dimensional p(x)

        # ---- Elrod–Adams complementarity: θ update ----
        full_mask = (p_tmp > 0.0)
        cav_mask  = ~full_mask

        theta[full_mask] = 1.0

        # In cavitated zones (p=0): ∂t(ρ h θ) + ∂x(u ρ h θ) = 0
        den_cav = (rho_dim[cav_mask] * np.maximum(h_nom[cav_mask], 1e-12) + 1e-30)
        theta[cav_mask] = _clamp01(
            theta[cav_mask]
            - dts * (
                term_adv[cav_mask] / den_cav
                + theta[cav_mask] * (rho_dim[cav_mask] * dhdt[cav_mask]) / den_cav
            )
        )

        # ---- Gentle hydrodynamic load relaxation (amplitude only) ----
        # Use Greenwood–Tripp on *current h_nom* for asperity load; then adjust
        # hydrodynamic pressure amplitude so (Wa + Wh) ≈ W without distorting shape.
        p_asp_sub = asperity_pressure_greenwood_tripp(np.maximum(h_nom, h_floor))
        Wa_sub = np.trapezoid(p_asp_sub, x) * L
        Wh_sub = np.trapezoid(p_tmp, x) * L
        total_load = Wa_sub + Wh_sub

        if total_load > 1e-18:
            # Target hydrodynamic load given asperity load
            Wh_target = max(W - Wa_sub, 0.0)
            if Wh_sub > 1e-18:
                s_relax_raw = Wh_target / (Wh_sub + 1e-30)
                # Limit how much we scale in one go to avoid explosions
                s_relax = np.clip(s_relax_raw, 0.25, 4.0)
                P_new *= s_relax
                p_tmp = embed_p(P_new * ph)

        # ---- Relaxation of the ND pressure on core ----
        P_old = p_core / ph  # previous ND pressure
        P_core_relaxed = (1.0 - relax_p) * P_old + relax_p * P_new
        # mild smoothing
        Ptmp = P_core_relaxed.copy()
        if len(P_core_relaxed) >= 3:
            P_core_relaxed[1:-1] = (
                0.025 * Ptmp[:-2] + 0.95 * Ptmp[1:-1] + 0.025 * Ptmp[2:]
            )
        P_core_relaxed[0]  = 0.0
        P_core_relaxed[-1] = 0.0

        p_core = P_core_relaxed * ph
        p_prev = embed_p(p_core).copy()

        # ---- Update film with elasticity at the *current* pressure ----
        defl  = elastic_deflection(x, p_prev)
        h_candidate = np.maximum(h0 + x**2 / (2.0 * R) + defl + htex, h_floor)
        h = np.maximum(relax_h * h + (1.0 - relax_h) * h_candidate, h_floor)

    # ---------------- Final fields on extended window ----------------
    p = embed_p(p_core)
    defl_final = elastic_deflection(x, p)
    h = np.maximum(h0 + x**2 / (2.0 * R) + defl_final + htex, h_floor)

    # Mixed load split: Greenwood–Tripp asperity + hydrodynamic (no extra scaling)
    p_asp_final = asperity_pressure_greenwood_tripp(h)
    Wa_final = np.trapezoid(p_asp_final, x) * L
    Wh_now = np.trapezoid(p, x) * L
    W_total_final = Wa_final + Wh_now  # for diagnostics if you want to print/log

    # Friction (hydrodynamic + boundary)
    eta_w, _dT_f = eta_houpert(p, TEMP_C, Ve, h, a)
    dpdx   = np.gradient(p, x)
    gdot_wall = np.maximum(np.abs(Vs) / np.maximum(h, 1e-12), 1e-6)
    gdot_wall = np.minimum(gdot_wall, gdot_max)
    eta_w_sh  = eta_carreau(eta_w, h, gdot_wall)

    tau_c  = np.where(h > 1e-12, eta_w_sh * Vs / h, 0.0)
    tau_p  = 0.5 * h * dpdx
    tau_tot = tau_c + tau_p

    tau_lim = gamma_lim * np.maximum(p, 0.0)
    tau_eff = np.clip(tau_tot, -tau_lim, tau_lim)

    Fh = np.trapezoid(tau_eff, x) * L
    Fb = L * np.trapezoid(mu_b * p_asp_final, x)

    return {
        "x": x, "X": X, "p": p, "h": h,
        "Fh": float(Fh), "Fb": float(Fb),
        "Wa": float(Wa_final), "a": float(a),
        "pmax": float(np.max(p)),
        "p_asp_x": p_asp_final
    }

#============================================================
# PLOT CONTROLLER & UTILITIES 
# ============================================================
def _as_list(v):
    return list(v) if isinstance(v, (list, tuple, np.ndarray)) else [v]

PLOT_OPTS = {
    "PROFILES": {
        "PRESSURE": {
            "ENABLE": True,
            "angles_deg": [10],
            "rpms": [300],
            "surface_state": 0,         # 0 = UNTEXTURED, 1 = TEXTURED
            "texture_densities": [8],
        },
        "FILM": {
            "ENABLE": True,
            "angles_deg": [10],
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        # New: asperity pressure vs X = x/a (same controls as Reynolds pressure)
        "ASPERITY": {
            "ENABLE": True,
            "angles_deg": [10],
            "rpms": [300],
            "surface_state": 0,         # 0 = UNTEXTURED, 1 = TEXTURED
            "texture_densities": [8],
        },
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
    "SWEEPS": {
        "Fh": {
            "ENABLE": True,
            "angles_deg": None,
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        "Fb": {
            "ENABLE": True,
            "angles_deg": None,
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        "Torque": {
            "ENABLE": False,
            "angles_deg": None,
            "rpms": [300, 500],
            "surface_state": 0,
            "texture_densities": [8],
        },
        "Wa": {
            "ENABLE": False,
            "angles_deg": None,
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
    "AVG_TORQUE": {
        "ENABLE": False,
        "rpms": [300, 500, 700, 900],
        "surface_state": 0,
        "texture_densities": [8],
    },
    "AVG_TORQUE_REDUCTION": {
        "ENABLE": False,
        "rpms": [300],
        "densities_vs_UN": [5],
    },
    "HTEX_300RPM": {
        "ENABLE": False,
        "texture_densities": [5, 8, 10],
        "style": {"lw": 2.0, "grid_alpha": 0.35},
    },
    # ---------------- Single-variable vs angle (Ve, Vs, W, R, a_hertz, ph, hc) ----------------
    "VARIABLE_BY_ANGLE": {
        "ENABLE": False,                 # set True to plot
        "variable": "Ve",               # one of: "Ve","Vs","W","R","a_hertz","ph","hc"
        "rpms": [300],                  # single RPM or list
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
}

def _dens_keys(nums):
    mapnum = {5: "5%", 8: "8%", 10: "10%"}
    if nums is None:
        return []
    out = [mapnum[n] for n in _as_list(nums) if n in mapnum]
    if len(out) == 0 and nums not in (None, []):
        raise ValueError("No valid texture densities given. Use any of 5, 8, 10.")
    return out

def _nearest_angle_index(angle_deg):
    return int(np.argmin(np.abs(TH_DEG - angle_deg)))

def _arm_at(angle_deg):
    j = _nearest_angle_index(angle_deg)
    return rb + lift_s[j]

def _torque(Fh, Fb, angle_deg):
    return (Fh + Fb) * _arm_at(angle_deg)

def _inputs_at(angle_deg, rpm, R, Ve, Vs, W):
    w = 2 * np.pi * rpm / 60.0
    j = _nearest_angle_index(angle_deg)
    dtheta = float(np.mean(np.diff(th)))
    dt = dtheta / (w + 1e-30)
    return dt, float(R[j]), float(Ve[j]), float(Vs[j]), float(W[j]), j

def _sweep_series_general(rpm, angle_list_deg, textured=False, density_key=None):
    angles = np.asarray(angle_list_deg, float)
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    Fh_list, Fb_list, Tq_list, Wa_list = [], [], [], []
    for ang in angles:
        dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
        if textured:
            atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
            dtex = D_TEXTURE[density_key]
            sh_j = float(shift[j])
        else:
            atex_j = 0.0
            dtex = D_TEXTURE["5%"]  # unused in UN but kept for call-compat
            sh_j = 0.0

        obs = solve_theta(
            Rj,
            Vej,
            Vsj,
            Wj,
            dt,
            ang,
            rpm,
            atex_theta=atex_j,
            shift_theta=sh_j,
            d_texture=dtex,
            Nx=171,
            iters=80,
            substep_cap=6,
            relax_p=0.85,
            relax_h=0.55,
            M_core=451,
            observe=True,
        )
        Fh, Fb, Wa = float(obs["Fh"]), float(obs["Fb"]), float(obs["Wa"])
        Tq = _torque(Fh, Fb, ang)
        Fh_list.append(Fh)
        Fb_list.append(Fb)
        Tq_list.append(Tq)
        Wa_list.append(Wa)
    return (
        angles,
        np.asarray(Fh_list),
        np.asarray(Fb_list),
        np.asarray(Tq_list),
        np.asarray(Wa_list),
    )

# ============================================================
# A) Profiles — pressure & film & asperity pressure
# ============================================================
def plot_profile_pressure():
    cfg = PLOT_OPTS["PROFILES"]["PRESSURE"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = (
        _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    )

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(
                ang, rpm, R, Ve, Vs, W
            )
            if textured:
                for dk in dens_keys:
                    atex_j = (
                        A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    )
                    obs = solve_theta(
                        Rj,
                        Vej,
                        Vsj,
                        Wj,
                        dt,
                        ang,
                        rpm,
                        atex_theta=atex_j,
                        shift_theta=float(shift[j]),
                        d_texture=D_TEXTURE[dk],
                        Nx=171,
                        iters=80,
                        substep_cap=6,
                        relax_p=0.85,
                        relax_h=0.55,
                        M_core=451,
                        observe=True,
                    )
                    x, p, a = obs["x"], obs["p"], float(obs["a"])
                    X = x / max(a, 1e-12)
                    plt.figure(dpi=dpi)
                    plt.plot(
                        X,
                        p,
                        linewidth=lw,
                        label=f"{dk} | θ={ang:.1f}°, {rpm} RPM",
                    )
                    plt.xlabel("X = x/a")
                    plt.ylabel("p (Pa)")
                    plt.title("Reynolds pressure vs X")
                    plt.grid(True, alpha=gA)
                    plt.legend()
                    plt.tight_layout()
            else:
                obs = solve_theta(
                    Rj,
                    Vej,
                    Vsj,
                    Wj,
                    dt,
                    ang,
                    rpm,
                    atex_theta=0.0,
                    shift_theta=0.0,
                    d_texture=D_TEXTURE["5%"],
                    Nx=171,
                    iters=80,
                    substep_cap=6,
                    relax_p=0.85,
                    relax_h=0.55,
                    M_core=451,
                    observe=True,
                )
                x, p, a = obs["x"], obs["p"], float(obs["a"])
                X = x / max(a, 1e-12)
                plt.figure(dpi=dpi)
                plt.plot(
                    X,
                    p,
                    linewidth=lw,
                    label=f"UN | θ={ang:.1f}°, {rpm} RPM",
                )
                plt.xlabel("X = x/a")
                plt.ylabel("p (Pa)")
                plt.title("Reynolds pressure vs X")
                plt.grid(True, alpha=gA)
                plt.legend()
                plt.tight_layout()

def plot_profile_film():
    cfg = PLOT_OPTS["PROFILES"]["FILM"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = (
        _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    )

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(
                ang, rpm, R, Ve, Vs, W
            )
            if textured:
                for dk in dens_keys:
                    atex_j = (
                        A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    )
                    obs = solve_theta(
                        Rj,
                        Vej,
                        Vsj,
                        Wj,
                        dt,
                        ang,
                        rpm,
                        atex_theta=atex_j,
                        shift_theta=float(shift[j]),
                        d_texture=D_TEXTURE[dk],
                        Nx=171,
                        iters=80,
                        substep_cap=6,
                        relax_p=0.85,
                        relax_h=0.55,
                        M_core=451,
                        observe=True,
                    )
                    x, h = obs["x"], obs["h"]
                    plt.figure(dpi=dpi)
                    plt.plot(
                        x * 1e3,
                        h * 1e9,
                        linewidth=lw,
                        label=f"{dk} | h(x) | θ={ang:.1f}°, {rpm} RPM",
                    )
                    plt.xlabel("x (mm)")
                    plt.ylabel("h (nm)")
                    plt.title("Film thickness vs x")
                    plt.grid(True, alpha=gA)
                    plt.legend()
                    plt.tight_layout()
            else:
                obs = solve_theta(
                    Rj,
                    Vej,
                    Vsj,
                    Wj,
                    dt,
                    ang,
                    rpm,
                    atex_theta=0.0,
                    shift_theta=0.0,
                    d_texture=D_TEXTURE["5%"],
                    Nx=171,
                    iters=80,
                    substep_cap=6,
                    relax_p=0.85,
                    relax_h=0.55,
                    M_core=451,
                    observe=True,
                )
                x, h = obs["x"], obs["h"]
                plt.figure(dpi=dpi)
                plt.plot(
                    x * 1e3,
                    h * 1e9,
                    linewidth=lw,
                    label=f"UN | h(x) | θ={ang:.1f}°, {rpm} RPM",
                )
                plt.xlabel("x (mm)")
                plt.ylabel("h (nm)")
                plt.title("Film thickness vs x")
                plt.grid(True, alpha=gA)
                plt.legend()
                plt.tight_layout()

def plot_profile_asperity():
    """
    GT asperity pressure vs X = x/a, with same controls as Reynolds pressure:
    angles, rpms, surface_state, texture_densities.
    """
    cfg = PLOT_OPTS["PROFILES"]["ASPERITY"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = (
        _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    )

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(
                ang, rpm, R, Ve, Vs, W
            )
            if textured:
                for dk in dens_keys:
                    atex_j = (
                        A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    )
                    obs = solve_theta(
                        Rj,
                        Vej,
                        Vsj,
                        Wj,
                        dt,
                        ang,
                        rpm,
                        atex_theta=atex_j,
                        shift_theta=float(shift[j]),
                        d_texture=D_TEXTURE[dk],
                        Nx=171,
                        iters=80,
                        substep_cap=6,
                        relax_p=0.85,
                        relax_h=0.55,
                        M_core=451,
                        observe=True,
                    )
                    x = obs["x"]
                    p_asp_x = obs["p_asp_x"]
                    a = float(obs["a"])
                    X = x / max(a, 1e-12)
                    plt.figure(dpi=dpi)
                    plt.plot(
                        X,
                        p_asp_x,
                        linewidth=lw,
                        label=f"{dk} | θ={ang:.1f}°, {rpm} RPM",
                    )
                    plt.xlabel("X = x/a")
                    plt.ylabel("p_asp (Pa)")
                    plt.title("GT asperity pressure vs X")
                    plt.grid(True, alpha=gA)
                    plt.legend()
                    plt.tight_layout()
            else:
                obs = solve_theta(
                    Rj,
                    Vej,
                    Vsj,
                    Wj,
                    dt,
                    ang,
                    rpm,
                    atex_theta=0.0,
                    shift_theta=0.0,
                    d_texture=D_TEXTURE["5%"],
                    Nx=171,
                    iters=80,
                    substep_cap=6,
                    relax_p=0.85,
                    relax_h=0.55,
                    M_core=451,
                    observe=True,
                )
                x = obs["x"]
                p_asp_x = obs["p_asp_x"]
                a = float(obs["a"])
                X = x / max(a, 1e-12)
                plt.figure(dpi=dpi)
                plt.plot(
                    X,
                    p_asp_x,
                    linewidth=lw,
                    label=f"UN | θ={ang:.1f}°, {rpm} RPM",
                )
                plt.xlabel("X = x/a")
                plt.ylabel("p_asp (Pa)")
                plt.title("GT asperity pressure vs X")
                plt.grid(True, alpha=gA)
                plt.legend()
                plt.tight_layout()

# ============================================================
# B–E) Angle sweeps — preserved
# ============================================================
def _angles_for(cfg_angles):
    if cfg_angles is None:
        return TH_DEG.tolist()
    return _as_list(cfg_angles)

def plot_sweep_Fh():
    cfg_all = PLOT_OPTS["SWEEPS"]
    cfg = cfg_all["Fh"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"])
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = (
        _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    )

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(
                    rpm, angles_deg, textured=True, density_key=dk
                )
                plt.plot(
                    ang,
                    Fh,
                    linewidth=lw,
                    label=f"Fh | {dk} | {rpm} RPM",
                )
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(
                rpm, angles_deg, textured=False
            )
            plt.plot(
                ang,
                Fh,
                linewidth=lw,
                label=f"Fh | UN | {rpm} RPM",
            )
    plt.xlabel("Cam angle (deg)")
    plt.ylabel("Hydrodynamic friction Fh (N)")
    plt.title("Hydrodynamic friction vs cam angle")
    plt.grid(True, alpha=gA)
    plt.legend()
    plt.tight_layout()

def plot_sweep_Fb():
    cfg_all = PLOT_OPTS["SWEEPS"]
    cfg = cfg_all["Fb"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"])
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = (
        _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    )

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(
                    rpm, angles_deg, textured=True, density_key=dk
                )
                plt.plot(
                    ang,
                    Fb,
                    linewidth=lw,
                    label=f"Fb | {dk} | {rpm} RPM",
                )
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(
                rpm, angles_deg, textured=False
            )
            plt.plot(
                ang,
                Fb,
                linewidth=lw,
                label=f"Fb | UN | {rpm} RPM",
            )
    plt.xlabel("Cam angle (deg)")
    plt.ylabel("Asperity friction Fb (N)")
    plt.title("Asperity friction vs cam angle")
    plt.grid(True, alpha=gA)
    plt.legend()
    plt.tight_layout()

def plot_sweep_Torque():
    cfg_all = PLOT_OPTS["SWEEPS"]
    cfg = cfg_all["Torque"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"])
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = (
        _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    )

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(
                    rpm, angles_deg, textured=True, density_key=dk
                )
                plt.plot(
                    ang,
                    Tq,
                    linewidth=lw,
                    label=f"T | {dk} | {rpm} RPM",
                )
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(
                rpm, angles_deg, textured=False
            )
            plt.plot(
                ang,
                Tq,
                linewidth=lw,
                label=f"T | UN | {rpm} RPM",
            )
    plt.xlabel("Cam angle (deg)")
    plt.ylabel("Friction torque T (N·m)")
    plt.title("Friction torque vs cam angle")
    plt.grid(True, alpha=gA)
    plt.legend()
    plt.tight_layout()

def plot_sweep_Wa():
    cfg_all = PLOT_OPTS["SWEEPS"]
    cfg = cfg_all["Wa"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"])
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = (
        _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    )

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(
                    rpm, angles_deg, textured=True, density_key=dk
                )
                plt.plot(
                    ang,
                    Wa,
                    linewidth=lw,
                    label=f"Wa | {dk} | {rpm} RPM",
                )
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(
                rpm, angles_deg, textured=False
            )
            plt.plot(
                ang,
                Wa,
                linewidth=lw,
                label=f"Wa | UN | {rpm} RPM",
            )
    plt.xlabel("Cam angle (deg)")
    plt.ylabel("Asperity load Wa (N)")
    plt.title("Asperity load vs cam angle")
    plt.grid(True, alpha=gA)
    plt.legend()
    plt.tight_layout()

# ============================================================
# F) Cycle-averaged torque & reductions — preserved
# ============================================================
def average_cycle_torque(rpm, angles_deg, textured=False, density_key=None):
    angles = np.asarray(angles_deg, float)
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    Tq = []
    for ang in angles:
        dt, Rj, Vej, Vsj, Wj, j = _inputs_at(
            ang, rpm, R, Ve, Vs, W
        )
        if textured:
            atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
            dtex = D_TEXTURE[density_key]
            sh_j = float(shift[j])
        else:
            atex_j = 0.0
            dtex = D_TEXTURE["5%"]
            sh_j = 0.0
        obs = solve_theta(
            Rj,
            Vej,
            Vsj,
            Wj,
            dt,
            ang,
            rpm,
            atex_theta=atex_j,
            shift_theta=sh_j,
            d_texture=dtex,
            Nx=171,
            iters=80,
            substep_cap=6,
            relax_p=0.85,
            relax_h=0.55,
            M_core=451,
            observe=True,
        )
        Tq.append(
            _torque(float(obs["Fh"]), float(obs["Fb"]), ang)
        )
    return float(np.mean(Tq))

def section_avg_torque():
    cfg = PLOT_OPTS["AVG_TORQUE"]
    if not cfg["ENABLE"]:
        return
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = (
        _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    )
    angles_deg = TH_DEG.tolist()

    print("\n=== Average friction torque over CAM cycle ===")
    for rpm in rpms:
        if not textured:
            T_un = average_cycle_torque(
                rpm, angles_deg, textured=False
            )
            print(f"RPM {rpm:>4}: UN   <T> = {T_un:.6f} N·m")
        else:
            for dk in dens_keys:
                T_tex = average_cycle_torque(
                    rpm,
                    angles_deg,
                    textured=True,
                    density_key=dk,
                )
                print(
                    f"RPM {rpm:>4}: {dk:>3} <T> = {T_tex:.6f} N·m"
                )

def section_avg_torque_reduction():
    cfg = PLOT_OPTS["AVG_TORQUE_REDUCTION"]
    if not cfg["ENABLE"]:
        return
    rpms = _as_list(cfg["rpms"])
    dens_keys = _dens_keys(cfg.get("densities_vs_UN", []))
    angles_deg = TH_DEG.tolist()

    print(
        "\n=== Average friction torque reduction vs UN (independent) ==="
    )
    for rpm in rpms:
        T_un = average_cycle_torque(
            rpm, angles_deg, textured=False
        )
        print(f"\nRPM {rpm:>4}: UN   <T> = {T_un:.6f} N·m")
        for dk in dens_keys:
            T_tex = average_cycle_torque(
                rpm,
                angles_deg,
                textured=True,
                density_key=dk,
            )
# Use a robust denominator and magnitude-based comparison to avoid blow-ups
            den = max(abs(T_un), 1e-6)
            red = 100.0 * (abs(T_un) - abs(T_tex)) / den

            print(
                f"          {dk:>3} <T> = {T_tex:.6f} N·m   (Δ% = {red:+.2f}%)"
            )

# ============================================================
# G) Optional: htex vs angle at 300 RPM — preserved
# ============================================================
def plot_htex_vs_angle_300rpm():
    cfg = PLOT_OPTS["HTEX_300RPM"]
    if not cfg["ENABLE"]:
        return
    dens_keys = _dens_keys(cfg.get("texture_densities", []))
    if len(dens_keys) == 0:
        return
    style = cfg["style"]
    lw, gA = style["lw"], style["grid_alpha"]
    rpm = 300
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    fig, axs = plt.subplots(
        len(dens_keys),
        1,
        figsize=(7, 2.6 * len(dens_keys)),
        sharex=True,
    )
    axs = np.atleast_1d(axs)
    for ax, dk in zip(axs, dens_keys):
        dtex = D_TEXTURE[dk]
        h0list = []
        for i in range(len(TH_DEG)):
            a = a_hertz(W[i], R[i])
            atex_i = (
                A_TEXTURE_CONST if TEXTURE_ZONE_MASK[i] else 0.0
            )
            h0list.append(
                htex_profile(
                    np.array([0.0]),
                    a,
                    atex_i,
                    shift[i],
                    dtex,
                )[0]
            )
        ax.plot(TH_DEG, np.array(h0list), linewidth=lw)
        ax.set_ylabel(f"htex (m)\n{dk}")
        ax.grid(True, alpha=gA)
    axs[-1].set_xlabel("Cam angle (deg)")
    fig.suptitle(
        "htex at contact center vs cam angle (300 RPM)"
    )
    plt.tight_layout(rect=[0, 0, 1, 0.95])

# ============================================================
# H) Single-variable vs cam angle (Ve, Vs, W, R, a_hertz, ph, hc)
#     (p_asp removed from here; handled separately vs X)
# ============================================================
def _variable_series(rpm, varname):
    varname = str(varname)
    valid = {"Ve", "Vs", "W", "R", "a_hertz", "ph", "hc"}
    if varname not in valid:
        raise ValueError(
            f"VARIABLE_BY_ANGLE.variable must be one of {sorted(valid)}"
        )

    R_arr, Ve_arr, Vs_arr, W_arr, w = kin_arrays(rpm)
    a_arr = np.sqrt(
        np.maximum(
            4.0
            * np.maximum(W_arr, 0.0)
            * np.maximum(R_arr, 1e-12),
            0.0,
        )
        / (np.pi * E_star * L + 1e-30)
    )
    ph_arr = (
        2.0
        * np.maximum(W_arr, 0.0)
        / (np.pi * np.maximum(a_arr, 1e-12) * L + 1e-30)
    )
    hc_arr = np.array(
        [
            central_film_thickness(
                R_arr[i], W_arr[i], Ve_arr[i]
            )
            for i in range(len(R_arr))
        ],
        dtype=float,
    )

    mapping = {
        "Ve": Ve_arr,
        "Vs": Vs_arr,
        "W": W_arr,
        "R": R_arr,
        "a_hertz": a_arr,
        "ph": ph_arr,
        "hc": hc_arr,
    }
    return TH_DEG, np.asarray(mapping[varname], dtype=float)

def plot_variable_by_angle():
    cfg = PLOT_OPTS["VARIABLE_BY_ANGLE"]
    if not cfg["ENABLE"]:
        return
    varname = cfg.get("variable", "Ve")
    style = cfg.get(
        "style", {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120}
    )
    lw = style.get("lw", 2.0)
    dpi = style.get("dpi", 120)
    gA = style.get("grid_alpha", 0.35)
    rpms = _as_list(cfg.get("rpms", [300]))

    ylabels = {
        "Ve": "Ve (m/s)",
        "Vs": "Vs (m/s)",
        "W": "W (N)",
        "R": "R (m)",
        "a_hertz": "a (m)",
        "ph": "p_h (Pa)",
        "hc": "h_c, seed (m)",
    }
    plt.figure(dpi=dpi)
    for rpm in rpms:
        ang, y = _variable_series(rpm, varname)
        plt.plot(
            ang,
            y,
            linewidth=lw,
            label=f"{varname} | {rpm} RPM",
        )
    plt.xlabel("Cam angle (deg)")
    plt.ylabel(ylabels.get(varname, varname))
    plt.title(f"{varname} vs cam angle")
    plt.grid(True, alpha=gA)
    plt.legend()
    plt.tight_layout()

# ============================================================
# Master runner
# ============================================================
def run_all():
    plot_profile_pressure()
    plot_profile_film()
    plot_profile_asperity()
    plot_htex_vs_angle_300rpm()
    plot_sweep_Fh()
    plot_sweep_Fb()
    plot_sweep_Torque()
    plot_sweep_Wa()
    plot_variable_by_angle()
    section_avg_torque()
    section_avg_torque_reduction()
    plt.show()
# ----- Execute -----
if __name__ == "__main__":
    run_all()
