# ============================================================
# PHYSICS SECTION — 1D Mixed Lubrication (Line Contact)
# Mass-conserving JFO; pressure mapped to [-1,1] (wide window);
# elastic log-kernel deflection; no film-shape clipping
# ============================================================

import os, numpy as np, pandas as pd
import matplotlib.pyplot as plt
from math import pi
plt.rcParams.update({"figure.dpi": 120})

# -----------------------
# Temperature setpoint
# -----------------------
TEMP_C = 90  # 60, 90, 110

# -----------------------
# Cam kinematics (unchanged)
# -----------------------
def _load_cam(data_dir, fname):
    path = os.path.join(data_dir, fname)
    _cam = pd.read_csv(path, sep=r"\s+", engine="python", comment="#",
                       header=None, names=["angle_deg","lift_m"], usecols=[0,1])
    _cam["angle_deg"] = pd.to_numeric(_cam["angle_deg"], errors="raise")
    _cam["lift_m"]    = pd.to_numeric(_cam["lift_m"],    errors="raise")
    return _cam.sort_values("angle_deg").reset_index(drop=True)

DATA_DIR = "/content/cam"
CAM_FILE = "CamAngle_vs_Lift_smooth.txt"
CAM = _load_cam(DATA_DIR, CAM_FILE)

th_deg = CAM["angle_deg"].to_numpy(float)
th     = np.deg2rad(th_deg)
lift   = CAM["lift_m"].to_numpy(float)


def _movavg(x, k):
    k = (int(max(3,k)) | 1)
    return np.convolve(x, np.ones(k)/k, mode="same")
dlift_s  = np.gradient(lift, th)
d2lift_s = np.gradient(dlift_s, th)

# -----------------------
# Geometry / materials
# -----------------------
rb, L = 18.5e-3, 7.2e-3
k_spring, delta, Meq = 7130.0, 1.77e-3, 0.05733
E_cam, E_tap, nu = 209e9, 216e9, 0.30
#E_star = 1.0/((1-nu**2)/E_cam + (1-nu**2)/E_tap)
E_star= 217e9
# -----------------------
# Fluid props (90 °C)
# -----------------------
ETA0_TABLE    = {60:0.04796, 90:0.01381, 110:0.008155}   # Pa·s
ALPHA_P_TABLE = {60:17e-9,   90:15e-9,   110:13e-9}      # 1/Pa
RHO0_TABLE    = {60:887.0,   90:858.44,  110:840.0}      # kg/m^3
MU_B_TABLE    = {60:0.12,    90:0.11,    110:0.10}
GAMMA_LIM_TABLE = {60:0.08,  90:0.06,    110:0.05}       # 1/Pa
LAM_C_TABLE   = {60:2.2e-6,  90:2e-6,  110:1.0e-6}     # s
N_C_TABLE     = {60:0.68,    90:0.8,    110:0.62}
PHI_IN_TABLE  = {60:0.45,    90:0.50,    110:0.55}

eta0    = ETA0_TABLE[TEMP_C]
alpha_p = ALPHA_P_TABLE[TEMP_C]
rho0    = RHO0_TABLE[TEMP_C]
mu_b    = MU_B_TABLE[TEMP_C]
phi_in_global = PHI_IN_TABLE[TEMP_C]
gamma_lim = GAMMA_LIM_TABLE[TEMP_C]
lam_c   = LAM_C_TABLE[TEMP_C]
n_c     = N_C_TABLE[TEMP_C]
eta_inf = 0.08*eta0

# -----------------------
# Greenwood–Tripp asperity pressure (unchanged)
# -----------------------
sigma_combined = 0.2e-6
beta_a         = sigma_combined/0.001
eta_R          = (0.05/(sigma_combined*beta_a))
_gt_w = np.linspace(0.0, 8.0, 400)
_lam_grid = np.linspace(0.0, 6.0, 360)
_kern = _gt_w[None,:]**1.5 * np.exp(-0.5 * (_lam_grid[:,None] + _gt_w)**2)
_F32_lookup = np.trapz(_kern, _gt_w, axis=1)/np.sqrt(2.0*np.pi)
_F32_lookup[-1] = 0.0
def asperity_pressure_greenwood_tripp(h):
    lam = np.maximum(np.asarray(h,float)/(sigma_combined+1e-18), 0.0)
    F32 = np.interp(np.clip(lam,_lam_grid[0],_lam_grid[-1]), _lam_grid, _F32_lookup)
    pref = (4.0/3.0)*E_star*np.sqrt(beta_a)*eta_R*(sigma_combined**1.5)
    return (pref*F32).reshape(lam.shape)

# -----------------------
# Rheology (DH + Houpert + Carreau + Eyring)
# -----------------------
def rho_dowson_higginson(p):
    p = np.maximum(p, 0.0)
    return rho0 * (1.0 + 0.6e-9*p) / (1.0 + 1.7e-9*p)  # DH density (EHL standard)

def eta_houpert(p):
    return np.maximum(eta0*np.exp(np.clip(alpha_p*np.maximum(p,0.0),0,23.0)), 1e-7)

def eta_carreau(etaN, h, Vs):
    gdot = np.where(h>1e-12, np.abs(Vs)/h, 0.0)
    return np.maximum(eta_inf + (etaN-eta_inf)*(1+(lam_c*gdot)**2)**((n_c-1)/2), 1e-7)

# -----------------------
# Line-contact Hertz + film seed (Hamrock–Dowson)
# -----------------------
def a_hertz(W,R):
      return np.sqrt(np.maximum(8.0*np.maximum(W,0.0)*np.maximum(R,1e-12),0.0)/(np.pi*E_star*L + 1e-30))
def ph_hertz(W,a):
    return 2.0*np.maximum(W,0.0)/(np.pi*np.maximum(a,1e-12)*L + 1e-30)

def central_film_thickness(R, W, Ve):
    """
    Hamrock–Dowson central film for line contact:
      h_c ≈ 2.69 * U^0.67 * G^0.53 * W*^-0.067 * R
    with U=(η0|U_e|)/(E*R), G=αE*, W* = W/(E* L R).
    """
    R = max(float(R), 1e-6); W = max(float(W), 1.0); Ue = float(np.abs(Ve))
    U = (eta0*Ue)/(E_star*R + 1e-30)
    G = alpha_p * E_star
    Wstar = W / (E_star*L*R + 1e-30)
    hc = 2.69 * (U**0.67) * (G**0.53) * (Wstar**-0.067) * R
    return float(np.clip(hc, 30e-9, 800e-9))  # range consistent with line-contact EHL

# -----------------------
# Kinematics (unchanged)
# -----------------------
def kin_arrays(rpm):
    w = (2*pi*rpm)/60.0
    r  = rb + lift
    R  = np.abs(r + d2lift_s)
    Vc = w*(r+d2lift_s)
    Vf = w*d2lift_s
    Ve = 0.5*(Vc + Vf)             # entrainment
    Vs = np.abs(Vc - Vf)           # sliding
    W  = k_spring*(lift + delta) + Meq*(w**2)*d2lift_s
    return R, Ve, Vs, W, w

# -----------------------
# Elastic deflection (correct line-contact kernel) + datum removal
# -----------------------
def elastic_deflection(x, p):
    x = np.asarray(x,float); p = np.asarray(p,float)
    N = len(x); dx = x[1]-x[0]; eps = 0.5*dx
    u = np.zeros_like(x)
    # u(x) = (2/(pi E*)) ∫ p(ξ) ln|x-ξ| dξ  (plane strain line contact)
    for i in range(N):
        u[i] = np.sum(p * np.log(np.sqrt((x[i]-x)**2 + eps*eps))) * dx
    u *= (2.0/(np.pi*E_star))
    return u - np.mean(u)

# -----------------------
# Texture (unchanged)
# -----------------------
w_texture, g_val, x_start = 35e-6, 1e-9, 0.0
X_IN, X_OUT = -4.5, 3.0             # display window in nondim X
D_TEXTURE = {"5%":700e-6, "8%":437.5e-6, "10%":350e-6}
A_TEXTURE_CONST = 5e-6
TEXTURE_ZONE_MASK = np.ones_like(th_deg, bool)

def integrate_shift(Vs, w):
    dtheta = np.gradient(th)
    s = np.zeros_like(Vs)
    s[1:] = np.cumsum(0.5*(Vs[1:]+Vs[:-1])/(w+1e-30)*dtheta[1:])
    return s

def htex_profile(x, a_theta, atex_theta, shift_theta, d_texture):
    if atex_theta <= 0.0 or a_theta <= 0.0: return np.zeros_like(x)
    u = ((x - x_start - shift_theta + d_texture/2.0) % d_texture) - d_texture/2.0
    expo = (np.log(g_val/atex_theta) * (u**2)) / (w_texture**2 + 1e-30)
    h = atex_theta*np.exp(expo)
    return np.where((x>=-a_theta)&(x<=a_theta), h, 0.0)

# -----------------------
# Helper: build wide-window arrays with EXACT mapping to [-1,1]
# -----------------------
def _to_wide_window_from_active(x_active, p_active, h_active, Xin=-4.5, Xout=3.0, N=1201):
    # determine first/last positive-pressure nodes (tolerant)
    pos = np.where(p_active > 1e-9*np.max(p_active))[0]
    if pos.size == 0:
        a_eff = (x_active[-1]-x_active[0])/2.0
        x0    = 0.5*(x_active[-1]+x_active[0])
    else:
        iL, iR = int(pos[0]), int(pos[-1])
        xL, xR = float(x_active[iL]), float(x_active[iR])
        a_eff  = max(0.5*(xR-xL), 1e-12)
        x0     = 0.5*(xR+xL)

    # center contact arrays and scale by a_eff so that support -> [-1,1]
    x_centered = x_active - x0

    X_full = np.linspace(Xin, Xout, N)
    p_full = np.zeros_like(X_full)
    h_full = np.full_like(X_full, np.nan, dtype=float)

    # fill only |X|<=1 from centered arrays; 0 elsewhere by construction
    mask = (X_full>=-1) & (X_full<=+1)
    if np.any(mask):
        xx = X_full[mask] * a_eff
        p_full[mask] = np.interp(xx, x_centered, p_active, left=0.0, right=0.0)
        h_full[mask] = np.interp(xx, x_centered, h_active)

    return X_full, p_full, h_full, x_centered, a_eff

# ============================================================
# CORE SOLVER — JFO outlet with mass conservation
# ============================================================
def solve_theta(
    R, Ve, Vs, W, dt, angle_deg, rpm,
    atex_theta, shift_theta, d_texture,
    Nx=401, iters=40, **_compat
):
    relax_p = _compat.get("relax_p", 0.85)
    relax_h = _compat.get("relax_h", 0.55)

    # internal grid on Hertz footprint for the coupled solve
    R=float(max(R,1e-12)); W=float(max(W,1.0))
    aH = max(a_hertz(W,R), 2e-6)
    x  = np.linspace(-aH, +aH, Nx); dx = x[1]-x[0]

    # seed film (Hamrock–Dowson) + texture (no shape clipping; small numeric epsilon)
    h0   = central_film_thickness(R, W, Ve)
    htex = htex_profile(x, aH, atex_theta, shift_theta, d_texture)
    h    = np.maximum(h0 + x**2/(2*R) + htex, 5e-9)
    p    = np.zeros_like(x)

    def fields(p_loc, h_loc):
        rho = rho_dowson_higginson(p_loc)
        eta = eta_houpert(p_loc)
        M = np.maximum((rho*h_loc**3)/(12.0*np.maximum(eta,1e-7)), 1e-18)
        F = rho*h_loc*Ve
        return rho, eta, M, F

    ixc_last = Nx-1
    for _ in range(iters):
        rho, eta, M, F = fields(p, h)

        # ---- JFO outlet: find cavitation index ixc via zero-flux condition
        def J_from_ixc(ixc):
            I1 = np.trapz(F[:ixc+1]/M[:ixc+1], x[:ixc+1])
            I2 = np.trapz(1.0/M[:ixc+1],       x[:ixc+1])
            return -I1/(I2 + 1e-30)

        lo, hi = 1, Nx-1
        Glo = F[lo]   + J_from_ixc(lo)
        Ghi = F[hi-1] + J_from_ixc(hi-1)

        if Glo*Ghi > 0:
            ixc = Nx-1; J = J_from_ixc(ixc)  # full-film fallback
        else:
            for _b in range(42):
                mid = (lo+hi)//2
                Gm  = F[mid] + J_from_ixc(mid)
                if Glo*Gm <= 0: hi, Ghi = mid, Gm
                else:           lo, Glo = mid, Gm
            ixc = hi
            if ixc >= Nx-2: ixc = Nx-1
            J = J_from_ixc(ixc)
        ixc_last = ixc

        # integrate p over [-aH, xc]; cavitated (p=0) to the right
        Gp = (F + J)/M
        p_new = np.zeros_like(p)
        p_new[1:ixc+1] = np.cumsum(0.5*(Gp[1:ixc+1] + Gp[0:ixc]) * dx)
        p_new[ixc+1:]  = 0.0
        p_new = np.maximum(p_new, 0.0)

        # relax + light smoothing only where pressurized
        p = (1-relax_p)*p + relax_p*p_new
        ptmp = p.copy()
        K0, K1 = 0.64, 0.18
        for j in range(1, ixc):
            p[j] = K1*ptmp[j-1] + K0*ptmp[j] + K1*ptmp[j+1]
        p[0]=0.0; p[-1]=0.0

        # elasticity and film update (no clipping apart from numeric epsilon)
        defl = elastic_deflection(x, p)
        h_nom = np.maximum(h0 + x**2/(2*R) + htex + defl, 5e-9)
        h = np.maximum(relax_h*h + (1.0-relax_h)*h_nom, 5e-9)

        # load closure (damped)
        Wa = np.trapz(asperity_pressure_greenwood_tripp(h), x)*L
        Wh = np.trapz(p, x)*L
        Wtot = Wa + Wh
        if abs(Wtot - W)/max(W,1e-20) > 1e-2:
            h0 = float(np.clip(h0 * (np.clip(Wtot/max(W,1e-20),1e-6,1e6)**0.5),
                               10e-9, 1.0e-6))
            h  = np.maximum(h0 + x**2/(2*R) + htex, 5e-9)

    # final film/deflection on contact grid
    defl = elastic_deflection(x, p)
    h = np.maximum(h0 + x**2/(2*R) + htex + defl, 5e-9)

    # ---- Map EXACT active support to [-1,1] and pad zeros outside
    X_full, p_full, h_full, x_centered, a_eff = _to_wide_window_from_active(x, p, h)

    # friction components
    p_asp   = asperity_pressure_greenwood_tripp(h)
    eta_eff = eta_carreau(eta_houpert(p), h, np.abs(Vs))
    tau_lim = gamma_lim*np.maximum(p,0.0)
    tau_h   = np.where(h>1e-12, (eta_eff*np.abs(Vs))/h, 0.0)
    tau_f   = np.minimum(tau_h, tau_lim)
    Fh      = np.trapz(tau_f, x)*L
    Fb      = L*np.trapz(mu_b*p_asp, x)

    # Defaults for plotting on the wide window:
    #   Pressure curve: zero baseline for |X|>1.
    #   Film curve: shown only for |X|<=1 (NaN outside).
    return {
        "X_full": X_full, "p_full": p_full, "h_full": h_full,  # wide-window arrays
        "x": x_centered, "p": p, "h": h, "a": float(a_eff),    # centered contact arrays
        "Fh": float(Fh), "Fb": float(Fb),
        "Wa": float(np.trapz(p_asp, x)*L),
        "pmax": float(np.max(p)),
    }
# ============================================================

## ============================================================
# PLOT CONTROLLER & UTILITIES — fully decoupled controls
## ============================================================

def _as_list(v):
    return list(v) if isinstance(v, (list, tuple, np.ndarray)) else [v]

# ---------------------------------------------------------------------------------
# Plot options: every figure type has its own switch + its own controls
# ---------------------------------------------------------------------------------
PLOT_OPTS = {
    # === A) Profiles ===
    "PROFILES": {
        # Pressure profiles (enable + fully independent controls)
        "PRESSURE": {
            "ENABLE": True,
            "angles_deg": [2],       # list of cam angles for pressure profiles
            "rpms": [300],              # list of RPMs for pressure profiles
            "surface_state": 0,         # 0 = UNTEXTURED, 1 = TEXTURED
            "texture_densities": [5],   # used only if surface_state==1 | values in {5,8,10}
        },
        # Film-thickness profiles (enable + fully independent controls)
        "FILM": {
            "ENABLE": True,
            "angles_deg": [2],       # list of cam angles for film profiles
            "rpms": [300],              # list of RPMs for film profiles
            "surface_state": 0,         # 0 = UNTEXTURED, 1 = TEXTURED
            "texture_densities": [5],   # used only if surface_state==1
        },
        # shared look & feel for both profile plots
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },

    # === B–E) Angle sweeps (each metric isolated) ===
    "SWEEPS": {
        # Fh(θ)
        "Fh": {
            "ENABLE": True,
            "angles_deg": None,         # None -> use full cam grid; else provide list
            "rpms": [300],
            "surface_state": 0,         # 0 = UNTEXTURED, 1 = TEXTURED
            "texture_densities": [8],   # used only if surface_state==1
        },
        # Fb(θ)
        "Fb": {
            "ENABLE": True,
            "angles_deg": None,
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        # Torque(θ)
        "Torque": {
            "ENABLE":False,
            "angles_deg": None,
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        # Wa(θ)
        "Wa": {
            "ENABLE": False,
            "angles_deg": None,
            "rpms": [300],
            "surface_state": 0,
            "texture_densities": [8],
        },
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },

    # === F) Average torque (independent from reduction) ===
    "AVG_TORQUE": {
        "ENABLE": False,
        "rpms": [300, 500],
        "surface_state": 0,           # 0=UN, 1=TEXTURED
        "texture_densities": [8],     # used only if surface_state==1
    },

    # === F-2) Average torque reduction vs UN (separate controls) ===
    "AVG_TORQUE_REDUCTION": {
        "ENABLE": False,
        "rpms": [300, 500],
        "densities_vs_UN": [8],       # compare each textured density to UN
    },

    # === G) Optional helper visualization (unchanged idea; independent)
    "HTEX_300RPM": {
        "ENABLE": False,
        "texture_densities": [5, 8, 10],
        "style": {"lw": 2.0, "grid_alpha": 0.35, "dpi": 120},
    },
}

# ---------- helpers that depend on earlier globals ----------
def _dens_keys(nums):
    """Map numeric list like [5,8,10] -> ['5%','8%','10%'] and validate."""
    mapnum = {5: '5%', 8: '8%', 10: '10%'}
    if nums is None:
        return []
    out = [mapnum[n] for n in _as_list(nums) if n in mapnum]
    if len(out) == 0 and nums not in (None, []):
        raise ValueError("No valid texture densities given. Use any of 5, 8, 10.")
    return out

def _nearest_angle_index(angle_deg):
    return int(np.argmin(np.abs(th_deg - angle_deg)))

def _arm_at(angle_deg):
    j = _nearest_angle_index(angle_deg)
    return rb + lift[j]

def _torque(Fh, Fb, angle_deg):
    return (Fh + Fb) * _arm_at(angle_deg)

def _inputs_at(angle_deg, rpm, R, Ve, Vs, W):
    w = 2*np.pi*rpm/60.0
    j = _nearest_angle_index(angle_deg)
    dtheta = float(np.mean(np.diff(th)))
    dt = dtheta / (w + 1e-30)
    return dt, float(R[j]), float(Ve[j]), float(Vs[j]), float(W[j]), j

# ---------- generic sweep with or without texture (angles are now passed in) ----------
def _sweep_series_general(rpm, angle_list_deg, textured=False, density_key=None):
    angles = np.asarray(angle_list_deg, float)
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    Fh_list, Fb_list, Tq_list, Wa_list = [], [], [], []
    for ang in angles:
        dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
        if textured:
            atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
            dtex   = D_TEXTURE[density_key]
            sh_j   = float(shift[j])
        else:
            atex_j = 0.0
            dtex   = D_TEXTURE['5%']  # unused in UN but kept for call-compat
            sh_j   = 0.0

        obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                          atex_theta=atex_j, shift_theta=sh_j,
                          d_texture=dtex,
                          Nx=171, iters=52, substep_cap=6, relax_p=0.85, relax_h=0.55,
                          M_core=451, observe=True)
        Fh, Fb, Wa = float(obs["Fh"]), float(obs["Fb"]), float(obs["Wa"])
        Tq = _torque(Fh, Fb, ang)
        Fh_list.append(Fh); Fb_list.append(Fb); Tq_list.append(Tq); Wa_list.append(Wa)
    return angles, np.asarray(Fh_list), np.asarray(Fb_list), np.asarray(Tq_list), np.asarray(Wa_list)

def plot_profile_pressure():
    cfg = PLOT_OPTS["PROFILES"]["PRESSURE"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms   = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
            if textured:
                for dk in dens_keys:
                    atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                      atex_theta=atex_j, shift_theta=float(shift[j]),
                                      d_texture=D_TEXTURE[dk],
                                      Nx=171, iters=52, substep_cap=6,
                                      relax_p=0.85, relax_h=0.55,
                                      M_core=451, observe=True)
                    x, p, a = obs["x"], obs["p"], float(obs["a"])
                    X = x/max(a,1e-12)
                    pmax = max(obs["pmax"], 1e-30)
                    p_nd = p/pmax
                    plt.figure(dpi=dpi)
                    plt.plot(X, p_nd, linewidth=lw,
                             label=f"{dk} | p/p_max | θ={ang:.1f}°, {rpm} RPM")
                    plt.xlabel("X = x/a"); plt.ylabel("p/p_max")
                    plt.title("Reynolds pressure vs X")
                    plt.xlim(-1.2, 1.5)
                    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()
            else:
                obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                  atex_theta=0.0, shift_theta=0.0, d_texture=D_TEXTURE['5%'],
                                  Nx=171, iters=52, substep_cap=6,
                                  relax_p=0.85, relax_h=0.55,
                                  M_core=451, observe=True)
                x, p, a = obs["x"], obs["p"], float(obs["a"])
                X = x/max(a,1e-12)
                pmax = max(obs["pmax"], 1e-30)
                p_nd = p/pmax
                plt.figure(dpi=dpi)
                plt.plot(X, p_nd, linewidth=lw,
                         label=f"UN | p/p_max | θ={ang:.1f}°, {rpm} RPM")
                plt.xlabel("X = x/a"); plt.ylabel("p/p_max")
                plt.title("Reynolds pressure vs X")
                plt.xlim(-1.2, 1.5)
                plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()


def plot_profile_film():
    cfg = PLOT_OPTS["PROFILES"]["FILM"]
    if not cfg["ENABLE"]:
        return
    style = PLOT_OPTS["PROFILES"]["style"]
    lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]

    rpms   = _as_list(cfg["rpms"])
    angles = _as_list(cfg["angles_deg"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    for rpm in rpms:
        R, Ve, Vs, W, w = kin_arrays(rpm)
        shift = integrate_shift(Vs, w)
        for ang in angles:
            dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
            if textured:
                for dk in dens_keys:
                    atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
                    obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                      atex_theta=atex_j, shift_theta=float(shift[j]),
                                      d_texture=D_TEXTURE[dk],
                                      Nx=171, iters=52, substep_cap=6,
                                      relax_p=0.85, relax_h=0.55,
                                      M_core=451, observe=True)
                    x, h = obs["x"], obs["h"]
                    plt.figure(dpi=dpi)
                    plt.plot(x*1e3, h*1e9, linewidth=lw,
                             label=f"{dk} | h(x) | θ={ang:.1f}°, {rpm} RPM")
                    plt.xlabel("x (mm)"); plt.ylabel("h (nm)")
                    plt.title("Film thickness vs x")
                    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()
            else:
                obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                                  atex_theta=0.0, shift_theta=0.0, d_texture=D_TEXTURE['5%'],
                                  Nx=171, iters=52, substep_cap=6,
                                  relax_p=0.85, relax_h=0.55,
                                  M_core=451, observe=True)
                x, h = obs["x"], obs["h"]
                plt.figure(dpi=dpi)
                plt.plot(x*1e3, h*1e9, linewidth=lw,
                         label=f"UN | h(x) | θ={ang:.1f}°, {rpm} RPM")
                plt.xlabel("x (mm)"); plt.ylabel("h (nm)")
                plt.title("Film thickness vs x")
                plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

# ============================================================
# B–E) Angle sweeps — each metric has its own independent cfg
# ============================================================
def _angles_for(cfg_angles):
    if cfg_angles is None:
        # default to full grid if not provided
        return th_deg.tolist()
    return _as_list(cfg_angles)

def plot_sweep_Fh():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Fh"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"])
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Fh, linewidth=lw, label=f"Fh | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Fh, linewidth=lw, label=f"Fh | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Hydrodynamic friction Fh (N)")
    plt.title("Hydrodynamic friction vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Fb():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Fb"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"])
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Fb, linewidth=lw, label=f"Fb | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Fb, linewidth=lw, label=f"Fb | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Asperity friction Fb (N)")
    plt.title("Asperity friction vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Torque():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Torque"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"])
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Tq, linewidth=lw, label=f"T | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Tq, linewidth=lw, label=f"T | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Friction torque T (N·m)")
    plt.title("Friction torque vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

def plot_sweep_Wa():
    cfg_all = PLOT_OPTS["SWEEPS"]; cfg = cfg_all["Wa"]
    if not cfg["ENABLE"]:
        return
    style = cfg_all["style"]; lw, dpi, gA = style["lw"], style["dpi"], style["grid_alpha"]
    angles_deg = _angles_for(cfg["angles_deg"])
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]

    plt.figure(dpi=dpi)
    for rpm in rpms:
        if textured:
            for dk in dens_keys:
                ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=True, density_key=dk)
                plt.plot(ang, Wa, linewidth=lw, label=f"Wa | {dk} | {rpm} RPM")
        else:
            ang, Fh, Fb, Tq, Wa = _sweep_series_general(rpm, angles_deg, textured=False)
            plt.plot(ang, Wa, linewidth=lw, label=f"Wa | UN | {rpm} RPM")
    plt.xlabel("Cam angle (deg)"); plt.ylabel("Asperity load Wa (N)")
    plt.title("Asperity load vs cam angle")
    plt.grid(True, alpha=gA); plt.legend(); plt.tight_layout()

# ============================================================
# F) Cycle-averaged torque (independent) and % reduction (independent)
# ============================================================
def average_cycle_torque(rpm, angles_deg, textured=False, density_key=None):
    angles = np.asarray(angles_deg, float)
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    Tq = []
    for ang in angles:
        dt, Rj, Vej, Vsj, Wj, j = _inputs_at(ang, rpm, R, Ve, Vs, W)
        if textured:
            atex_j = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[j] else 0.0
            dtex   = D_TEXTURE[density_key]
            sh_j   = float(shift[j])
        else:
            atex_j = 0.0
            dtex   = D_TEXTURE['5%']
            sh_j   = 0.0
        obs = solve_theta(Rj, Vej, Vsj, Wj, dt, ang, rpm,
                          atex_theta=atex_j, shift_theta=sh_j,
                          d_texture=dtex,
                          Nx=171, iters=52, substep_cap=6, relax_p=0.85, relax_h=0.55,
                          M_core=451, observe=True)
        Tq.append(_torque(float(obs["Fh"]), float(obs["Fb"]), ang))
    return float(np.mean(Tq))

def section_avg_torque():
    cfg = PLOT_OPTS["AVG_TORQUE"]
    if not cfg["ENABLE"]:
        return
    rpms = _as_list(cfg["rpms"])
    textured = bool(cfg.get("surface_state", 0))
    dens_keys = _dens_keys(cfg.get("texture_densities", [])) if textured else ["UN"]
    angles_deg = th_deg.tolist()

    print("\n=== Average friction torque over cycle (independent) ===")
    for rpm in rpms:
        if not textured:
            T_un = average_cycle_torque(rpm, angles_deg, textured=False)
            print(f"RPM {rpm:>4}: UN   <T> = {T_un:.6f} N·m")
        else:
            for dk in dens_keys:
                T_tex = average_cycle_torque(rpm, angles_deg, textured=True, density_key=dk)
                print(f"RPM {rpm:>4}: {dk:>3} <T> = {T_tex:.6f} N·m")

def section_avg_torque_reduction():
    cfg = PLOT_OPTS["AVG_TORQUE_REDUCTION"]
    if not cfg["ENABLE"]:
        return
    rpms = _as_list(cfg["rpms"])
    dens_keys = _dens_keys(cfg.get("densities_vs_UN", []))
    angles_deg = th_deg.tolist()

    print("\n=== Average friction torque reduction vs UN (independent) ===")
    for rpm in rpms:
        T_un = average_cycle_torque(rpm, angles_deg, textured=False)
        print(f"\nRPM {rpm:>4}: UN   <T> = {T_un:.6f} N·m")
        for dk in dens_keys:
            T_tex = average_cycle_torque(rpm, angles_deg, textured=True, density_key=dk)
            red = 100.0*(T_un - T_tex)/abs(T_un) if abs(T_un) > 1e-12 else 0.0
            print(f"          {dk:>3} <T> = {T_tex:.6f} N·m   (Δ% = {red:+.2f}%)")

# ============================================================
# G) Optional: htex vs angle at 300 RPM — independent switch
# ============================================================
def plot_htex_vs_angle_300rpm():
    cfg = PLOT_OPTS["HTEX_300RPM"]
    if not cfg["ENABLE"]:
        return
    dens_keys = _dens_keys(cfg.get("texture_densities", []))
    if len(dens_keys) == 0:
        return
    style = cfg["style"]; lw, gA = style["lw"], style["grid_alpha"]
    rpm = 300
    R, Ve, Vs, W, w = kin_arrays(rpm)
    shift = integrate_shift(Vs, w)
    fig, axs = plt.subplots(len(dens_keys), 1, figsize=(7, 2.6*len(dens_keys)), sharex=True)
    axs = np.atleast_1d(axs)
    for ax, dk in zip(axs, dens_keys):
        dtex = D_TEXTURE[dk]
        h0 = []
        for i in range(len(th_deg)):
            a = a_hertz(W[i], R[i])
            atex_i = A_TEXTURE_CONST if TEXTURE_ZONE_MASK[i] else 0.0
            h0.append(htex_profile(np.array([0.0]), a, atex_i, shift[i], dtex)[0])
        ax.plot(th_deg, np.array(h0), linewidth=lw)
        ax.set_ylabel(f"htex (m)\n{dk}"); ax.grid(True, alpha=gA)
    axs[-1].set_xlabel("Cam angle (deg)")
    fig.suptitle("htex at contact center vs cam angle (300 RPM)")
    plt.tight_layout(rect=[0, 0, 1, 0.95])

# ============================================================
# Master runner (calls only what is enabled)
# ============================================================
def run_all():
    # A) Profiles (independent toggles)
    plot_profile_pressure()
    plot_profile_film()

    # G) Optional htex helper (independent)
    plot_htex_vs_angle_300rpm()

    # B–E) Independent sweeps
    plot_sweep_Fh()
    plot_sweep_Fb()
    plot_sweep_Torque()
    plot_sweep_Wa()

    # F) Independent averages
    section_avg_torque()
    section_avg_torque_reduction()

    plt.show()

# ----- Execute -----
if __name__ == "__main__":
    run_all()

