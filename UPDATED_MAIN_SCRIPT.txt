"""Mixed lubrication torque model with textured film-thickness offsets.

This script loads the precomputed :math:`a_\text{texture}` tables, applies the
texture-attached model, and evaluates the mixed-lubrication torque reduction
for each RPM and texture density case.
"""
from __future__ import annotations

from pathlib import Path␊
from typing import Callable, Dict, Sequence, Tuple

import numpy as np
from numpy.fft import irfft, rfft

# ---------------- Paths & data ----------------
# Resolve repository root even when __file__ is undefined (e.g. in Colab).
try:
    ROOT = Path(__file__).resolve().parent
except NameError:
    ROOT = Path.cwd()
CAM_PROFILE_PATH = ROOT / "CamAngle_vs_Lift_smooth.txt"
W_TEXTURE = 35e-6
G_TEXTURE = 1e-9
X_IN = -4.5
X_OUT = 3.0
X_START = 0.0

TEXTURE_CASES = {
    "htex5": {
        "label": "Htex 5%",
        "d_texture": 700e-6,
        "area_fraction": 0.05,
        "output": ROOT / "a_texture_5_percent.txt",
    },
    "htex8": {
        "label": "Htex 8%",
        "d_texture": 437.5e-6,
        "area_fraction": 0.08,
        "output": ROOT / "a_texture_8_percent.txt",
    },
    "htex10": {
        "label": "Htex 10%",
        "d_texture": 350e-6,
        "area_fraction": 0.10,
        "output": ROOT / "a_texture_10_percent.txt",
    },
}

TEXTURE_KEYS = ("htex5", "htex8", "htex10")

# Load the cam lift profile.
data = np.loadtxt(CAM_PROFILE_PATH)
th_deg = data[:, 0]
th = np.deg2rad(th_deg)
lift = data[:, 1]

# Numerical derivatives of lift with respect to cam rotation.
dId = np.gradient(lift, th)
d2Id = np.gradient(dId, th)

# ---------------- Constants (user) ----------------
rb = 18.5e-3
k_spring = 7130.0
delta = 1.77e-3
Meq = 0.05733

E_cam = 209e9
E_tap = 216e9
nu = 0.30
E_star = 1.0 / ((1 - nu**2) / E_cam + (1 - nu**2) / E_tap)
L = 7.2e-3
eta0 = 0.01381
rho0 = 858.44
alpha_p = 15e-9
mu_b = 0.12

# ---------------- Rheology models ----------------

def eta_houpert(p: np.ndarray) -> np.ndarray:
    clipped = np.clip(alpha_p * np.maximum(p, 0.0), 0.0, 23.0)
    return np.maximum(eta0 * np.exp(clipped), 1e-7)


def eta_carreau(etaN: np.ndarray, h: np.ndarray, Vs: np.ndarray) -> np.ndarray:
    eta_inf = 0.1 * eta0
    lam_c = 2e-6
    n_c = 0.80
    gdot = np.where(h > 1e-12, np.abs(Vs) / h, 0.0)
    return np.maximum(eta_inf + (etaN - eta_inf) * (1 + (lam_c * gdot) ** 2) ** ((n_c - 1) / 2), 1e-7)


def gamma_eyr() -> float:
    log = np.log10
    eta1, eta2, eta3 = 129.0, 13.5, 15.5
    T1, T2 = 40.0, 100.0
    rho0_local = 858.44
    ASTM = (log((log(eta1 + 0.7)) / (log(eta2 + 0.7)))) / (T2 / T1)
    g = (
        -5.0662
        + 8.8630 * (log(eta3)) ** (-0.07662)
        + 0.0312 * (ASTM**3.3611) * (log(eta3)) ** (-0.6271)
        - 0.1189 * (log(eta3)) ** (-5.4743) * (rho0_local) ** (-23.5841)
    ) / 100.0
    return max(g, 0.0)


gamma_lim = gamma_eyr()

# ---------------- Kinematics ----------------

def kin(rpm: float) -> Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    w = 2 * np.pi * rpm / 60.0
    R = np.abs(rb + lift + d2Id)
    Vf = w * d2Id
    Vc = w * (rb + lift + d2Id)
    Ve = 0.5 * (Vc + Vf)
    Vs = np.abs(Vc - Vf)
    W = k_spring * (lift + delta) + Meq * (w**2) * d2Id
    return w, R, Ve, Vs, W


def a_hertz(W: float, R: float) -> float:
    return float(np.sqrt(np.maximum(2 * np.maximum(W, 0.0) * np.maximum(R, 1e-12), 0.0) / (np.pi * E_star * L + 1e-30)))


def ph_hertz(W: float, a: float) -> float:
    return float(2.0 * np.maximum(W, 0.0) / (np.pi * np.maximum(a, 1e-12) * L + 1e-30))


# ---------------- Numerical helpers ----------------

def elastic_deflection(x: np.ndarray, p: np.ndarray) -> np.ndarray:
    N = len(x)
    dx = x[1] - x[0]
    xi = x - x[0]
    kernel = np.log(np.sqrt(xi * xi + dx * dx))
@@ -121,74 +149,88 @@ def rusanov_div_bc(u: float, q: np.ndarray, dx: float, q_in_left: float, q_in_ri
    qR[:-1] = q
    qL[0] = q_in_left
    qR[0] = q[0]
    qL[-1] = q[-1]
    qR[-1] = q_in_right
    F = 0.5 * (u * (qL + qR)) - 0.5 * np.abs(u) * (qR - qL)
    return (F[1:] - F[:-1]) / (dx + 1e-30)


class HtexProfile:
    """Interpolates texture-induced film-thickness offsets vs cam angle."""

    def __init__(self, theta_deg: np.ndarray, values: np.ndarray) -> None:
        idx = np.argsort(theta_deg)
        self.theta = theta_deg[idx]
        self.values = values[idx]
        self.left = float(self.values[0])
        self.right = float(self.values[-1])

    def __call__(self, theta_deg: float) -> float:
        return float(np.interp(theta_deg, self.theta, self.values, left=self.left, right=self.right))


# ---------------- Mixed lubrication solver ----------------

def solve_theta(␊
    R: float,
    Ve: float,
    Vs: float,
    W: float,
    dt: float,
    h_prev: np.ndarray | None = None,
    phi_in: float = 0.5,
    Nx: int = 201,
    iters: int = 12,
    substep_cap: int = 12,
    relax_p: float = 0.5,
    relax_h: float = 0.5,
    htex_offset: float = 0.0,
) -> Tuple[
    np.ndarray,
    np.ndarray,
    np.ndarray,
    float,
    float,
    float,
    float,
    float,
    float,
    np.ndarray,
    np.ndarray,
    float,
    float,
    float,
]:
    R = float(max(R, 1e-12))
    W = float(max(W, 1.0))
    a = max(a_hertz(W, R), 2e-6)
    xL, xR = -4.5 * a, 3.0 * a
    x = np.linspace(xL, xR, Nx)
    dx = x[1] - x[0]

    base_gap = max(180e-9 + htex_offset, 5e-9)
    if h_prev is None:
        h = np.maximum(base_gap + x**2 / (2 * R), 5e-9)
        G = phi_in * h
    else:
        xp = np.linspace(xL, xR, len(h_prev))
        h = np.maximum(np.interp(x, xp, h_prev), 5e-9)
        G = phi_in * h

    p = np.zeros(Nx)
    core = np.abs(x) <= a
    if np.any(core):
        ph = ph_hertz(W, a)
        p[core] = ph * np.sqrt(np.maximum(1 - (x[core] / a) ** 2, 0.0))

    cfl = abs(Ve) * dt / (dx + 1e-30)
    substeps = int(min(max(3, np.ceil(cfl / 0.35)), substep_cap))
    dts = dt / max(substeps, 1)

    for _ in range(substeps):
        G_in_L = phi_in * h[0]
        G_in_R = phi_in * h[-1]
        G = np.clip(G - dts * rusanov_div_bc(Ve, G, dx, G_in_L, G_in_R), 0.0, h)

        for _ in range(iters):
            etaN = eta_houpert(p)
@@ -223,146 +265,174 @@ def solve_theta(
                RHS[i] -= wfac * RHS[i - 1]
            p_new = np.zeros(Nx)
            p_new[-1] = RHS[-1] / (B[-1] + 1e-30)
            for i in range(Nx - 2, -1, -1):
                p_new[i] = (RHS[i] - C[i] * p_new[i + 1]) / (B[i] + 1e-30)

            Wh_trial = np.trapz(np.maximum(p_new, 0.0), x) * L
            s = 1.0
            if Wh_trial > 1e-12:
                s = 0.5 * s + 0.5 * min(1.6, max(0.4, W / Wh_trial))
            p = np.maximum(
                (1 - relax_p) * p + relax_p * np.minimum(p_new * s, 3.0 * ph_hertz(W, a)),
                0.0,
            )

            press = p > 0
            G = np.clip(np.where(press, h, G), 0.0, h)
            defl = elastic_deflection(x, p)
            target_gap = base_gap + x**2 / (2 * R) + defl
            h = np.maximum((1 - relax_h) * h + relax_h * target_gap, 5e-9)

    eta_eff = eta_carreau(eta_houpert(p), h, Vs)
    tau = np.minimum(np.where(h > 1e-12, eta_eff * np.abs(Vs) / h, 0.0), gamma_lim * p)
    Fh = np.trapz(tau, x) * L
    Wh = np.trapz(p, x) * L
    Wa = max(W - Wh, 0.0)
    Fb = mu_b * Wa

    a = max(a, 1e-12)
    ph = ph_hertz(W, a)
    X = x / a
    P = p / np.maximum(ph, 1e-12)
    W_star = W / (np.maximum(ph * a * L, 1e-30))
    Pa_bar = Wa / (np.maximum(ph * a * L, 1e-30))
    resid = np.trapz(P, X) + Pa_bar - W_star

    return x, h, p, Fh, Fb, Wh, Wa, a, ph, X, P, W_star, Pa_bar, resid


def avg_cycle(
    rpm: float,
    htex_profile: Callable[[float], float] | None = None,
    idx_step: int = 45,
    Nx: int = 61,
    iters: int = 4,
    substep_cap: int = 4,
) -> float:
    w, R, Ve, Vs, W = kin(rpm)
    dt = float(np.mean(np.diff(th)) / (w + 1e-30))
    idxs = np.arange(0, len(th), idx_step)
    h_prev = None
    torques = []
    for i in idxs:
        htex_offset = 0.0 if htex_profile is None else htex_profile(th_deg[i])
        x, h, p, Fh, Fb, *_ = solve_theta(
            R[i],
            Ve[i],
            Vs[i],
            W[i],
            dt,
            h_prev,
            phi_in=0.5,
            Nx=Nx,
            iters=iters,
            substep_cap=substep_cap,
            relax_p=0.5,
            relax_h=0.5,
            htex_offset=htex_offset,
        )
        torques.append((Fh + Fb) * (rb + lift[i]))
        h_prev = h
    return float(np.mean(torques))


RPM_LIST = [300, 500, 700, 900]

SMOOTH_TORQUES: Dict[int, float] = {}


def get_smooth_torque(rpm: int) -> float:
    if rpm not in SMOOTH_TORQUES:
        SMOOTH_TORQUES[rpm] = avg_cycle(rpm)
    return SMOOTH_TORQUES[rpm]


class TextureAttachedModel:
    """Texture-attached model that serves offsets from :math:`a_\text{texture}` tables."""

    def __init__(
        self,
        theta_deg: np.ndarray,
        rpm_list: Sequence[int],
        area_fraction: float,
        d_texture: float,
        table_path: Path,
    ) -> None:
        self.theta_deg = theta_deg
        self.rpm_list = rpm_list
        self.area_fraction = area_fraction
        self.d_texture = d_texture
        self.table_path = table_path
        self._a_texture: Dict[int, np.ndarray] = {}
        self._load_a_texture()

    def _load_a_texture(self) -> None:
        data = np.loadtxt(self.table_path, comments="#")
        if data.shape[1] != len(self.rpm_list) + 1:
            raise ValueError(
                f"Unexpected column count in {self.table_path}: {data.shape[1]} vs {len(self.rpm_list) + 1}"
            )

        theta = data[:, 0]
        if not np.allclose(theta, self.theta_deg, atol=1e-8):
            self.theta_deg = theta

        for idx, rpm in enumerate(self.rpm_list, start=1):
            self._a_texture[rpm] = data[:, idx]

    def profile(self, rpm: int) -> HtexProfile:
        if rpm not in self._a_texture:
            raise KeyError(f"RPM {rpm} not found in a_texture table {self.table_path}")
        return HtexProfile(self.theta_deg, self._a_texture[rpm])


RPM_TUPLE = tuple(RPM_LIST)

TEXTURE_MODELS: Dict[str, TextureAttachedModel] = {}
for key in TEXTURE_KEYS:
    params = TEXTURE_CASES[key]
    TEXTURE_MODELS[key] = TextureAttachedModel(
        th_deg,
        RPM_TUPLE,
        params["area_fraction"],
        params["d_texture"],
        params["output"],
    )


def compute_texture_reductions() -> Dict[str, Dict[int, float]]:
    """Compute percentage torque reductions for each dataset and RPM."""

    smooth_torques = {rpm: get_smooth_torque(rpm) for rpm in RPM_LIST}
    reductions: Dict[str, Dict[int, float]] = {}

    for key, params in TEXTURE_CASES.items():
        model = TEXTURE_MODELS[key]
        label = params["label"]
        reductions[label] = {}
        for rpm in RPM_LIST:
            profile = model.profile(rpm)
            textured_torque = avg_cycle(rpm, profile)
            smooth_torque = smooth_torques[rpm]
            reduction = 100.0 * (1.0 - textured_torque / smooth_torque)
            reductions[label][rpm] = reduction

    return reductions


def format_reduction_table(reductions: Dict[str, Dict[int, float]]) -> str:
    headers = ["RPM"] + [TEXTURE_CASES[key]["label"] for key in TEXTURE_KEYS]
    lines = ["\t".join(headers)]
    for rpm in RPM_LIST:
        row = [f"{rpm}"]
        for key in TEXTURE_KEYS:
            label = TEXTURE_CASES[key]["label"]
            value = reductions[label].get(rpm, float("nan"))
            row.append(f"{value:.2f}%")
        lines.append("\t".join(row))
    return "\n".join(lines)


if __name__ == "__main__":
    reduction_map = compute_texture_reductions()
    print(format_reduction_table(reduction_map))