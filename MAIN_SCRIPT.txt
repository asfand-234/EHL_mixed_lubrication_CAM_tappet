# Mixed-lubrication CAM–tappet with migrating line-texture on shim (1D Reynolds, mass-conserving).
# Physics identical to your baseline: Houpert + Carreau + Eyring, elastic line contact, content transport (G=phi*h),
# cavitation switching, Hertz-core pressure support, migrating line textures, zero-volume correction, appearance rule.
# Change vs. baseline: a_tex is now read from 3 amplitude files (per density, per RPM, vs. cam angle).

import os, numpy as np, pandas as pd
from numpy.fft import rfft, irfft

# ---------- Validate required files ----------
required_files = [
    "CamAngle_vs_Lift_smooth.txt",
    "amplitude_5_percent.txt",
    "amplitude_8_percent.txt",
    "amplitude_10_percent.txt",
]
missing = [f for f in required_files if not os.path.exists(f)]
assert not missing, f"Missing required file(s): {missing}\nUpload them or place them in the working directory."

# ---------- Load cam kinematics ----------
# Expect a two-column ASCII file: [cam_angle_deg, lift_m]
cam = np.loadtxt("CamAngle_vs_Lift_smooth.txt")
assert cam.ndim == 2 and cam.shape[1] >= 2, "Cam file must have at least 2 columns: angle_deg, lift."
th_deg = cam[:,0]                    # degrees
lift   = cam[:,1]                    # meters
th     = np.deg2rad(th_deg)         # radians

# Numerical derivatives vs. angle (radians)
dlift  = np.gradient(lift, th)
d2lift = np.gradient(dlift, th)

# ---------- Constants (unchanged physics) ----------
rb      = 18.5e-3      # base circle radius [m]
k_spring= 7130.0       # N/m
delta   = 1.77e-3      # pre-load [m]
Meq     = 0.05733      # kg

E_cam=209e9; E_tap=216e9; nu=0.30
E_star = 1.0/((1-nu**2)/E_cam + (1-nu**2)/E_tap)
L      = 7.2e-3        # contact length (axial) [m]

eta0    = 0.01381      # Pa·s (ref)
alpha_p = 15e-9        # 1/Pa
mu_b    = 0.12         # boundary friction coefficient

def eta_houpert(p):
    return np.maximum(eta0*np.exp(np.clip(alpha_p*np.maximum(p,0.0),0,23.0)), 1e-7)

eta_inf = 0.1*eta0
lam_c   = 2e-6
n_c     = 0.80
def eta_carreau(etaN,h,Vs):
    gdot = np.where(h>1e-12, np.abs(Vs)/h, 0.0)
    return np.maximum(eta_inf + (etaN-eta_inf)*(1+(lam_c*gdot)**2)**((n_c-1)/2), 1e-7)

def gamma_eyr():
    # crude ASTM-style limiter (kept exactly to match your baseline behavior)
    log=np.log10; eta1,eta2,eta3=129.0,13.5,15.5; T1,T2=40.0,100.0; rho0_local=858.44
    ASTM=(log((log(eta1+0.7))/(log(eta2+0.7))))/(T2/T1)
    g=(-5.0662 + 8.8630*(log(eta3))**(-0.07662) + 0.0312*(ASTM**3.3611)*(log(eta3))**(-0.6271) - 0.1189*(log(eta3))**(-5.4743)*(rho0_local)**(-23.5841))/100.0
    return max(g,0.0)
gamma_lim = gamma_eyr()

# Kinematics at RPM
def kin(rpm):
    w = 2*np.pi*rpm/60.0
    R  = np.abs(rb+lift+d2lift)        # local radius [m]
    Vf = w*d2lift                      # follower surf speed (x) [m/s]
    Vc = w*(rb+lift+d2lift)            # cam surf speed [m/s]
    Ve = 0.5*(Vc+Vf)                   # mean entrainment [m/s]
    Vs = np.abs(Vc - Vf)               # sliding [m/s]
    W  = k_spring*(lift + delta) + Meq*(w**2)*d2lift  # load [N]
    return w,R,Ve,Vs,W

# Hertzian line-contact geometry
def a_hertz(W,R):
    return np.sqrt(np.maximum(2*np.maximum(W,0.0)*np.maximum(R,1e-12),0.0)/(np.pi*E_star*L + 1e-30))
def ph_hertz(W,a):
    return 2.0*np.maximum(W,0.0)/(np.pi*np.maximum(a,1e-12)*L + 1e-30)

# Elastic deflection (line kernel via FFT)
def elastic_deflection(x, p):
    N=len(x); dx=x[1]-x[0]
    xi = x - x[0]
    k  = np.log(np.sqrt(xi*xi + dx*dx)); k -= np.mean(k)
    P = rfft(p); K = rfft(k); conv = irfft(P*K, n=N)*dx
    return (2.0/(np.pi*E_star))*conv

# Upwind/Rusanov divergence for transported quantity
def rusanov_div_bc(u, q, dx, q_in_left, q_in_right):
    N=len(q)
    qL = np.empty(N+1); qR = np.empty(N+1)
    qL[1:] = q; qR[:-1] = q
    qL[0] = q_in_left; qR[0] = q[0]
    qL[-1] = q[-1];     qR[-1] = q_in_right
    F = 0.5*(u*(qL+qR)) - 0.5*np.abs(u)*(qR - qL)
    return (F[1:] - F[:-1])/(dx + 1e-30)

# ---------- Texture parameters (same as baseline) ----------
w_tex   = 35e-6   # groove width scale [m]
g_min   = 1e-9    # groove minimum [m]
x_start = 0.0
d_tex_map = {0.05: 700e-6, 0.08: 437.5e-6, 0.10: 350e-6}  # area density -> pitch [m]

# ---------- Load amplitude datasets ----------
def _read_amp_table(path):
    # Accepts TSV/CSV/space-separated; expects 5 columns.
    df = pd.read_csv(path, sep=None, engine="python", header=0)
    if df.shape[1] != 5:
        # maybe no header: re-read with no header and assign names
        df = pd.read_csv(path, sep=None, engine="python", header=None)
        assert df.shape[1] == 5, f"{path} must have exactly 5 columns."
        df.columns = ["angle_deg","amp_300","amp_500","amp_700","amp_900"]
    else:
        # if header present, enforce consistent names
        df.columns = ["angle_deg","amp_300","amp_500","amp_700","amp_900"]
    # Basic sanity
    assert np.all(np.isfinite(df.values)), f"Non-finite values in {path}"
    return {
        "angle": df["angle_deg"].to_numpy(dtype=float),
        300: df["amp_300"].to_numpy(dtype=float),
        500: df["amp_500"].to_numpy(dtype=float),
        700: df["amp_700"].to_numpy(dtype=float),
        900: df["amp_900"].to_numpy(dtype=float),
    }

amp_tables = {
    0.05: _read_amp_table("amplitude_5_percent.txt"),
    0.08: _read_amp_table("amplitude_8_percent.txt"),
    0.10: _read_amp_table("amplitude_10_percent.txt"),
}

# Piecewise-linear interpolate a_tex vs angle for given RPM & density
def a_tex_lookup(angle_deg, rpm, area_density):
    tab  = amp_tables[area_density]
    ang  = tab["angle"]
    vals = tab[int(rpm)]
    return float(np.interp(angle_deg, ang, vals, left=vals[0], right=vals[-1]))

# Migrating shift accumulator (texture entrainment by follower speed)
def make_shift_accumulator():
    state = {"S": 0.0}
    def step(Vf, dt, d_tex):
        state["S"] = (state["S"] + Vf*dt) % d_tex
        return state["S"]
    return step
shift_step = make_shift_accumulator()

# Texture profile using dataset-sourced a_tex_now
def texture_profile(x, a, Vf, dt, d_tex, a_tex_now):
    S = shift_step(Vf, dt, d_tex)
    if (2*a)/w_tex < 1.5:                 # appearance rule: single groove if Hertz width too small
        d_eff = 10.0*(2*a)
        arg = ( ( ( (x - 0.0 - 0.0 + d_eff/2.0) % d_eff ) - d_eff/2.0 ) / w_tex )**2
    else:
        arg = ( ( ( (x - x_start - S + d_tex/2.0) % d_tex ) - d_tex/2.0 ) / w_tex )**2

    # analytic “log-Gaussian” groove (volume-neutral after correction)
    h_raw = a_tex_now * np.exp( np.log(g_min / max(a_tex_now,1e-15)) * arg )

    # zero-volume correction on the computational window
    h_corr = h_raw - np.trapz(h_raw, x)/max((x[-1]-x[0]),1e-30)
    return h_corr

# Core solver at a cam angle
def solve_theta(R, Ve, Vs, W, dt, angle_deg, rpm, textured=False, d_tex=None, a_tex_now=None,
                phi_in=0.5, Nx=171, iters=8, substep_cap=10, relax_p=0.5, relax_h=0.5):
    R=float(max(R,1e-12)); W=float(max(W,1.0))
    a=max(a_hertz(W,R),2e-6)
    xL,xR=-4.5*a,3.0*a; x=np.linspace(xL,xR,Nx); dx=x[1]-x[0]
    core = (np.abs(x) <= a)

    # initial film (parabolic + nominal clearance)
    hc = 180e-9
    h = np.maximum(hc + x**2/(2*R), 5e-9)

    # add migrated texture if enabled
    if textured and (d_tex is not None) and (a_tex_now is not None):
        h += texture_profile(x, a, Ve, dt, d_tex, a_tex_now)

    # initialize content and pressure
    G = phi_in*h.copy()
    p = np.zeros(Nx)
    if np.any(core):
        ph=ph_hertz(W,a); p[core]=ph*np.sqrt(np.maximum(1-(x[core]/a)**2,0.0))

    # CFL substepping
    cfl      = abs(Ve)*dt/(dx+1e-30)
    substeps = int(min(max(3,np.ceil(cfl/0.35)), substep_cap))
    dts      = dt/max(substeps,1)

    for _ in range(substeps):
        G_in_L = phi_in*h[0]; G_in_R = phi_in*h[-1]
        G = np.clip(G - dts*rusanov_div_bc(Ve, G, dx, G_in_L, G_in_R), 0.0, h)

        for _it in range(iters):
            etaN=eta_houpert(p); eta=eta_carreau(etaN,h,Vs)
            D = np.zeros_like(h); D[core] = h[core]**3/(12.0*np.maximum(eta[core],1e-7))

            press=(p>0)
            Q = np.where(press,h,G)
            divUQ = rusanov_div_bc(Ve, Q, dx, G_in_L, G_in_R)
            S_term = (np.where(press,h,G)-G)/max(dts,1e-12) + divUQ

            # tri-diagonal in core; p=0 elsewhere
            A=np.zeros(Nx); B=np.zeros(Nx); C=np.zeros(Nx); RHS=np.zeros(Nx)
            invdx2=1.0/(dx*dx + 1e-30)
            for i in range(1,Nx-1):
                if not core[i]:
                    B[i]=1.0; RHS[i]=0.0
                else:
                    De=0.5*(D[i]+D[i+1]); Dw=0.5*(D[i]+D[i-1])
                    A[i] = -Dw*invdx2
                    C[i] = -De*invdx2
                    B[i] = -(A[i]+C[i] + 1e-30)
                    RHS[i] = S_term[i]
            for i in range(1,Nx):
                wfac=A[i]/(B[i-1]+1e-30); B[i]-=wfac*C[i-1]; RHS[i]-=wfac*RHS[i-1]
            p_new=np.zeros(Nx); p_new[-1]=RHS[-1]/(B[-1]+1e-30)
            for i in range(Nx-2,-1,-1): p_new[i]=(RHS[i]-C[i]*p_new[i+1])/(B[i]+1e-30)

            # enforce load via mild scaling, cap peak pressure
            Wh_trial = np.trapz(np.maximum(p_new,0.0), x)*L
            ph_cap   = ph_hertz(W,a)
            s = 1.0
            if Wh_trial>1e-12:
                s = 0.5*s + 0.5*min(1.6, max(0.4, W/Wh_trial))
            p = np.maximum((1-relax_p)*p + relax_p*np.minimum(p_new*s, 3.0*ph_cap), 0.0)

            # cavitation switch and elastic update
            press = p>0
            G = np.clip(np.where(press, h, G), 0.0, h)

            defl  = elastic_deflection(x, p)
            h_nom = np.maximum(180e-9 + x**2/(2*R) + defl, 5e-9)
            if textured and (d_tex is not None) and (a_tex_now is not None):
                h = np.maximum((1-relax_h)*h + relax_h*( h_nom + texture_profile(x, a, Ve, dts, d_tex, a_tex_now) ), 5e-9)
            else:
                h = np.maximum((1-relax_h)*h + relax_h*( h_nom ), 5e-9)

    # friction split: hydrodynamic + boundary
    eta_eff=eta_carreau(eta_houpert(p),h,Vs)
    tau   = np.minimum(np.where(h>1e-12, eta_eff*np.abs(Vs)/h, 0.0), gamma_lim * p)
    Fh    = np.trapz(tau, x)*L
    Wh    = np.trapz(p, x)*L
    Wa    = max(W-Wh, 0.0)
    Fb    = mu_b*Wa
    return (Fh+Fb)

# Cycle-averaged torque using amplitude datasets
def avg_cycle(rpm, textured=False, area_density=None):
    w,R,Ve,Vs,W = kin(rpm)
    dt   = float(np.mean(np.diff(th))/(w + 1e-30))
    idxs = np.arange(0,len(th),10)  # sub-sample over angle for runtime
    Tqs  = []

    if textured:
        d_tex = d_tex_map[area_density]
    else:
        d_tex = None

    # reset migrating shift accumulator each call
    global shift_step
    shift_step = make_shift_accumulator()

    for i in idxs:
        angle_deg  = th_deg[i]
        a_tex_now  = a_tex_lookup(angle_deg, rpm, area_density) if textured else None
        T = solve_theta(R[i],Ve[i],Vs[i],W[i],dt, angle_deg, rpm,
                        textured=textured, d_tex=d_tex, a_tex_now=a_tex_now,
                        phi_in=0.5, Nx=171, iters=8, substep_cap=10, relax_p=0.5, relax_h=0.5)
        # torque arm ≈ instantaneous cam radius
        Tqs.append(T * (rb + lift[i]))
    return float(np.mean(Tqs))

# ---------- Run study and print table ----------
rpms      = [300, 500, 700, 900]
densities = [0.05, 0.08, 0.10]

results = []
for rpm in rpms:
    T_un = avg_cycle(rpm, textured=False)
    for ad in densities:
        T_tx = avg_cycle(rpm, textured=True, area_density=ad)
        red  = 100.0*(T_un - T_tx)/max(T_un, 1e-12)
        results.append([rpm, f"{int(ad*100)}%", red])

df_out = pd.DataFrame(results, columns=["RPM", "Area density", "% Avg friction torque reduction vs. untextured"])
print(df_out.to_string(index=False))
