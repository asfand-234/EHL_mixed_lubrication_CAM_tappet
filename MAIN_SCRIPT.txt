# Mixed-lubrication CAM–tappet with migrating line-texture on shim (1D Reynolds, mass-conserving).
# We compute cycle-averaged friction torque for: untextured, and textured at 5%, 8%, 10% area densities,
# then report % reduction vs. untextured for RPM ∈ {300, 500, 700, 900}.
#
# Notes for robustness:
# - Non-negative pressure (p >= 0), Dirichlet p=0 at x-boundaries
# - Pressure operator is restricted to the Hertzian core |x|<=a so p=0 outside [-a, a]
# - Mass-conserving Swift–Stieber style cavitation via transported content G = φ h with φ∈[0,1]
# - Elastic deformation by convolution (FFT-based)
# - Viscosity: Houpert pressure-thickening + Carreau shear thinning; Eyring shear cap
# - Texture: migrating, entrained by follower velocity; zero-volume correction each step;
#   appearance criterion: if 2a / w_texture < 1.5 then only a single groove is allowed inside |x|<=a.
#
# IMPORTANT: The texture profile follows the user's formula
#   h_tex(x) = a_texture * exp( ln(g / a_texture) * ((mod(x - x_start - Shift + d_tex/2, d_tex) - d_tex/2)/w_texture)**2 )
# and is added to the nominal film (with zero-mean correction over the computational window).
#
# Runtime guardrails:
# - Grid is modest (Nx≈181..221) and substepped by CFL; iteration counts trimmed to finish <300 s.
# - We reuse the converged h from the previous angle as initial guess.
#
# The final cell prints ONLY a small table of % torque reduction numbers as requested.

import numpy as np, pandas as pd
from numpy.fft import rfft, irfft
from caas_jupyter_tools import display_dataframe_to_user

# ---------------- Input data (cam kinematics) ----------------
data = np.loadtxt("/mnt/data/CamAngle_vs_Lift_smooth.txt")
th_deg = data[:,0]; lift = data[:,1]
th = np.deg2rad(th_deg)
dlift = np.gradient(lift, th)
d2lift = np.gradient(dlift, th)

# ---------------- Constants (from user's baseline and prompt) ----------------
rb = 18.5e-3                  # base circle radius [m]
k_spring = 7130.0             # N/m
delta = 1.77e-3               # pre-load [m]
Meq = 0.05733                 # kg (equivalent mass)

E_cam=209e9; E_tap=216e9; nu=0.30
E_star = 1.0/((1-nu**2)/E_cam + (1-nu**2)/E_tap)
L = 7.2e-3                    # contact length (axial) [m]

# Viscosity model
eta0 = 0.01381                # Pa·s (40C ref)
rho0 = 858.44                 # kg/m^3 (unused)
alpha_p = 15e-9               # 1/Pa
mu_b = 0.12                   # boundary friction coefficient

def eta_houpert(p):
    return np.maximum(eta0*np.exp(np.clip(alpha_p*np.maximum(p,0.0),0,23.0)), 1e-7)

eta_inf = 0.1*eta0
lam_c = 2e-6
n_c = 0.80
def eta_carreau(etaN,h,Vs):
    gdot = np.where(h>1e-12, np.abs(Vs)/h, 0.0)
    return np.maximum(eta_inf + (etaN-eta_inf)*(1+(lam_c*gdot)**2)**((n_c-1)/2), 1e-7)

def gamma_eyr():
    # crude ASTM-based limiter, consistent with the provided baseline
    log=np.log10; eta1,eta2,eta3=129.0,13.5,15.5; T1,T2=40.0,100.0; rho0_local=858.44
    ASTM=(log((log(eta1+0.7))/(log(eta2+0.7))))/(T2/T1)
    g=(-5.0662 + 8.8630*(log(eta3))**(-0.07662) + 0.0312*(ASTM**3.3611)*(log(eta3))**(-0.6271) - 0.1189*(log(eta3))**(-5.4743)*(rho0_local)**(-23.5841))/100.0
    return max(g,0.0)
gamma_lim = gamma_eyr()

# Kinematics
def kin(rpm):
    w=2*np.pi*rpm/60.0
    R=np.abs(rb+lift+d2lift)                   # local radius
    Vf=w*d2lift                                # follower surface speed along x
    Vc=w*(rb+lift+d2lift)                      # cam surface speed
    Ve=0.5*(Vc+Vf)                             # mean entrainment
    Vs=np.abs(Vc - Vf)                         # sliding
    W = k_spring*(lift + delta) + Meq*(w**2)*d2lift  # load
    return w,R,Ve,Vs,W

# Hertzian geometry
def a_hertz(W,R): 
    return np.sqrt(np.maximum(2*np.maximum(W,0.0)*np.maximum(R,1e-12),0.0)/(np.pi*E_star*L + 1e-30))
def ph_hertz(W,a): 
    return 2.0*np.maximum(W,0.0)/(np.pi*np.maximum(a,1e-12)*L + 1e-30)

# Elastic deflection (line contact kernel, periodic padding via FFT)
def elastic_deflection(x, p):
    N=len(x); dx=x[1]-x[0]
    xi = x - x[0]
    k = np.log(np.sqrt(xi*xi + dx*dx)); k -= np.mean(k)
    P = rfft(p); K = rfft(k); conv = irfft(P*K, n=N)*dx
    return (2.0/(np.pi*E_star))*conv

# Upwinded transport for G = φ h
def rusanov_div_bc(u, q, dx, q_in_left, q_in_right):
    N=len(q)
    qL = np.empty(N+1); qR = np.empty(N+1)
    qL[1:] = q; qR[:-1] = q
    qL[0] = q_in_left; qR[0] = q[0]
    qL[-1] = q[-1];     qR[-1] = q_in_right
    F = 0.5*(u*(qL+qR)) - 0.5*np.abs(u)*(qR - qL)
    return (F[1:] - F[:-1])/(dx + 1e-30)

# ---------------- Texture parameters (from prompt) ----------------
w_tex = 35e-6   # width of one groove [m]
g_min = 1e-9    # groove minimum (nm scale)
a_tex = 5e-6    # shaping amplitude (µm)
x_start = 0.0
d_tex_map = {0.05: 700e-6, 0.08: 437.5e-6, 0.10: 350e-6}  # area density → pitch

# Migrating shift state (integral of Vf)
def make_shift_accumulator():
    state = {"S": 0.0}
    def step(Vf, dt, d_tex):
        state["S"] = (state["S"] + Vf*dt) % d_tex
        return state["S"]
    return step
shift_step = make_shift_accumulator()

# Build texture height (zero-mean corrected over the current x-window), with appearance rule
def texture_profile(x, a, Vf, dt, d_tex):
    # appearance rule I): if window too small, force a single groove centered at 0
    S = shift_step(Vf, dt, d_tex)
    if (2*a)/w_tex < 1.5:
        # center a single groove at x=0; emulate with very large pitch
        d_eff = 10.0*(2*a)   # effectively one feature
        arg = ( ( ( (x - 0.0 - 0.0 + d_eff/2.0) % d_eff ) - d_eff/2.0 ) / w_tex )**2
    else:
        arg = ( ( ( (x - x_start - S + d_tex/2.0) % d_tex ) - d_tex/2.0 ) / w_tex )**2
    h_raw = a_tex * np.exp( np.log(g_min / a_tex) * arg )   # user's formula

    # Zero-volume correction over computational window to avoid artificial pumping bias
    h_corr = h_raw - np.trapz(h_raw, x)/np.maximum((x[-1]-x[0]),1e-30)

    return h_corr

# Core solver at a cam angle
def solve_theta(R, Ve, Vs, W, dt, textured=False, d_tex=None, phi_in=0.5,
                Nx=191, iters=10, substep_cap=10, relax_p=0.5, relax_h=0.5):
    R=float(max(R,1e-12)); W=float(max(W,1.0))
    a=max(a_hertz(W,R),2e-6)
    xL,xR=-4.5*a,3.0*a; x=np.linspace(xL,xR,Nx); dx=x[1]-x[0]
    core = (np.abs(x) <= a)  # restrict pressure operator support

    # initial film (parabolic + nominal clearance)
    hc = 180e-9
    h = np.maximum(hc + x**2/(2*R), 5e-9)

    # Add texture if requested (zero-mean corrected)
    if textured and (d_tex is not None):
        h += texture_profile(x, a, Ve, dt, d_tex)

    # Initialize content and pressure with Hertz footprint
    G = phi_in*h.copy()
    p=np.zeros(Nx); 
    if np.any(core):
        ph=ph_hertz(W,a); p[core]=ph*np.sqrt(np.maximum(1-(x[core]/a)**2,0.0))

    # CFL-based substepping
    cfl=abs(Ve)*dt/(dx+1e-30)
    substeps=int(min(max(3,np.ceil(cfl/0.35)), substep_cap))
    dts=dt/max(substeps,1)

    for _ in range(substeps):
        G_in_L = phi_in*h[0]; G_in_R = phi_in*h[-1]
        G = np.clip(G - dts*rusanov_div_bc(Ve, G, dx, G_in_L, G_in_R), 0.0, h)

        # Newton-like fixed-point on (p, h)
        for _it in range(iters):
            etaN=eta_houpert(p); eta=eta_carreau(etaN,h,Vs)
            D = np.zeros_like(h); D[core] = h[core]**3/(12.0*np.maximum(eta[core],1e-7))

            press=(p>0)
            Q=np.where(press,h,G)

            divUQ = rusanov_div_bc(Ve, Q, dx, G_in_L, G_in_R)

            S=(np.where(press,h,G)-G)/max(dts,1e-12) + divUQ

            # Tridiagonal solve only on the core |x|<=a, p=0 outside (stability + correct support)
            A=np.zeros(Nx); B=np.zeros(Nx); C=np.zeros(Nx); RHS=np.zeros(Nx)
            invdx2=1.0/(dx*dx + 1e-30)
            # boundary nodes: p=0 (already in arrays)
            for i in range(1,Nx-1):
                if not core[i]: 
                    B[i]=1.0; RHS[i]=0.0
                else:
                    De=0.5*(D[i]+D[i+1]); Dw=0.5*(D[i]+D[i-1])
                    A[i] = -Dw*invdx2
                    C[i] = -De*invdx2
                    B[i] = -(A[i]+C[i] + 1e-30)
                    RHS[i] = S[i]
            # forward/backward elimination
            for i in range(1,Nx):
                wfac=A[i]/(B[i-1]+1e-30); B[i]-=wfac*C[i-1]; RHS[i]-=wfac*RHS[i-1]
            p_new=np.zeros(Nx); p_new[-1]=RHS[-1]/(B[-1]+1e-30)
            for i in range(Nx-2,-1,-1): p_new[i]=(RHS[i]-C[i]*p_new[i+1])/(B[i]+1e-30)

            # Enforce load by mild scaling, cap at 3×Hertz peak; clamp negative to zero
            Wh_trial = np.trapz(np.maximum(p_new,0.0), x)*L
            ph_cap = ph_hertz(W,a)
            s = 1.0
            if Wh_trial>1e-12:
                s = 0.5*s + 0.5*min(1.6, max(0.4, W/Wh_trial))
            p = np.maximum((1-relax_p)*p + relax_p*np.minimum(p_new*s, 3.0*ph_cap), 0.0)

            # Cavitation switch & elastic deflection
            press = p>0
            G = np.clip(np.where(press, h, G), 0.0, h)

            defl = elastic_deflection(x, p)
            h_nom = np.maximum(hc + x**2/(2*R) + defl, 5e-9)
            if textured and (d_tex is not None):
                h = np.maximum((1-relax_h)*h + relax_h*( h_nom + texture_profile(x, a, Ve, dts, d_tex) ), 5e-9)
            else:
                h = np.maximum((1-relax_h)*h + relax_h*( h_nom ), 5e-9)

    # Friction split
    eta_eff=eta_carreau(eta_houpert(p),h,Vs)
    tau=np.minimum(np.where(h>1e-12, eta_eff*np.abs(Vs)/h, 0.0), gamma_lim * p)
    Fh=np.trapz(tau, x)*L
    Wh=np.trapz(p, x)*L
    Wa=max(W-Wh, 0.0)
    Fb=mu_b*Wa

    # Return torque about cam center
    return (Fh+Fb)

# Cycle-averaged torque
def avg_cycle(rpm, textured=False, area_density=None):
    w,R,Ve,Vs,W = kin(rpm)
    dt = float(np.mean(np.diff(th))/(w + 1e-30))
    idxs=np.arange(0,len(th),10)
    Tqs=[]
    if textured:
        d_tex = d_tex_map[area_density]
    else:
        d_tex = None

    # reset migrating shift each cycle average call
    global shift_step
    shift_step = make_shift_accumulator()

    for i in idxs:
        T = solve_theta(R[i],Ve[i],Vs[i],W[i],dt,
                        textured=textured, d_tex=d_tex,
                        phi_in=0.5, Nx=171, iters=8, substep_cap=10, relax_p=0.5, relax_h=0.5)
        # lever arm ≈ instantaneous cam radius
        Tqs.append(T * (rb + lift[i]))
    return float(np.mean(Tqs))

# ------- Evaluation across RPM and densities -------
rpms = [300, 500, 700, 900]
densities = [0.05, 0.08, 0.10]

results = []
for rpm in rpms:
    T_un = avg_cycle(rpm, textured=False)
    for ad in densities:
        T_tx = avg_cycle(rpm, textured=True, area_density=ad)
        red = 100.0*(T_un - T_tx)/max(T_un, 1e-12)
        results.append([rpm, f"{int(ad*100)}%", red])

df = pd.DataFrame(results, columns=["RPM", "Area density", "% Avg friction torque reduction vs. untextured"])

# Present ONLY the requested table
display_dataframe_to_user("Predicted % averaged friction torque reduction (mixed lubrication with migrating line textures)", df)
print(df)
