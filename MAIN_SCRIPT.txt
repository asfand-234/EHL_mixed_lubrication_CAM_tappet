import numpy as np, matplotlib.pyplot as plt, pandas as pd
from numpy.fft import rfft, irfft

# ---------------- Data ----------------
data = np.loadtxt("/mnt/data/CamAngle_vs_Lift_smooth.txt")
th_deg = data[:,0]; lift = data[:,1]
th = np.deg2rad(th_deg)
dId = np.gradient(lift, th); d2Id = np.gradient(dId, th)

# ---------------- Constants (user) ----------------
rb = 18.5e-3
k_spring = 7130.0
delta = 1.77e-3
Meq = 0.05733

E_cam=209e9; E_tap=216e9; nu=0.30
E_star = 1.0/((1-nu**2)/E_cam + (1-nu**2)/E_tap)
L = 7.2e-3
eta0 = 0.01381
rho0 = 858.44
alpha_p = 15e-9
mu_b = 0.12

def eta_houpert(p): return np.maximum(eta0*np.exp(np.clip(alpha_p*np.maximum(p,0.0),0,23.0)), 1e-7)
eta_inf=0.1*eta0; lam_c=2e-6; n_c=0.80
def eta_carreau(etaN,h,Vs):
    gdot = np.where(h>1e-12, np.abs(Vs)/h, 0.0)
    return np.maximum(eta_inf + (etaN-eta_inf)*(1+(lam_c*gdot)**2)**((n_c-1)/2), 1e-7)
def gamma_eyr():
    log=np.log10; eta1,eta2,eta3=129.0,13.5,15.5; T1,T2=40.0,100.0; rho0_local=858.44
    ASTM=(log((log(eta1+0.7))/(log(eta2+0.7))))/(T2/T1)
    g=(-5.0662 + 8.8630*(log(eta3))**(-0.07662) + 0.0312*(ASTM**3.3611)*(log(eta3))**(-0.6271) - 0.1189*(log(eta3))**(-5.4743)*(rho0_local)**(-23.5841))/100.0
    return max(g,0.0)
gamma_lim = gamma_eyr()

def kin(rpm):
    w=2*np.pi*rpm/60.0
    R=np.abs(rb+lift+d2Id)
    Vf=w*d2Id; Vc=w*(rb+lift+d2Id)
    Ve=0.5*(Vc+Vf)
    Vs=np.abs(Vc - Vf)
    W = k_spring*(lift + delta) + Meq*(w**2)*d2Id
    return w,R,Ve,Vs,W

def a_hertz(W,R): 
    return np.sqrt(np.maximum(2*np.maximum(W,0.0)*np.maximum(R,1e-12),0.0)/(np.pi*E_star*L + 1e-30))
def ph_hertz(W,a): 
    return 2.0*np.maximum(W,0.0)/(np.pi*np.maximum(a,1e-12)*L + 1e-30)

def elastic_deflection(x, p):
    N=len(x); dx=x[1]-x[0]
    xi = x - x[0]
    k = np.log(np.sqrt(xi*xi + dx*dx)); k -= np.mean(k)
    P = rfft(p); K = rfft(k); conv = irfft(P*K, n=N)*dx
    return (2.0/(np.pi*E_star))*conv

def rusanov_div_bc(u, q, dx, q_in_left, q_in_right):
    N=len(q)
    qL = np.empty(N+1); qR = np.empty(N+1)
    qL[1:] = q; qR[:-1] = q
    qL[0] = q_in_left; qR[0] = q[0]
    qL[-1] = q[-1];     qR[-1] = q_in_right
    F = 0.5*(u*(qL+qR)) - 0.5*np.abs(u)*(qR - qL)
    return (F[1:] - F[:-1])/(dx + 1e-30)

def solve_theta(R, Ve, Vs, W, dt, h_prev=None, phi_in=0.5,
                Nx=201, iters=12, substep_cap=12, relax_p=0.5, relax_h=0.5, theta_deg=0.0):
    R=float(max(R,1e-12)); W=float(max(W,1.0))
    a=max(a_hertz(W,R),2e-6)
    xL,xR=-4.5*a,3.0*a; x=np.linspace(xL,xR,Nx); dx=x[1]-x[0]

    if h_prev is None:
        hc = 180e-9
        h = np.maximum(hc + x**2/(2*R), 5e-9)
        G = phi_in*h
    else:
        xp=np.linspace(xL,xR,len(h_prev))
        h = np.maximum(np.interp(x,xp,h_prev), 5e-9)
        G = phi_in*h

    p=np.zeros(Nx); core=np.abs(x)<=a
    if np.any(core):
        ph=ph_hertz(W,a); p[core]=ph*np.sqrt(np.maximum(1-(x[core]/a)**2,0.0))

    cfl=abs(Ve)*dt/(dx+1e-30)
    substeps=int(min(max(3,np.ceil(cfl/0.35)), substep_cap))
    dts=dt/max(substeps,1)

    for ss in range(substeps):
        G_in_L = phi_in*h[0]; G_in_R = phi_in*h[-1]
        G = np.clip(G - dts*rusanov_div_bc(Ve, G, dx, G_in_L, G_in_R), 0.0, h)

        for _ in range(iters):
            etaN=eta_houpert(p); eta=eta_carreau(etaN,h,Vs)
            D=h**3/(12.0*np.maximum(eta,1e-7))

            press=(p>0)
            Q=np.where(press,h,G)

            divUQ = rusanov_div_bc(Ve, Q, dx, G_in_L, G_in_R)

            S=(np.where(press,h,G)-G)/max(dts,1e-12) + divUQ

            De=0.5*(D[1:]+D[:-1]); Dw=De
            A=np.zeros(Nx); B=np.zeros(Nx); C=np.zeros(Nx); RHS=np.zeros(Nx)
            B[0]=1.0; RHS[0]=0.0; B[-1]=1.0; RHS[-1]=0.0
            invdx2=1.0/(dx*dx + 1e-30)
            for i in range(1,Nx-1):
                A[i] = -Dw[i-1]*invdx2
                C[i] = -De[i]*invdx2
                B[i] = -(A[i]+C[i] + 1e-30)
                RHS[i] = S[i]
            for i in range(1,Nx):
                wfac=A[i]/(B[i-1]+1e-30); B[i]-=wfac*C[i-1]; RHS[i]-=wfac*RHS[i-1]
            p_new=np.zeros(Nx); p_new[-1]=RHS[-1]/(B[-1]+1e-30)
            for i in range(Nx-2,-1,-1): p_new[i]=(RHS[i]-C[i]*p_new[i+1])/(B[i]+1e-30)

            Wh_trial = np.trapz(np.maximum(p_new,0.0), x)*L
            s = 1.0
            if Wh_trial>1e-12:
                s = 0.5*s + 0.5*min(1.6, max(0.4, W/Wh_trial))
            p = np.maximum((1-relax_p)*p + relax_p*np.minimum(p_new*s, 3.0*ph_hertz(W,a)), 0.0)

            press = p>0
            G = np.clip(np.where(press, h, G), 0.0, h)
            defl = elastic_deflection(x, p)
            h = np.maximum((1-relax_h)*h + relax_h*( (180e-9) + x**2/(2*R) + defl ), 5e-9)

    eta_eff=eta_carreau(eta_houpert(p),h,Vs)
    tau=np.minimum(np.where(h>1e-12, eta_eff*np.abs(Vs)/h, 0.0), gamma_lim * p)
    Fh=np.trapz(tau, x)*L
    Wh=np.trapz(p, x)*L
    Wa=max(W-Wh, 0.0)
    Fb=mu_b*Wa

    a = max(a, 1e-12)
    ph = ph_hertz(W,a)
    X = x/a; P = p/np.maximum(ph,1e-12)
    W_star = W/(np.maximum(ph*a*L,1e-30))
    Pa_bar = Wa/(np.maximum(ph*a*L,1e-30))
    resid = np.trapz(P, X) + Pa_bar - W_star

    return x,h,p,Fh,Fb,Wh,Wa,a,ph,X,P,W_star,Pa_bar,resid

# 500 RPM run
rpm=500
w,R,Ve,Vs,W = kin(rpm)
dt = float(np.mean(np.diff(th))/(w + 1e-30))

idxs = np.arange(0, len(th), 6)
FhL=[]; FbL=[]; TqL=[]; ResL=[]
h_prev=None
for i in idxs:
    x,h,p,Fh,Fb,Wh,Wa,a,ph,X,P,W_star,Pa_bar,resid = solve_theta(R[i],Ve[i],Vs[i],W[i],dt,
                                                                 h_prev,phi_in=0.5,
                                                                 Nx=221,iters=12,substep_cap=12,
                                                                 relax_p=0.5,relax_h=0.5,theta_deg=th_deg[i])
    FhL.append(Fh); FbL.append(Fb); TqL.append((Fh+Fb)*(rb+lift[i])); ResL.append(resid)
    h_prev=h

plt.figure(); plt.plot(th_deg[idxs], FhL); plt.xlabel("θ (deg)"); plt.ylabel("Hydrodynamic friction (N)"); plt.title("Hydrodynamic friction vs θ (500 RPM) — dimensional balance"); plt.grid(True)
plt.figure(); plt.plot(th_deg[idxs], FbL); plt.xlabel("θ (deg)"); plt.ylabel("Boundary friction (N)"); plt.title("Boundary friction vs θ (500 RPM)"); plt.grid(True)
plt.figure(); plt.plot(th_deg[idxs], TqL); plt.xlabel("θ (deg)"); plt.ylabel("Friction torque (N·m)"); plt.title("Total friction torque vs θ (500 RPM)"); plt.grid(True)
plt.figure(); plt.plot(th_deg[idxs], ResL); plt.xlabel("θ (deg)"); plt.ylabel("Residual = ∫P dX + Pa_bar − W*"); plt.title("Diagnostic residual (no factor-2) — 500 RPM"); plt.grid(True)

# Pressure profiles at θ = −34°, 0°, +20°
def pressure_profiles_at(rpm, degs, Nx=301):
    w,R,Ve,Vs,W = kin(rpm)
    dt = float(np.mean(np.diff(th))/(w + 1e-30))
    out=[]
    for ang in degs:
        k = int(np.argmin(np.abs(th_deg - ang)))
        x,h,p,Fh,Fb,Wh,Wa,a,ph,X,P,W_star,Pa_bar,resid = solve_theta(R[k],Ve[k],Vs[k],W[k],dt,
                                                                     None,phi_in=0.5,
                                                                     Nx=Nx,iters=14,substep_cap=14,
                                                                     relax_p=0.5,relax_h=0.5,theta_deg=th_deg[k])
        out.append((ang,x,p,X,P))
    return out

for ang,xp,pp,Xd,Pd in pressure_profiles_at(500, [-34.0, 0.0, 20.0], Nx=301):
    plt.figure(); plt.plot(xp*1e3, pp/1e6); plt.xlabel("x (mm)"); plt.ylabel("p (MPa)"); plt.title(f"Dimensional pressure at θ={ang:.0f}° (500 RPM)"); plt.grid(True)
    plt.figure(); plt.plot(Xd, Pd); plt.xlabel("X=x/a"); plt.ylabel("P=p/ph"); plt.title(f"Nondim P at θ={ang:.0f}° (500 RPM)"); plt.ylim([0,1.3]); plt.grid(True)

# Averages table
def avg_cycle(rpm):
    w,R,Ve,Vs,W = kin(rpm); dt=float(np.mean(np.diff(th))/(w+1e-30))
    idxs=np.arange(0,len(th),10); h_prev=None; Tqs=[]
    for i in idxs:
        x,h,p,Fh,Fb,Wh,Wa,a,ph,X,P,W_star,Pa_bar,resid = solve_theta(R[i],Ve[i],Vs[i],W[i],dt,
                                                                     h_prev,phi_in=0.5,
                                                                     Nx=181,iters=10,substep_cap=12,
                                                                     relax_p=0.5,relax_h=0.5,theta_deg=th_deg[i])
        Tqs.append((Fh+Fb)*(rb+lift[i])); h_prev=h
    return float(np.mean(Tqs))

rows=[[300, avg_cycle(300)],
      [500, avg_cycle(500)],
      [700, avg_cycle(700)],
      [900, avg_cycle(900)]]
df=pd.DataFrame(rows, columns=["RPM","Average friction torque (N·m)"])
from caas_jupyter_tools import display_dataframe_to_user
display_dataframe_to_user("Cycle-averaged friction torque (dimensional balance, refined)", df)
print(df)
